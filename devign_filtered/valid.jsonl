{"code":"static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n","idx":2,"target":0}
{"code":"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n","idx":4,"target":0}
{"code":"static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) \/ 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n","idx":5,"target":1}
{"code":"static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);","idx":8,"target":1}
{"code":"static void test_init(TestData *d)\n\n{\n\n    QPCIBus *bus;\n\n    QTestState *qs;\n\n    char *s;\n\n\n\n    s = g_strdup_printf(\"-machine q35 %s %s\",\n\n                        d->noreboot ? \"\" : \"-global ICH9-LPC.noreboot=false\",\n\n                        !d->args ? \"\" : d->args);\n\n    qs = qtest_start(s);\n\n    qtest_irq_intercept_in(qs, \"ioapic\");\n\n    g_free(s);\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));\n\n    g_assert(d->dev != NULL);\n\n\n\n    qpci_device_enable(d->dev);\n\n\n\n    \/* set ACPI PM I\/O space base address *\/\n\n    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);\n\n    \/* enable ACPI I\/O *\/\n\n    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);\n\n    \/* set Root Complex BAR *\/\n\n    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);\n\n\n\n    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);\n\n}\n","idx":9,"target":1}
{"code":"static inline int64_t sub64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a - b;\n\n}\n","idx":10,"target":1}
{"code":"void assert_avoptions(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t;\n\n    if ((t = av_dict_get(m, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Option %s not found.\\n\", t->key);\n\n        exit(1);\n\n    }\n\n}\n","idx":11,"target":1}
{"code":"int net_init_tap(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    const char *ifname;\n\n\n\n    ifname = qemu_opt_get(opts, \"ifname\");\n\n\n\n    if (!ifname) {\n\n        error_report(\"tap: no interface name\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap_win32_init(vlan, \"tap\", name, ifname) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":14,"target":1}
{"code":"void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n","idx":15,"target":1}
{"code":"av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n","idx":19,"target":0}
{"code":"static void quantize_mantissas(AC3EncodeContext *s)\n\n{\n\n    int blk, ch;\n\n\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        AC3Block *block = &s->blocks[blk];\n\n        s->mant1_cnt  = s->mant2_cnt  = s->mant4_cnt  = 0;\n\n        s->qmant1_ptr = s->qmant2_ptr = s->qmant4_ptr = NULL;\n\n\n\n        for (ch = 0; ch < s->channels; ch++) {\n\n            quantize_mantissas_blk_ch(s, block->fixed_coef[ch], block->exp_shift[ch],\n\n                                      block->exp[ch], block->bap[ch],\n\n                                      block->qmant[ch], s->nb_coefs[ch]);\n\n        }\n\n    }\n\n}\n","idx":21,"target":1}
{"code":"static void emulated_push_error(EmulatedState *card, uint64_t code)\n\n{\n\n    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));\n\n\n\n    assert(event);\n\n    event->p.error.type = EMUL_ERROR;\n\n    event->p.error.code = code;\n\n    emulated_push_event(card, event);\n\n}\n","idx":22,"target":1}
{"code":"int av_packet_ref(AVPacket *dst, AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n    } else\n\n        dst->buf = av_buffer_ref(src->buf);\n\n\n\n    dst->size = src->size;\n\n    dst->data = dst->buf->data;\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n","idx":28,"target":0}
{"code":"av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}\n","idx":29,"target":0}
{"code":"static av_cold int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n","idx":31,"target":0}
{"code":"void helper_slbie(CPUPPCState *env, target_ulong addr)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    ppc_slb_t *slb;\n\n\n\n    slb = slb_lookup(cpu, addr);\n\n    if (!slb) {\n\n        return;\n\n    }\n\n\n\n    if (slb->esid & SLB_ESID_V) {\n\n        slb->esid &= ~SLB_ESID_V;\n\n\n\n        \/* XXX: given the fact that segment size is 256 MB or 1TB,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask)\n\n         *      in QEMU, we just invalidate all TLBs\n\n         *\/\n\n        tlb_flush(CPU(cpu), 1);\n\n    }\n\n}\n","idx":33,"target":1}
{"code":"static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr)\n\n{\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n\n\n    \/* MSR:POW cannot be set by any form of rfi *\/\n\n    msr &= ~(1ULL << MSR_POW);\n\n\n\n#if defined(TARGET_PPC64)\n\n    \/* Switching to 32-bit ? Crop the nip *\/\n\n    if (!msr_is_64bit(env, msr)) {\n\n        nip = (uint32_t)nip;\n\n    }\n\n#else\n\n    nip = (uint32_t)nip;\n\n#endif\n\n    \/* XXX: beware: this is false if VLE is supported *\/\n\n    env->nip = nip & ~((target_ulong)0x00000003);\n\n    hreg_store_msr(env, msr, 1);\n\n#if defined(DEBUG_OP)\n\n    cpu_dump_rfi(env->nip, env->msr);\n\n#endif\n\n    \/* No need to raise an exception here,\n\n     * as rfi is always the last insn of a TB\n\n     *\/\n\n    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n\n\n    \/* Context synchronizing: check if TCG TLB needs flush *\/\n\n    check_tlb_flush(env);\n\n}\n","idx":34,"target":1}
{"code":"static void d3d11va_device_uninit(AVHWDeviceContext *hwdev)\n\n{\n\n    AVD3D11VADeviceContext *device_hwctx = hwdev->hwctx;\n\n\n\n    if (device_hwctx->device)\n\n        ID3D11Device_Release(device_hwctx->device);\n\n\n\n    if (device_hwctx->device_context)\n\n        ID3D11DeviceContext_Release(device_hwctx->device_context);\n\n\n\n    if (device_hwctx->video_device)\n\n        ID3D11VideoDevice_Release(device_hwctx->video_device);\n\n\n\n    if (device_hwctx->video_context)\n\n        ID3D11VideoContext_Release(device_hwctx->video_context);\n\n\n\n    if (device_hwctx->lock == d3d11va_default_lock)\n\n        CloseHandle(device_hwctx->lock_ctx);\n\n}\n","idx":36,"target":1}
{"code":"void hmp_info_io_apic(Monitor *mon, const QDict *qdict)\n\n{\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_ioapic_dump_state(mon, qdict);\n\n    } else {\n\n        ioapic_dump_state(mon, qdict);\n\n    }\n\n}\n","idx":41,"target":1}
{"code":"static av_cold int split_init(AVFilterContext *ctx)\n\n{\n\n    SplitContext *s = ctx->priv;\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_outputs; i++) {\n\n        char name[32];\n\n        AVFilterPad pad = { 0 };\n\n\n\n        snprintf(name, sizeof(name), \"output%d\", i);\n\n        pad.type = ctx->filter->inputs[0].type;\n\n        pad.name = av_strdup(name);\n\n        if (!pad.name)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ff_insert_outpad(ctx, i, &pad);\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":42,"target":1}
{"code":"static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; \/* clear head *\/\n\n    \/* put signature *\/\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n","idx":44,"target":0}
{"code":"void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}\n","idx":45,"target":0}
{"code":"static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n","idx":47,"target":0}
{"code":"void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n}\n","idx":48,"target":0}
{"code":"static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}\n","idx":49,"target":0}
{"code":"static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}\n","idx":50,"target":0}
{"code":"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n","idx":51,"target":0}
{"code":"void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}\n","idx":52,"target":0}
{"code":"static void usb_hid_changed(HIDState *hs)\n\n{\n\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n\n\n\n    us->changed = 1;\n\n\n\n    if (us->datain) {\n\n        us->datain(us->datain_opaque);\n\n    }\n\n\n\n    usb_wakeup(&us->dev);\n\n}\n","idx":54,"target":0}
{"code":"static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        \/* fallthrough *\/\n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}\n","idx":55,"target":0}
{"code":"void aio_context_setup(AioContext *ctx)\n\n{\n\n}\n","idx":57,"target":0}
{"code":"static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}\n","idx":58,"target":0}
{"code":"void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}\n","idx":59,"target":0}
{"code":"static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (blit_is_unsafe(s, false))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n","idx":63,"target":0}
{"code":"static void listener_add_address_space(MemoryListener *listener,\n\n                                       AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n    FlatRange *fr;\n\n\n\n    if (listener->address_space_filter\n\n        && listener->address_space_filter != as) {\n\n        return;\n\n    }\n\n\n\n    if (global_dirty_log) {\n\n        if (listener->log_global_start) {\n\n            listener->log_global_start(listener);\n\n        }\n\n    }\n\n\n\n    view = as->current_map;\n\n    FOR_EACH_FLAT_RANGE(fr, view) {\n\n        MemoryRegionSection section = {\n\n            .mr = fr->mr,\n\n            .address_space = as,\n\n            .offset_within_region = fr->offset_in_region,\n\n            .size = fr->addr.size,\n\n            .offset_within_address_space = int128_get64(fr->addr.start),\n\n            .readonly = fr->readonly,\n\n        };\n\n        if (listener->region_add) {\n\n            listener->region_add(listener, &section);\n\n        }\n\n    }\n\n}\n","idx":65,"target":0}
{"code":"long do_sigreturn(CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr = env->aregs[7] - 4;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int d0, i;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    \/* set blocked signals *\/\n\n\n\n    if (__get_user(target_set.sig[0], &frame->sc.sc_mask))\n\n        goto badframe;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    \/* restore registers *\/\n\n\n\n    if (restore_sigcontext(env, &frame->sc, &d0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return d0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n","idx":66,"target":0}
{"code":"static inline bool vhost_needs_vring_endian(VirtIODevice *vdev)\n\n{\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        return false;\n\n    }\n\n#ifdef TARGET_IS_BIENDIAN\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    return !virtio_is_big_endian(vdev);\n\n#else\n\n    return virtio_is_big_endian(vdev);\n\n#endif\n\n#else\n\n    return false;\n\n#endif\n\n}\n","idx":68,"target":0}
{"code":"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n","idx":70,"target":0}
{"code":"static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwl.base = base;\n\n    omap_pwl_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,\n\n                    omap_pwl_writefn, s);\n\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n}\n","idx":73,"target":0}
{"code":"static void virt_acpi_build_update(void *build_opaque)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    \/* No state to update or already patched? Nothing to do. *\/\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = true;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    acpi_ram_update(build_state->table_mr, tables.table_data);\n\n    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n\n    acpi_ram_update(build_state->linker_mr, tables.linker);\n\n\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n","idx":74,"target":0}
{"code":"static void uart_rx_reset(UartState *s)\n\n{\n\n    s->rx_wpos = 0;\n\n    s->rx_count = 0;\n\n    qemu_chr_accept_input(s->chr);\n\n\n\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n\n}\n","idx":76,"target":0}
{"code":"static int rndis_set_response(USBNetState *s,\n\n                rndis_set_msg_type *buf, unsigned int length)\n\n{\n\n    rndis_set_cmplt_type *resp =\n\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n\n    uint32_t bufoffs, buflen;\n\n    int ret;\n\n\n\n    if (!resp)\n\n        return USB_RET_STALL;\n\n\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n\n    if (bufoffs + buflen > length)\n\n        return USB_RET_STALL;\n\n\n\n    ret = ndis_set(s, le32_to_cpu(buf->OID),\n\n                    bufoffs + (uint8_t *) buf, buflen);\n\n    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);\n\n    resp->RequestID = buf->RequestID; \/* Still LE in msg buffer *\/\n\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n\n    if (ret < 0) {\n\n        \/* OID not supported *\/\n\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\n        return 0;\n\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\n\n    return 0;\n\n}\n","idx":77,"target":1}
{"code":"SwsContext *sws_alloc_context(void)\n\n{\n\n    SwsContext *c = av_mallocz(sizeof(SwsContext));\n\n\n\n    c->av_class = &sws_context_class;\n\n    av_opt_set_defaults(c);\n\n\n\n    return c;\n\n}\n","idx":78,"target":1}
{"code":"static i2c_interface *musicpal_audio_init(qemu_irq irq)\n\n{\n\n    AudioState *audio;\n\n    musicpal_audio_state *s;\n\n    i2c_interface *i2c;\n\n    int iomemtype;\n\n\n\n    audio = AUD_init();\n\n    if (!audio) {\n\n        AUD_log(audio_name, \"No audio state\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(musicpal_audio_state));\n\n    s->irq = irq;\n\n\n\n    i2c = qemu_mallocz(sizeof(i2c_interface));\n\n    i2c->bus = i2c_init_bus();\n\n    i2c->current_addr = -1;\n\n\n\n    s->wm = wm8750_init(i2c->bus, audio);\n\n    if (!s->wm)\n\n        return NULL;\n\n    i2c_set_slave_address(s->wm, MP_WM_ADDR);\n\n    wm8750_data_req_set(s->wm, audio_callback, s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, musicpal_audio_readfn,\n\n                       musicpal_audio_writefn, s);\n\n    cpu_register_physical_memory(MP_AUDIO_BASE, MP_AUDIO_SIZE, iomemtype);\n\n\n\n    qemu_register_reset(musicpal_audio_reset, s);\n\n\n\n    return i2c;\n\n}\n","idx":79,"target":1}
{"code":"void bdrv_error_action(BlockDriverState *bs, BlockErrorAction action,\n\n                       bool is_read, int error)\n\n{\n\n    assert(error >= 0);\n\n    bdrv_emit_qmp_error_event(bs, QEVENT_BLOCK_IO_ERROR, action, is_read);\n\n    if (action == BDRV_ACTION_STOP) {\n\n        vm_stop(RUN_STATE_IO_ERROR);\n\n        bdrv_iostatus_set_err(bs, error);\n\n    }\n\n}\n","idx":80,"target":1}
{"code":"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size,\n\n                     uint64_t max_mem)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    \/* allocate RAM *\/\n\n    if ((uint64_t)RAM_size > max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size \/ (1024 * 1024)),\n\n                (unsigned int)(max_mem \/ (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n","idx":81,"target":1}
{"code":"int xics_alloc_block(XICSState *icp, int src, int num, bool lsi, bool align)\n\n{\n\n    int i, first = -1;\n\n    ICSState *ics = &icp->ics[src];\n\n\n\n    assert(src == 0);\n\n    \/*\n\n     * MSIMesage::data is used for storing VIRQ so\n\n     * it has to be aligned to num to support multiple\n\n     * MSI vectors. MSI-X is not affected by this.\n\n     * The hint is used for the first IRQ, the rest should\n\n     * be allocated continuously.\n\n     *\/\n\n    if (align) {\n\n        assert((num == 1) || (num == 2) || (num == 4) ||\n\n               (num == 8) || (num == 16) || (num == 32));\n\n        first = ics_find_free_block(ics, num, num);\n\n    } else {\n\n        first = ics_find_free_block(ics, num, 1);\n\n    }\n\n\n\n    if (first >= 0) {\n\n        for (i = first; i < first + num; ++i) {\n\n            ics_set_irq_type(ics, i, lsi);\n\n        }\n\n    }\n\n    first += ics->offset;\n\n\n\n    trace_xics_alloc_block(src, first, num, lsi, align);\n\n\n\n    return first;\n\n}\n","idx":82,"target":1}
{"code":"static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    \/* No data transfer may already be in progress *\/\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE \/ 512)\n\n        n = SCSI_DMA_BUF_SIZE \/ 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n","idx":83,"target":1}
{"code":"void object_property_get_uint16List(Object *obj, const char *name,\n\n                                    uint16List **list, Error **errp)\n\n{\n\n    StringOutputVisitor *ov;\n\n    StringInputVisitor *iv;\n\n\n\n    ov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(ov),\n\n                        name, errp);\n\n    iv = string_input_visitor_new(string_output_get_string(ov));\n\n    visit_type_uint16List(string_input_get_visitor(iv),\n\n                          list, NULL, errp);\n\n    string_output_visitor_cleanup(ov);\n\n    string_input_visitor_cleanup(iv);\n\n}\n","idx":85,"target":1}
{"code":"static int raw_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int fd;\n\n    int64_t total_size = 0;\n\n\n\n    \/* Read out options *\/\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            total_size = options->value.n \/ 512;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\n              0644);\n\n    if (fd < 0)\n\n        return -EIO;\n\n    ftruncate(fd, total_size * 512);\n\n    close(fd);\n\n    return 0;\n\n}\n","idx":86,"target":1}
{"code":"static inline void RENAME(rgb24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n    int i;\n\n    assert(src1==src2);\n\n    for (i=0; i<width; i++) {\n\n        int r= src1[6*i + 0] + src1[6*i + 3];\n\n        int g= src1[6*i + 1] + src1[6*i + 4];\n\n        int b= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n    }\n\n}\n","idx":87,"target":1}
{"code":"static void tricore_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TriCoreCPU *cpu = TRICORE_CPU(obj);\n\n    CPUTriCoreState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        tricore_tcg_init();\n\n    }\n\n}\n","idx":88,"target":1}
{"code":"void ff_xvmc_init_block(MpegEncContext *s)\n\n{\n\n    struct xvmc_render_state *render = (struct xvmc_render_state*)s->current_picture.data[2];\n\n    assert(render);\n\n    if (!render || render->magic != AV_XVMC_RENDER_MAGIC) {\n\n        assert(0);\n\n        return; \/\/ make sure that this is a render packet\n\n    }\n\n    s->block = (DCTELEM *)(render->data_blocks + render->next_free_data_block_num * 64);\n\n}\n","idx":90,"target":1}
{"code":"void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n","idx":91,"target":1}
{"code":"static int write_trailer(AVFormatContext *s)\n\n{\n\n    WVMuxContext *wc = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    ff_ape_write(s);\n\n\n\n    if (pb->seekable) {\n\n        avio_seek(pb, 12, SEEK_SET);\n\n        avio_wl32(pb, wc->duration);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":96,"target":0}
{"code":"void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    \/* virtio-1 compliant devices cannot change the alignment *\/\n\n    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    \/* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     *\/\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n","idx":97,"target":0}
{"code":"int qcrypto_init(Error **errp)\n\n{\n\n    int ret;\n\n    ret = gnutls_global_init();\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Unable to initialize GNUTLS library: %s\",\n\n                   gnutls_strerror(ret));\n\n        return -1;\n\n    }\n\n#ifdef DEBUG_GNUTLS\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(qcrypto_gnutls_log);\n\n#endif\n\n\n\n#ifdef CONFIG_GNUTLS_GCRYPT\n\n    if (!gcry_check_version(GCRYPT_VERSION)) {\n\n        error_setg(errp, \"Unable to initialize gcrypt\");\n\n        return -1;\n\n    }\n\n#ifdef QCRYPTO_INIT_GCRYPT_THREADS\n\n    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);\n\n#endif \/* QCRYPTO_INIT_GCRYPT_THREADS *\/\n\n    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n\n#endif\n\n\n\n    return 0;\n\n}\n","idx":99,"target":0}
{"code":"static void read_vec_element_i32(DisasContext *s, TCGv_i32 tcg_dest, int srcidx,\n\n                                 int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_8|MO_SIGN:\n\n        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16|MO_SIGN:\n\n        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n    case MO_32|MO_SIGN:\n\n        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n","idx":100,"target":0}
{"code":"static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,\n\n                            hwaddr desc_pa, int i)\n\n{\n\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),\n\n                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n\n    virtio_tswap64s(vdev, &desc->addr);\n\n    virtio_tswap32s(vdev, &desc->len);\n\n    virtio_tswap16s(vdev, &desc->flags);\n\n    virtio_tswap16s(vdev, &desc->next);\n\n}\n","idx":101,"target":0}
{"code":"static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,\n\n                                                   int64_t offset)\n\n{\n\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    extent_begin_offset =\n\n        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;\n\n    extent_relative_offset = offset - extent_begin_offset;\n\n    offset_in_cluster = extent_relative_offset % cluster_size;\n\n\n\n    return offset_in_cluster;\n\n}\n","idx":103,"target":0}
{"code":"static unsigned int dec_move_pr(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"move $p%u, $r%u\\n\", dc->op1, dc->op2));\n\n\tcris_cc_mask(dc, 0);\n\n\n\n\tif (dc->op2 == PR_CCS)\n\n\t\tcris_evaluate_flags(dc);\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_gen_mov_TN_preg(t0, dc->op2);\n\n\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t cpu_R[dc->op1], cpu_R[dc->op1], t0, preg_sizes[dc->op2]);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n","idx":104,"target":0}
{"code":"static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = virtio_balloon_init_pci;\n\n    k->exit = virtio_balloon_exit_pci;\n\n    k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;\n\n    k->device_id = PCI_DEVICE_ID_VIRTIO_BALLOON;\n\n    k->revision = VIRTIO_PCI_ABI_VERSION;\n\n    k->class_id = PCI_CLASS_MEMORY_RAM;\n\n    dc->alias = \"virtio-balloon\";\n\n    dc->reset = virtio_pci_reset;\n\n    dc->props = virtio_balloon_properties;\n\n}\n","idx":105,"target":0}
{"code":"static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    bool start = req->cmd.buf[4] & 1;\n\n    bool loej = req->cmd.buf[4] & 2; \/* load on start, eject on !start *\/\n\n\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n\n        if (!start && !s->tray_open && s->tray_locked) {\n\n            scsi_check_condition(r,\n\n                                 bdrv_is_inserted(s->qdev.conf.bs)\n\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n\n            return -1;\n\n        }\n\n\n\n        if (s->tray_open != !start) {\n\n            bdrv_eject(s->qdev.conf.bs, !start);\n\n            s->tray_open = !start;\n\n        }\n\n    }\n\n    return 0;\n\n}\n","idx":110,"target":0}
{"code":"static void ecc_mem_writew(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    printf(\"ECC: Unsupported write 0x\" TARGET_FMT_plx \" %04x\\n\",\n\n           addr, val & 0xffff);\n\n}\n","idx":111,"target":0}
{"code":"static void qemu_chr_parse_stdio(QemuOpts *opts, ChardevBackend *backend,\n\n                                 Error **errp)\n\n{\n\n    ChardevStdio *stdio;\n\n\n\n    stdio = backend->u.stdio = g_new0(ChardevStdio, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevStdio_base(stdio));\n\n    stdio->has_signal = true;\n\n    stdio->signal = qemu_opt_get_bool(opts, \"signal\", true);\n\n}\n","idx":113,"target":0}
{"code":"void OPPROTO op_movl_npc_T0(void)\n\n{\n\n    env->npc = T0;\n\n}\n","idx":116,"target":0}
{"code":"int ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec)\n\n{\n\n    _Bool exp = 0;\n\n    if (codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || !codec->init)\n\n        return 0;\n\n\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n\n\n    if (atomic_fetch_add(&entangled_thread_counter, 1)) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Insufficient thread locking. At least %d threads are \"\n\n               \"calling avcodec_open2() at the same time right now.\\n\",\n\n               atomic_load(&entangled_thread_counter));\n\n        if (!lockmgr_cb)\n\n            av_log(log_ctx, AV_LOG_ERROR, \"No lock manager is set, please see av_lockmgr_register()\\n\");\n\n        atomic_store(&ff_avcodec_locked, 1);\n\n        ff_unlock_avcodec(codec);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_assert0(atomic_compare_exchange_strong(&ff_avcodec_locked, &exp, 1));\n\n    return 0;\n\n}\n","idx":118,"target":0}
{"code":"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n","idx":121,"target":1}
{"code":"static void put_swf_matrix(ByteIOContext *pb,\n\n                           int a, int b, int c, int d, int tx, int ty)\n\n{\n\n    PutBitContext p;\n\n    uint8_t buf[256];\n\n\n\n    init_put_bits(&p, buf, sizeof(buf));\n\n    \n\n    put_bits(&p, 1, 1); \/* a, d present *\/\n\n    put_bits(&p, 5, 20); \/* nb bits *\/\n\n    put_bits(&p, 20, a);\n\n    put_bits(&p, 20, d);\n\n    \n\n    put_bits(&p, 1, 1); \/* b, c present *\/\n\n    put_bits(&p, 5, 20); \/* nb bits *\/\n\n    put_bits(&p, 20, c);\n\n    put_bits(&p, 20, b);\n\n\n\n    put_bits(&p, 5, 20); \/* nb bits *\/\n\n    put_bits(&p, 20, tx);\n\n    put_bits(&p, 20, ty);\n\n\n\n    flush_put_bits(&p);\n\n    put_buffer(pb, buf, pbBufPtr(&p) - p.buf);\n\n}\n","idx":124,"target":1}
{"code":"static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)\n\n{\n\n    switch (tag) {\n\n    case 0x1901:\n\n        mxf->packages_count = get_be32(pb);\n\n        if (mxf->packages_count >= UINT_MAX \/ sizeof(UID))\n\n            return -1;\n\n        mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));\n\n        if (!mxf->packages_refs)\n\n            return -1;\n\n        url_fskip(pb, 4); \/* useless size of objects, always 16 according to specs *\/\n\n        get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));\n\n        break;\n\n    }\n\n    return 0;\n\n}\n","idx":125,"target":1}
{"code":"int ff_nvdec_start_frame(AVCodecContext *avctx, AVFrame *frame)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n    FrameDecodeData *fdd = (FrameDecodeData*)frame->private_ref->data;\n\n    NVDECFrame *cf = NULL;\n\n    int ret;\n\n\n\n    ctx->bitstream_len = 0;\n\n    ctx->nb_slices     = 0;\n\n\n\n    if (fdd->hwaccel_priv)\n\n        return 0;\n\n\n\n    cf = av_mallocz(sizeof(*cf));\n\n    if (!cf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    cf->decoder_ref = av_buffer_ref(ctx->decoder_ref);\n\n    if (!cf->decoder_ref)\n\n        goto fail;\n\n\n\n    cf->idx_ref = av_buffer_pool_get(ctx->decoder_pool);\n\n    if (!cf->idx_ref) {\n\n        av_log(avctx, AV_LOG_ERROR, \"No decoder surfaces left\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    cf->idx = *(unsigned int*)cf->idx_ref->data;\n\n\n\n    fdd->hwaccel_priv      = cf;\n\n    fdd->hwaccel_priv_free = nvdec_fdd_priv_free;\n\n    fdd->post_process      = nvdec_retrieve_data;\n\n\n\n    return 0;\n\nfail:\n\n    nvdec_fdd_priv_free(cf);\n\n    return ret;\n\n\n\n}\n","idx":126,"target":0}
{"code":"int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n\n{\n\n    void **ptrptr = ptr;\n\n    void *ret;\n\n    if (size <= 0 || nmemb >= INT_MAX \/ size)\n\n        return AVERROR(ENOMEM);\n\n    if (nmemb <= 0) {\n\n        av_freep(ptr);\n\n        return 0;\n\n    }\n\n    ret = av_realloc(*ptrptr, nmemb * size);\n\n    if (!ret) {\n\n        av_freep(ptr);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    *ptrptr = ret;\n\n    return 0;\n\n}\n","idx":127,"target":0}
{"code":"static void device_finalize(Object *obj)\n\n{\n\n    NamedGPIOList *ngl, *next;\n\n\n\n    DeviceState *dev = DEVICE(obj);\n\n    qemu_opts_del(dev->opts);\n\n\n\n    QLIST_FOREACH_SAFE(ngl, &dev->gpios, node, next) {\n\n        QLIST_REMOVE(ngl, node);\n\n        qemu_free_irqs(ngl->in, ngl->num_in);\n\n        g_free(ngl->name);\n\n        g_free(ngl);\n\n        \/* ngl->out irqs are owned by the other end and should not be freed\n\n         * here\n\n         *\/\n\n    }\n\n}\n","idx":131,"target":1}
{"code":"static void i440fx_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = i440fx_initfn;\n\n    k->config_write = i440fx_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82441;\n\n    k->revision = 0x02;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"Host bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_i440fx;\n\n}\n","idx":133,"target":1}
{"code":"target_ulong helper_udiv(target_ulong a, target_ulong b)\n\n{\n\n    uint64_t x0;\n\n    uint32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 \/ x1;\n\n    if (x0 > 0xffffffff) {\n\n        env->cc_src2 = 1;\n\n        return 0xffffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n","idx":135,"target":1}
{"code":"void ff_put_h264_qpel16_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_16w_msa(src - 2,\n\n                            src - (stride * 2) +\n\n                            sizeof(uint8_t), stride, dst, stride, 16);\n\n}\n","idx":137,"target":0}
{"code":"static int xan_huffman_decode(unsigned char *dest, const unsigned char *src,\n\n    int dest_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    init_get_bits(&gb, ptr, 0); \/\/ FIXME: no src size available\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest + 1 > dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":139,"target":1}
{"code":"static int kvm_log_stop(CPUPhysMemoryClient *client,\n\n                        target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n    return kvm_dirty_pages_log_change(phys_addr, size, false);\n\n}\n","idx":140,"target":1}
{"code":"void MPV_common_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n\n\n    if (s->motion_val)\n\n        free(s->motion_val);\n\n    if (s->h263_pred) {\n\n        free(s->dc_val[0]);\n\n        free(s->ac_val[0]);\n\n        free(s->coded_block);\n\n        free(s->mbintra_table);\n\n    }\n\n    if (s->mbskip_table)\n\n        free(s->mbskip_table);\n\n    for(i=0;i<3;i++) {\n\n        free(s->last_picture_base[i]);\n\n        free(s->next_picture_base[i]);\n\n        if (s->has_b_frames)\n\n            free(s->aux_picture_base[i]);\n\n    }\n\n    s->context_initialized = 0;\n\n}\n","idx":141,"target":1}
{"code":"struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n\n    return NULL;\n\n}","idx":143,"target":1}
{"code":"static inline int usb_bt_fifo_dequeue(struct usb_hci_in_fifo_s *fifo,\n\n                USBPacket *p)\n\n{\n\n    int len;\n\n\n\n    if (likely(!fifo->len))\n\n        return USB_RET_STALL;\n\n\n\n    len = MIN(p->len, fifo->fifo[fifo->start].len);\n\n    memcpy(p->data, fifo->fifo[fifo->start].data, len);\n\n    if (len == p->len) {\n\n        fifo->fifo[fifo->start].len -= len;\n\n        fifo->fifo[fifo->start].data += len;\n\n    } else {\n\n        fifo->start ++;\n\n        fifo->start &= CFIFO_LEN_MASK;\n\n        fifo->len --;\n\n    }\n\n\n\n    fifo->dstart += len;\n\n    fifo->dlen -= len;\n\n    if (fifo->dstart >= fifo->dsize) {\n\n        fifo->dstart = 0;\n\n        fifo->dsize = DFIFO_LEN_MASK + 1;\n\n    }\n\n\n\n    return len;\n\n}\n","idx":144,"target":1}
{"code":"static uint32_t m5206_mbar_readb(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    if (m5206_mbar_width[offset >> 2] > 1) {\n\n        uint16_t val;\n\n        val = m5206_mbar_readw(opaque, offset & ~1);\n\n        if ((offset & 1) == 0) {\n\n            val >>= 8;\n\n        }\n\n        return val & 0xff;\n\n    }\n\n    return m5206_mbar_read(s, offset, 1);\n\n}\n","idx":148,"target":1}
{"code":"static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= 0;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb=\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n","idx":153,"target":1}
{"code":"static void cg3_initfn(Object *obj)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    CG3State *s = CG3(obj);\n\n\n\n    memory_region_init_ram(&s->rom, NULL, \"cg3.prom\", FCODE_MAX_ROM_SIZE,\n\n                           &error_abort);\n\n    memory_region_set_readonly(&s->rom, true);\n\n    sysbus_init_mmio(sbd, &s->rom);\n\n\n\n    memory_region_init_io(&s->reg, NULL, &cg3_reg_ops, s, \"cg3.reg\",\n\n                          CG3_REG_SIZE);\n\n    sysbus_init_mmio(sbd, &s->reg);\n\n}\n","idx":154,"target":1}
{"code":"static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    fprintf(stderr, \"EHCI doesn't handle 16-bit writes to MMIO\\n\");\n\n    exit(1);\n\n}\n","idx":155,"target":1}
{"code":"static void parse_context_init(SchroParseUnitContext *parse_ctx,\n\n                               const uint8_t *buf, int buf_size)\n\n{\n\n    parse_ctx->buf           = buf;\n\n    parse_ctx->buf_size      = buf_size;\n\n}\n","idx":157,"target":1}
{"code":"static void wm8750_audio_out_cb(void *opaque, int free_b)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n    wm8750_out_flush(s);\n\n\n\n    s->req_out = free_b;\n\n    s->data_req(s->opaque, free_b >> 2, s->req_in >> 2);\n\n}\n","idx":160,"target":1}
{"code":"static void xendev_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->props = xendev_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n\n\n\n\n\n}","idx":161,"target":1}
{"code":"static uint64_t qdev_get_prop_mask64(Property *prop)\n\n{\n\n    assert(prop->info == &qdev_prop_bit);\n\n    return 0x1 << prop->bitnr;\n\n}\n","idx":162,"target":1}
{"code":"static void unix_process_msgfd(CharDriverState *chr, struct msghdr *msg)\n{\n    TCPCharDriver *s = chr->opaque;\n    struct cmsghdr *cmsg;\n    for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\n        int fd;\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n            cmsg->cmsg_level != SOL_SOCKET ||\n            cmsg->cmsg_type != SCM_RIGHTS)\n            continue;\n        fd = *((int *)CMSG_DATA(cmsg));\n        if (fd < 0)\n            continue;\n#ifndef MSG_CMSG_CLOEXEC\n        qemu_set_cloexec(fd);\n#endif\n        if (s->msgfd != -1)\n            close(s->msgfd);\n        s->msgfd = fd;\n    }\n}","idx":163,"target":1}
{"code":"void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 \/ x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();","idx":164,"target":1}
{"code":"void ga_channel_free(GAChannel *c)\n\n{\n\n    if (c->method == GA_CHANNEL_UNIX_LISTEN\n\n        && c->listen_channel) {\n\n        ga_channel_listen_close(c);\n\n    }\n\n    if (c->client_channel) {\n\n        ga_channel_client_close(c);\n\n    }\n\n    g_free(c);\n\n}\n","idx":165,"target":0}
{"code":"ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,\n\n                                   MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    ram_addr_t addr;\n\n    Error *local_err = NULL;\n\n\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    addr = ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return -1;\n\n    }\n\n    return addr;\n\n}\n","idx":167,"target":0}
{"code":"void kvm_s390_io_interrupt(S390CPU *cpu, uint16_t subchannel_id,\n\n                           uint16_t subchannel_nr, uint32_t io_int_parm,\n\n                           uint32_t io_int_word)\n\n{\n\n    uint32_t type;\n\n\n\n    if (io_int_word & IO_INT_WORD_AI) {\n\n        type = KVM_S390_INT_IO(1, 0, 0, 0);\n\n    } else {\n\n        type = ((subchannel_id & 0xff00) << 24) |\n\n            ((subchannel_id & 0x00060) << 22) | (subchannel_nr << 16);\n\n    }\n\n    kvm_s390_interrupt_internal(cpu, type,\n\n                                ((uint32_t)subchannel_id << 16) | subchannel_nr,\n\n                                ((uint64_t)io_int_parm << 32) | io_int_word, 1);\n\n}\n","idx":168,"target":0}
{"code":"static void elcr_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    s->elcr = val & s->elcr_mask;\n\n}\n","idx":169,"target":0}
{"code":"void nonono(const char* file, int line, const char* msg) {\n\n    fprintf(stderr, \"Nonono! %s:%d %s\\n\", file, line, msg);\n\n    exit(-5);\n\n}\n","idx":170,"target":0}
{"code":"static void spitz_i2c_setup(PXA2xxState *cpu)\n\n{\n\n    \/* Attach the CPU on one end of our I2C bus.  *\/\n\n    i2c_bus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);\n\n\n\n#ifdef HAS_AUDIO\n\n    DeviceState *wm;\n\n\n\n    \/* Attach a WM8750 to the bus *\/\n\n    wm = i2c_create_slave(bus, \"wm8750\", 0);\n\n\n\n    spitz_wm8750_addr(wm, 0, 0);\n\n    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_WM,\n\n                    qemu_allocate_irqs(spitz_wm8750_addr, wm, 1)[0]);\n\n    \/* .. and to the sound interface.  *\/\n\n    cpu->i2s->opaque = wm;\n\n    cpu->i2s->codec_out = wm8750_dac_dat;\n\n    cpu->i2s->codec_in = wm8750_adc_dat;\n\n    wm8750_data_req_set(wm, cpu->i2s->data_req, cpu->i2s);\n\n#endif\n\n}\n","idx":171,"target":0}
{"code":"void restore_boot_order(void *opaque)\n\n{\n\n    char *normal_boot_order = opaque;\n\n    static int first = 1;\n\n\n\n    \/* Restore boot order and remove ourselves after the first boot *\/\n\n    if (first) {\n\n        first = 0;\n\n        return;\n\n    }\n\n\n\n    qemu_boot_set(normal_boot_order);\n\n\n\n    qemu_unregister_reset(restore_boot_order, normal_boot_order);\n\n    g_free(normal_boot_order);\n\n}\n","idx":173,"target":0}
{"code":"void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n","idx":176,"target":0}
{"code":"void block_job_pause(BlockJob *job)\n\n{\n\n    job->paused = true;\n\n}\n","idx":177,"target":0}
{"code":"int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n","idx":178,"target":0}
{"code":"static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n","idx":179,"target":0}
{"code":"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf, int bytes)\n\n{\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {\n\n        .iov_base   = (void *) buf,\n\n        .iov_len    = bytes,\n\n    };\n\n\n\n    if (bytes < 0) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n    return bdrv_pwritev(bs, offset, &qiov);\n\n}\n","idx":181,"target":0}
{"code":"static int ppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    \/* TCG doesn't (yet) emulate some groups of instructions that\n\n     * are implemented on some otherwise supported CPUs (e.g. VSX\n\n     * and decimal floating point instructions on POWER7).  We\n\n     * remove unsupported instruction groups from the cpu state's\n\n     * instruction masks and hope the guest can cope.  For at\n\n     * least the pseries machine, the unavailability of these\n\n     * instructions can be advertised to the guest via the device\n\n     * tree. *\/\n\n    if ((env->insns_flags & ~PPC_TCG_INSNS)\n\n        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {\n\n        fprintf(stderr, \"Warning: Disabling some instructions which are not \"\n\n                \"emulated by TCG (0x%\" PRIx64 \", 0x%\" PRIx64 \")\\n\",\n\n                env->insns_flags & ~PPC_TCG_INSNS,\n\n                env->insns_flags2 & ~PPC_TCG_INSNS2);\n\n    }\n\n    env->insns_flags &= PPC_TCG_INSNS;\n\n    env->insns_flags2 &= PPC_TCG_INSNS2;\n\n    return 0;\n\n}\n","idx":182,"target":0}
{"code":"static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        output[1][i] -= output[3][i];\n\n        output[2][i] += output[3][i];\n\n    }\n\n    memset(output[3], 0, sizeof(output[3]));\n\n}\n","idx":183,"target":0}
{"code":"static void libopus_write_header(AVCodecContext *avctx, int stream_count,\n\n                                 int coupled_stream_count,\n\n                                 const uint8_t *channel_mapping)\n\n{\n\n    uint8_t *p   = avctx->extradata;\n\n    int channels = avctx->channels;\n\n\n\n    bytestream_put_buffer(&p, \"OpusHead\", 8);\n\n    bytestream_put_byte(&p, 1); \/* Version *\/\n\n    bytestream_put_byte(&p, channels);\n\n    bytestream_put_le16(&p, avctx->delay); \/* Lookahead samples at 48kHz *\/\n\n    bytestream_put_le32(&p, avctx->sample_rate); \/* Original sample rate *\/\n\n    bytestream_put_le16(&p, 0); \/* Gain of 0dB is recommended. *\/\n\n\n\n    \/* Channel mapping *\/\n\n    if (channels > 2) {\n\n        bytestream_put_byte(&p, channels <= 8 ? 1 : 255);\n\n        bytestream_put_byte(&p, stream_count);\n\n        bytestream_put_byte(&p, coupled_stream_count);\n\n        bytestream_put_buffer(&p, channel_mapping, channels);\n\n    } else {\n\n        bytestream_put_byte(&p, 0);\n\n    }\n\n}\n","idx":189,"target":0}
{"code":"void tlb_fill(CPUState *env1, target_ulong addr, int is_write, int mmu_idx,\n\n              void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    CPUState *saved_env;\n\n    unsigned long pc;\n\n    int ret;\n\n\n\n    saved_env = env;\n\n\n    ret = cpu_arm_handle_mmu_fault(env, addr, is_write, mmu_idx);\n\n    if (unlikely(ret)) {\n\n        if (retaddr) {\n\n            \/* now we have a real cpu fault *\/\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                \/* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault *\/\n\n                cpu_restore_state(tb, env, pc);\n\n            }\n\n        }\n\n        raise_exception(env->exception_index);\n\n    }\n\n    env = saved_env;\n\n}","idx":193,"target":1}
{"code":"int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)\n\n{\n\n    BufferSinkContext *s    = ctx->priv;\n\n    AVFilterLink      *link = ctx->inputs[0];\n\n    int ret;\n\n\n\n    if ((ret = ff_request_frame(link)) < 0)\n\n        return ret;\n\n\n\n    if (!s->cur_frame)\n\n        return AVERROR(EINVAL);\n\n\n\n    av_frame_move_ref(frame, s->cur_frame);\n\n    av_frame_free(&s->cur_frame);\n\n\n\n    return 0;\n\n}\n","idx":197,"target":1}
{"code":"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    sPAPRTCE *tcep;\n\n\n\n    if (ioba >= tcet->window_size) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-boards IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcep = tcet->table + (ioba >> SPAPR_TCE_PAGE_SHIFT);\n\n    tcep->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n","idx":199,"target":1}
{"code":"static void gen_lq(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    int ra, rd;\n\n    TCGv EA;\n\n\n\n    \/* Restore CPU state *\/\n\n    if (unlikely(ctx->mem_idx == 0)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    ra = rA(ctx->opcode);\n\n    rd = rD(ctx->opcode);\n\n    if (unlikely((rd & 1) || rd == ra)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        return;\n\n    }\n\n    if (unlikely(ctx->le_mode)) {\n\n        \/* Little-endian mode is not handled *\/\n\n        gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    EA = tcg_temp_new();\n\n    gen_addr_imm_index(ctx, EA, 0x0F);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd], EA);\n\n    gen_addr_add(ctx, EA, EA, 8);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd+1], EA);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n","idx":201,"target":1}
{"code":"static void pcie_cap_slot_hotplug_common(PCIDevice *hotplug_dev,\n\n                                         DeviceState *dev,\n\n                                         uint8_t **exp_cap, Error **errp)\n\n{\n\n    *exp_cap = hotplug_dev->config + hotplug_dev->exp.exp_cap;\n\n    uint16_t sltsta = pci_get_word(*exp_cap + PCI_EXP_SLTSTA);\n\n\n\n    PCIE_DEV_PRINTF(PCI_DEVICE(dev), \"hotplug state: 0x%x\\n\", sltsta);\n\n    if (sltsta & PCI_EXP_SLTSTA_EIS) {\n\n        \/* the slot is electromechanically locked.\n\n         * This error is propagated up to qdev and then to HMP\/QMP.\n\n         *\/\n\n        error_setg_errno(errp, -EBUSY, \"slot is electromechanically locked\");\n\n    }\n\n}\n","idx":204,"target":1}
{"code":"void qmp_getfd(const char *fdname, Error **errp)\n\n{\n\n    mon_fd_t *monfd;\n\n    int fd;\n\n\n\n    fd = qemu_chr_fe_get_msgfd(cur_mon->chr);\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_FD_NOT_SUPPLIED);\n\n        return;\n\n    }\n\n\n\n    if (qemu_isdigit(fdname[0])) {\n\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n\n                  \"a name not starting with a digit\");\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        close(monfd->fd);\n\n        monfd->fd = fd;\n\n        return;\n\n    }\n\n\n\n    monfd = g_malloc0(sizeof(mon_fd_t));\n\n    monfd->name = g_strdup(fdname);\n\n    monfd->fd = fd;\n\n\n\n    QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);\n\n}","idx":205,"target":1}
{"code":"static void qmp_deserialize(void **native_out, void *datap,\n\n                            VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = datap;\n\n    QString *output_json = qobject_to_json(qmp_output_get_qobject(d->qov));\n\n    QObject *obj = qobject_from_json(qstring_get_str(output_json));\n\n\n\n    QDECREF(output_json);\n\n    d->qiv = qmp_input_visitor_new(obj);\n\n    qobject_decref(obj);\n\n    visit(qmp_input_get_visitor(d->qiv), native_out, errp);\n\n}\n","idx":206,"target":1}
{"code":"static bool coroutine_fn yield_and_check(BackupBlockJob *job)\n\n{\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    \/* we need to yield so that bdrv_drain_all() returns.\n\n     * (without, VM does not reboot)\n\n     *\/\n\n    if (job->common.speed) {\n\n        uint64_t delay_ns = ratelimit_calculate_delay(&job->limit,\n\n                                                      job->sectors_read);\n\n        job->sectors_read = 0;\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n    } else {\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, 0);\n\n    }\n\n\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n","idx":207,"target":1}
{"code":"int ffurl_read_complete(URLContext *h, unsigned char *buf, int size)\n\n{\n\n    if (h->flags & AVIO_FLAG_WRITE)\n\n        return AVERROR(EIO);\n\n    return retry_transfer_wrapper(h, buf, size, size, h->prot->url_read);\n\n}\n","idx":209,"target":1}
{"code":"void qemu_del_timer(QEMUTimer *ts)\n\n{\n\n}\n","idx":211,"target":0}
{"code":"static void restore_native_fp_frstor(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    fp->fpuc = env->fpuc;\n\n    fp->fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;\n\n    fptag = 0;\n\n    for (i=7; i>=0; i--) {\n\n\tfptag <<= 2;\n\n\tif (env->fptags[i]) {\n\n            fptag |= 3;\n\n        } else {\n\n            \/* the FPU automatically computes it *\/\n\n        }\n\n    }\n\n    fp->fptag = fptag;\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&fp->fpregs1[i * 10], &env->fpregs[j].d, 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    asm volatile (\"frstor %0\" : \"=m\" (*fp));\n\n}\n","idx":212,"target":0}
{"code":"static void cpu_exec_nocache(int max_cycles, TranslationBlock *orig_tb)\n\n{\n\n    unsigned long next_tb;\n\n    TranslationBlock *tb;\n\n\n\n    \/* Should never happen.\n\n       We only end up here when an existing TB is too long.  *\/\n\n    if (max_cycles > CF_COUNT_MASK)\n\n        max_cycles = CF_COUNT_MASK;\n\n\n\n    tb = tb_gen_code(env, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,\n\n                     max_cycles);\n\n    env->current_tb = tb;\n\n    \/* execute the generated code *\/\n\n    next_tb = tcg_qemu_tb_exec(tb->tc_ptr);\n\n    env->current_tb = NULL;\n\n\n\n    if ((next_tb & 3) == 2) {\n\n        \/* Restore PC.  This may happen if async event occurs before\n\n           the TB starts executing.  *\/\n\n        cpu_pc_from_tb(env, tb);\n\n    }\n\n    tb_phys_invalidate(tb, -1);\n\n    tb_free(tb);\n\n}\n","idx":213,"target":0}
{"code":"static char *regname(uint32_t addr)\n\n{\n\n    static char buf[16];\n\n    if (addr < PCI_IO_SIZE) {\n\n        const char *r = reg[addr \/ 4];\n\n        if (r != 0) {\n\n            sprintf(buf, \"%s+%u\", r, addr % 4);\n\n        } else {\n\n            sprintf(buf, \"0x%02x\", addr);\n\n        }\n\n    } else {\n\n        sprintf(buf, \"??? 0x%08x\", addr);\n\n    }\n\n    return buf;\n\n}\n","idx":214,"target":0}
{"code":"static inline void writer_print_rational(WriterContext *wctx,\n\n                                         const char *key, AVRational q, char sep)\n\n{\n\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n    av_bprintf(&buf, \"%d%c%d\", q.num, sep, q.den);\n\n    wctx->writer->print_string(wctx, key, buf.str);\n\n    wctx->nb_item++;\n\n}\n","idx":217,"target":0}
{"code":"START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n","idx":218,"target":0}
{"code":"int cpu_watchpoint_insert(CPUState *env, target_ulong addr, target_ulong len,\n\n                          int flags, CPUWatchpoint **watchpoint)\n\n{\n\n    target_ulong len_mask = ~(len - 1);\n\n    CPUWatchpoint *wp;\n\n\n\n    \/* sanity checks: allow power-of-2 lengths, deny unaligned watchpoints *\/\n\n    if ((len != 1 && len != 2 && len != 4 && len != 8) || (addr & ~len_mask)) {\n\n        fprintf(stderr, \"qemu: tried to set invalid watchpoint at \"\n\n                TARGET_FMT_lx \", len=\" TARGET_FMT_lu \"\\n\", addr, len);\n\n        return -EINVAL;\n\n    }\n\n    wp = qemu_malloc(sizeof(*wp));\n\n\n\n    wp->vaddr = addr;\n\n    wp->len_mask = len_mask;\n\n    wp->flags = flags;\n\n\n\n    \/* keep all GDB-injected watchpoints in front *\/\n\n    if (flags & BP_GDB)\n\n        TAILQ_INSERT_HEAD(&env->watchpoints, wp, entry);\n\n    else\n\n        TAILQ_INSERT_TAIL(&env->watchpoints, wp, entry);\n\n\n\n    tlb_flush_page(env, addr);\n\n\n\n    if (watchpoint)\n\n        *watchpoint = wp;\n\n    return 0;\n\n}\n","idx":219,"target":0}
{"code":"static off_t read_off(int fd, int64_t offset)\n\n{\n\n\tuint64_t buffer;\n\n\tif (pread(fd, &buffer, 8, offset) < 8)\n\n\t\treturn 0;\n\n\treturn be64_to_cpu(buffer);\n\n}\n","idx":220,"target":0}
{"code":"bool replay_next_event_is(int event)\n\n{\n\n    bool res = false;\n\n\n\n    \/* nothing to skip - not all instructions used *\/\n\n    if (replay_state.instructions_count != 0) {\n\n        assert(replay_data_kind == EVENT_INSTRUCTION);\n\n        return event == EVENT_INSTRUCTION;\n\n    }\n\n\n\n    while (true) {\n\n        if (event == replay_data_kind) {\n\n            res = true;\n\n        }\n\n        switch (replay_data_kind) {\n\n        case EVENT_SHUTDOWN:\n\n            replay_finish_event();\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        default:\n\n            \/* clock, time_t, checkpoint and other events *\/\n\n            return res;\n\n        }\n\n    }\n\n    return res;\n\n}\n","idx":223,"target":0}
{"code":"void kvm_init_irq_routing(KVMState *s)\n\n{\n\n    int gsi_count, i;\n\n\n\n    gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING);\n\n    if (gsi_count > 0) {\n\n        unsigned int gsi_bits, i;\n\n\n\n        \/* Round up so we can search ints using ffs *\/\n\n        gsi_bits = ALIGN(gsi_count, 32);\n\n        s->used_gsi_bitmap = g_malloc0(gsi_bits \/ 8);\n\n        s->gsi_count = gsi_count;\n\n\n\n        \/* Mark any over-allocated bits as already in use *\/\n\n        for (i = gsi_count; i < gsi_bits; i++) {\n\n            set_gsi(s, i);\n\n        }\n\n    }\n\n\n\n    s->irq_routes = g_malloc0(sizeof(*s->irq_routes));\n\n    s->nr_allocated_irq_routes = 0;\n\n\n\n    if (!s->direct_msi) {\n\n        for (i = 0; i < KVM_MSI_HASHTAB_SIZE; i++) {\n\n            QTAILQ_INIT(&s->msi_hashtab[i]);\n\n        }\n\n    }\n\n\n\n    kvm_arch_init_irq_routing(s);\n\n}\n","idx":224,"target":0}
{"code":"static uint16_t *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n\n{\n\n    PhysPageEntry *lp, *p;\n\n    int i, j;\n\n\n\n    lp = &phys_map;\n\n\n\n    \/* Level 1..N.  *\/\n\n    for (i = P_L2_LEVELS - 1; i >= 0; i--) {\n\n        if (lp->u.node == NULL) {\n\n            if (!alloc) {\n\n                return NULL;\n\n            }\n\n            lp->u.node = p = g_malloc0(sizeof(PhysPageEntry) * L2_SIZE);\n\n            if (i == 0) {\n\n                for (j = 0; j < L2_SIZE; j++) {\n\n                    p[j].u.leaf = phys_section_unassigned;\n\n                }\n\n            }\n\n        }\n\n        lp = &lp->u.node[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    return &lp->u.leaf;\n\n}\n","idx":225,"target":0}
{"code":"void qemu_cpu_kick(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n\n\n    qemu_cond_broadcast(env->halt_cond);\n\n    if (!env->thread_kicked) {\n\n        qemu_cpu_kick_thread(env);\n\n        env->thread_kicked = true;\n\n    }\n\n}\n","idx":226,"target":0}
{"code":"static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t\/* FRC *\/\n\n        return s->frc;\n\n    case 0x04:\t\/* VCR *\/\n\n        return s->vrc;\n\n    case 0x08:\t\/* GCR *\/\n\n        return s->gcr;\n\n    }\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n","idx":227,"target":0}
{"code":"static int local_create_mapped_attr_dir(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    char attr_dir[PATH_MAX];\n\n    char *tmp_path = g_strdup(path);\n\n\n\n    snprintf(attr_dir, PATH_MAX, \"%s\/%s\/%s\",\n\n             ctx->fs_root, dirname(tmp_path), VIRTFS_META_DIR);\n\n\n\n    err = mkdir(attr_dir, 0700);\n\n    if (err < 0 && errno == EEXIST) {\n\n        err = 0;\n\n    }\n\n    g_free(tmp_path);\n\n    return err;\n\n}\n","idx":230,"target":0}
{"code":"static inline void sync_jmpstate(DisasContext *dc)\n\n{\n\n    if (dc->jmp == JMP_DIRECT) {\n\n            dc->jmp = JMP_INDIRECT;\n\n            tcg_gen_movi_tl(env_btaken, 1);\n\n            tcg_gen_movi_tl(env_btarget, dc->jmp_pc);\n\n    }\n\n}\n","idx":231,"target":0}
{"code":"void register_device_unmigratable(DeviceState *dev, const char *idstr,\n\n                                                            void *opaque)\n\n{\n\n    SaveStateEntry *se;\n\n    char id[256] = \"\";\n\n\n\n    if (dev && dev->parent_bus && dev->parent_bus->info->get_dev_path) {\n\n        char *path = dev->parent_bus->info->get_dev_path(dev);\n\n        if (path) {\n\n            pstrcpy(id, sizeof(id), path);\n\n            pstrcat(id, sizeof(id), \"\/\");\n\n            g_free(path);\n\n        }\n\n    }\n\n    pstrcat(id, sizeof(id), idstr);\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) {\n\n            se->no_migrate = 1;\n\n        }\n\n    }\n\n}\n","idx":232,"target":0}
{"code":"int css_do_rsch(SubchDev *sch)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {\n\n        ret = -EINPROGRESS;\n\n        goto out;\n\n    }\n\n\n\n    if (((s->ctrl & SCSW_CTRL_MASK_FCTL) != SCSW_FCTL_START_FUNC) ||\n\n        (s->ctrl & SCSW_ACTL_RESUME_PEND) ||\n\n        (!(s->ctrl & SCSW_ACTL_SUSP))) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    \/* If monitoring is active, update counter. *\/\n\n    if (channel_subsys.chnmon_active) {\n\n        css_update_chnmon(sch);\n\n    }\n\n\n\n    s->ctrl |= SCSW_ACTL_RESUME_PEND;\n\n    do_subchannel_work(sch, NULL);\n\n    ret = 0;\n\n\n\nout:\n\n    return ret;\n\n}\n","idx":233,"target":0}
{"code":"uint32_t lduw_be_phys(target_phys_addr_t addr)\n\n{\n\n    return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN);\n\n}\n","idx":235,"target":0}
{"code":"xilinx_axidma_data_stream_push(StreamSlave *obj, unsigned char *buf, size_t len,\n\n                               uint32_t *app)\n\n{\n\n    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(obj);\n\n    struct Stream *s = &ds->dma->streams[1];\n\n    size_t ret;\n\n\n\n    if (!app) {\n\n        hw_error(\"No stream app data!\\n\");\n\n    }\n\n    ret = stream_process_s2mem(s, buf, len, app);\n\n    stream_update_irq(s);\n\n    return ret;\n\n}\n","idx":236,"target":0}
{"code":"void *av_realloc(void *ptr, unsigned int size)\n\n{\n\n#ifdef MEMALIGN_HACK\n\n    int diff;\n\n#endif\n\n\n\n    \/* let's disallow possible ambiguous cases *\/\n\n    if(size > INT_MAX)\n\n        return NULL;\n\n\n\n#ifdef MEMALIGN_HACK\n\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n\n    if(!ptr) return av_malloc(size);\n\n    diff= ((char*)ptr)[-1];\n\n    return realloc(ptr - diff, size + diff) + diff;\n\n#else\n\n    return realloc(ptr, size);\n\n#endif\n\n}\n","idx":237,"target":0}
{"code":"static int mmf_probe(AVProbeData *p)\n\n{\n\n    \/* check file header *\/\n\n    if (p->buf_size <= 32)\n\n        return 0;\n\n    if (p->buf[0] == 'M' && p->buf[1] == 'M' &&\n\n        p->buf[2] == 'M' && p->buf[3] == 'D' &&\n\n        p->buf[8] == 'C' && p->buf[9] == 'N' &&\n\n        p->buf[10] == 'T' && p->buf[11] == 'I')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n","idx":238,"target":0}
{"code":"static XICSState *try_create_xics(const char *type, int nr_servers,\n\n                                  int nr_irqs)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(NULL, type);\n\n    qdev_prop_set_uint32(dev, \"nr_servers\", nr_servers);\n\n    qdev_prop_set_uint32(dev, \"nr_irqs\", nr_irqs);\n\n    if (qdev_init(dev) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    return XICS_COMMON(dev);\n\n}\n","idx":239,"target":1}
{"code":"static VncServerInfo *vnc_server_info_get(VncDisplay *vd)\n\n{\n\n    VncServerInfo *info;\n\n    Error *err = NULL;\n\n\n\n    info = g_malloc(sizeof(*info));\n\n    vnc_init_basic_info_from_server_addr(vd->lsock,\n\n                                         qapi_VncServerInfo_base(info), &err);\n\n    info->has_auth = true;\n\n    info->auth = g_strdup(vnc_auth_name(vd));\n\n    if (err) {\n\n        qapi_free_VncServerInfo(info);\n\n        info = NULL;\n\n        error_free(err);\n\n    }\n\n    return info;\n\n}\n","idx":240,"target":1}
{"code":"static int vm_request_pending(void)\n\n{\n\n    return powerdown_requested ||\n\n           reset_requested ||\n\n           shutdown_requested ||\n\n           debug_requested ||\n\n           vmstop_requested;\n\n}\n","idx":241,"target":1}
{"code":"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)\/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);","idx":244,"target":1}
{"code":"static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n","idx":246,"target":1}
{"code":"static void ff_h264_idct_add16intra_mmx(uint8_t *dst, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){\n\n    int i;\n\n    for(i=0; i<16; i++){\n\n        if(nnzc[ scan8[i] ] || block[i*16])\n\n            ff_h264_idct_add_mmx(dst + block_offset[i], block + i*16, stride);\n\n    }\n\n}\n","idx":251,"target":0}
{"code":"static int find_stream_index(AVFormatContext *s)\n\n{\n\n    int i;\n\n    AVStream *st;\n\n\n\n    if (s->nb_streams <= 0)\n\n        return -1;\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n        if (st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n            return i;\n\n        }\n\n    }\n\n    return 0;\n\n}\n","idx":253,"target":0}
{"code":"static inline void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    \/* p0' *\/\n\n                pix[0]        = av_clip_uint8( q0 - delta );    \/* q0' *\/\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n","idx":254,"target":0}
{"code":"static void parse_type_bool(Visitor *v, const char *name, bool *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (siv->string) {\n\n        if (!strcasecmp(siv->string, \"on\") ||\n\n            !strcasecmp(siv->string, \"yes\") ||\n\n            !strcasecmp(siv->string, \"true\")) {\n\n            *obj = true;\n\n            return;\n\n        }\n\n        if (!strcasecmp(siv->string, \"off\") ||\n\n            !strcasecmp(siv->string, \"no\") ||\n\n            !strcasecmp(siv->string, \"false\")) {\n\n            *obj = false;\n\n            return;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"boolean\");\n\n}\n","idx":257,"target":1}
{"code":"static int adts_aac_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    int ret, fsize;\n\n\n\n    ret = av_get_packet(s->pb, pkt, ADTS_HEADER_SIZE);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (ret < ADTS_HEADER_SIZE) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if ((AV_RB16(pkt->data) >> 4) != 0xfff) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    fsize = (AV_RB32(pkt->data + 3) >> 13) & 0x1FFF;\n\n    if (fsize < ADTS_HEADER_SIZE) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return av_append_packet(s->pb, pkt, fsize - ADTS_HEADER_SIZE);\n\n}\n","idx":261,"target":1}
{"code":"static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}","idx":262,"target":1}
{"code":"static int bgr24ToYv12Wrapper(SwsContext *c, const uint8_t *src[],\n\n                              int srcStride[], int srcSliceY, int srcSliceH,\n\n                              uint8_t *dst[], int dstStride[])\n\n{\n\n    rgb24toyv12(\n\n        src[0],\n\n        dst[0] +  srcSliceY       * dstStride[0],\n\n        dst[1] + (srcSliceY >> 1) * dstStride[1],\n\n        dst[2] + (srcSliceY >> 1) * dstStride[2],\n\n        c->srcW, srcSliceH,\n\n        dstStride[0], dstStride[1], srcStride[0]);\n\n    if (dst[3])\n\n        fillPlane(dst[3], dstStride[3], c->srcW, srcSliceH, srcSliceY, 255);\n\n    return srcSliceH;\n\n}\n","idx":263,"target":1}
{"code":"void rgb15tobgr32(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tconst uint16_t *end;\n\n\tuint8_t *d = (uint8_t *)dst;\n\n\tconst uint16_t *s = (const uint16_t *)src;\n\n\tend = s + src_size\/2;\n\n\twhile(s < end)\n\n\t{\n\n\t\tregister uint16_t bgr;\n\n\t\tbgr = *s++;\n\n\t\t*d++ = (bgr&0x7C00)>>7;\n\n\t\t*d++ = (bgr&0x3E0)>>2;\n\n\t\t*d++ = (bgr&0x1F)<<3;\n\n\t\t*d++ = 0;\n\n\t}\n\n}\n","idx":264,"target":1}
{"code":"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    \/* read the palette *\/\n\n    n = length \/ 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     \/* crc *\/\n\n\n\n    return 0;\n\n}\n","idx":265,"target":1}
{"code":"static inline int coeff_unpack_golomb(GetBitContext *gb, int qfactor, int qoffset)\n\n{\n\n    int coeff = dirac_get_se_golomb(gb);\n\n    const int sign = FFSIGN(coeff);\n\n    if (coeff)\n\n        coeff = sign*((sign * coeff * qfactor + qoffset) >> 2);\n\n    return coeff;\n\n}\n","idx":267,"target":1}
{"code":"static void gen_rfe(DisasContext *s, TCGv_i32 pc, TCGv_i32 cpsr)\n\n{\n\n    gen_set_cpsr(cpsr, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(cpsr);\n\n    store_reg(s, 15, pc);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n","idx":270,"target":1}
{"code":"static void decode_ac_filter(WmallDecodeCtx *s)\n\n{\n\n    int i;\n\n    s->acfilter_order = get_bits(&s->gb, 4) + 1;\n\n    s->acfilter_scaling = get_bits(&s->gb, 4);\n\n\n\n    for(i = 0; i < s->acfilter_order; i++) {\n\n\ts->acfilter_coeffs[i] = get_bits(&s->gb, s->acfilter_scaling) + 1;\n\n    }\n\n}\n","idx":275,"target":1}
{"code":"QDict *qdict_get_qdict(const QDict *qdict, const char *key)\n\n{\n\n    return qobject_to_qdict(qdict_get_obj(qdict, key, QTYPE_QDICT));\n\n}\n","idx":279,"target":1}
{"code":"void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    \/* Discard written trace records *\/\n\n    trace_idx = 0;\n\n}\n","idx":280,"target":1}
{"code":"static int nut_write_trailer(AVFormatContext *s)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    AVIOContext *bc = s->pb, *dyn_bc;\n\n    int i, ret;\n\n\n\n    while (nut->header_count < 3)\n\n        write_headers(s, bc);\n\n\n\n    ret = avio_open_dyn_buf(&dyn_bc);\n\n    if (ret >= 0 && nut->sp_count) {\n\n        av_assert1(nut->write_index);\n\n        write_index(nut, dyn_bc);\n\n        put_packet(nut, bc, dyn_bc, 1, INDEX_STARTCODE);\n\n    }\n\n\n\n    ff_nut_free_sp(nut);\n\n    for (i=0; i<s->nb_streams; i++)\n\n        av_freep(&nut->stream[i].keyframe_pts);\n\n\n\n    av_freep(&nut->stream);\n\n    av_freep(&nut->chapter);\n\n    av_freep(&nut->time_base);\n\n\n\n    return 0;\n\n}\n","idx":282,"target":1}
{"code":"static uint32_t arm_ldl_ptw(CPUState *cs, hwaddr addr, bool is_secure,\n\n                            ARMMMUIdx mmu_idx, ARMMMUFaultInfo *fi)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    MemTxAttrs attrs = {};\n\n    AddressSpace *as;\n\n\n\n    attrs.secure = is_secure;\n\n    as = arm_addressspace(cs, attrs);\n\n    addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fi);\n\n    if (fi->s1ptw) {\n\n        return 0;\n\n    }\n\n    if (regime_translation_big_endian(env, mmu_idx)) {\n\n        return address_space_ldl_be(as, addr, attrs, NULL);\n\n    } else {\n\n        return address_space_ldl_le(as, addr, attrs, NULL);\n\n    }\n\n}\n","idx":283,"target":1}
{"code":"void aio_context_acquire(AioContext *ctx)\n\n{\n\n    qemu_rec_mutex_lock(&ctx->lock);\n\n}\n","idx":284,"target":0}
{"code":"static void qjson_finalizefn(Object *obj)\n\n{\n\n    QJSON *json = QJSON(obj);\n\n\n\n    qobject_decref(QOBJECT(json->str));\n\n}\n","idx":285,"target":0}
{"code":"static void visitor_output_setup(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    data->qov = qmp_output_visitor_new();\n\n    g_assert(data->qov != NULL);\n\n\n\n    data->ov = qmp_output_get_visitor(data->qov);\n\n    g_assert(data->ov != NULL);\n\n}\n","idx":287,"target":0}
{"code":"int event_notifier_get_fd(EventNotifier *e)\n\n{\n\n    return e->fd;\n\n}\n","idx":291,"target":0}
{"code":"static uint64_t sp804_read(void *opaque, target_phys_addr_t offset,\n\n                           unsigned size)\n\n{\n\n    sp804_state *s = (sp804_state *)opaque;\n\n\n\n    if (offset < 0x20) {\n\n        return arm_timer_read(s->timer[0], offset);\n\n    }\n\n    if (offset < 0x40) {\n\n        return arm_timer_read(s->timer[1], offset - 0x20);\n\n    }\n\n\n\n    \/* TimerPeriphID *\/\n\n    if (offset >= 0xfe0 && offset <= 0xffc) {\n\n        return sp804_ids[(offset - 0xfe0) >> 2];\n\n    }\n\n\n\n    switch (offset) {\n\n    \/* Integration Test control registers, which we won't support *\/\n\n    case 0xf00: \/* TimerITCR *\/\n\n    case 0xf04: \/* TimerITOP (strictly write only but..) *\/\n\n        return 0;\n\n    }\n\n\n\n    hw_error(\"%s: Bad offset %x\\n\", __func__, (int)offset);\n\n    return 0;\n\n}\n","idx":292,"target":0}
{"code":"opts_type_size(Visitor *v, const char *name, uint64_t *obj, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    const QemuOpt *opt;\n\n    int64_t val;\n\n\n\n    opt = lookup_scalar(ov, name, errp);\n\n    if (!opt) {\n\n        return;\n\n    }\n\n\n\n    val = qemu_strtosz(opt->str ? opt->str : \"\", NULL);\n\n    if (val < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, opt->name,\n\n                   \"a size value representible as a non-negative int64\");\n\n        return;\n\n    }\n\n\n\n    *obj = val;\n\n    processed(ov, name);\n\n}\n","idx":293,"target":0}
{"code":"static void handle_mousemotion(SDL_Event *ev)\n\n{\n\n    int max_x, max_y;\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n\n\n    if (qemu_input_is_absolute() || absolute_enabled) {\n\n        int scr_w, scr_h;\n\n        SDL_GetWindowSize(scon->real_window, &scr_w, &scr_h);\n\n        max_x = scr_w - 1;\n\n        max_y = scr_h - 1;\n\n        if (gui_grab && (ev->motion.x == 0 || ev->motion.y == 0 ||\n\n                         ev->motion.x == max_x || ev->motion.y == max_y)) {\n\n            sdl_grab_end(scon);\n\n        }\n\n        if (!gui_grab &&\n\n            (ev->motion.x > 0 && ev->motion.x < max_x &&\n\n             ev->motion.y > 0 && ev->motion.y < max_y)) {\n\n            sdl_grab_start(scon);\n\n        }\n\n    }\n\n    if (gui_grab || qemu_input_is_absolute() || absolute_enabled) {\n\n        sdl_send_mouse_event(scon, ev->motion.xrel, ev->motion.yrel,\n\n                             ev->motion.x, ev->motion.y, ev->motion.state);\n\n    }\n\n}\n","idx":294,"target":0}
{"code":"static void xen_platform_ioport_writeb(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIXenPlatformState *s = opaque;\n\n\n\n    addr &= 0xff;\n\n    val  &= 0xff;\n\n\n\n    switch (addr) {\n\n    case 0: \/* Platform flags *\/\n\n        platform_fixed_ioport_writeb(opaque, XEN_PLATFORM_IOPORT, val);\n\n        break;\n\n    case 8:\n\n        log_writeb(s, val);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n","idx":296,"target":0}
{"code":"static void timerlist_rearm(QEMUTimerList *timer_list)\n\n{\n\n    \/* Interrupt execution to force deadline recalculation.  *\/\n\n    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {\n\n        qemu_start_warp_timer();\n\n    }\n\n    timerlist_notify(timer_list);\n\n}\n","idx":298,"target":0}
{"code":"av_cold int ff_lpc_init(LPCContext *s, int blocksize, int max_order,\n\n                        enum FFLPCType lpc_type)\n\n{\n\n    s->blocksize = blocksize;\n\n    s->max_order = max_order;\n\n    s->lpc_type  = lpc_type;\n\n\n\n    if (lpc_type == FF_LPC_TYPE_LEVINSON) {\n\n        s->windowed_samples = av_mallocz((blocksize + max_order + 2) *\n\n                                         sizeof(*s->windowed_samples));\n\n        if (!s->windowed_samples)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        s->windowed_samples = NULL;\n\n    }\n\n\n\n    s->lpc_apply_welch_window = lpc_apply_welch_window_c;\n\n    s->lpc_compute_autocorr   = lpc_compute_autocorr_c;\n\n\n\n    if (HAVE_MMX)\n\n        ff_lpc_init_x86(s);\n\n\n\n    return 0;\n\n}\n","idx":303,"target":1}
{"code":"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n","idx":304,"target":1}
{"code":"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n","idx":305,"target":1}
{"code":"static void omap_tipb_bridge_write(void *opaque, target_phys_addr_t addr,\n\n                                   uint64_t value, unsigned size)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *) opaque;\n\n\n\n    if (size < 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t\/* TIPB_CNTL *\/\n\n        s->control = value & 0xffff;\n\n        break;\n\n\n\n    case 0x04:\t\/* TIPB_BUS_ALLOC *\/\n\n        s->alloc = value & 0x003f;\n\n        break;\n\n\n\n    case 0x08:\t\/* MPU_TIPB_CNTL *\/\n\n        s->buffer = value & 0x0003;\n\n        break;\n\n\n\n    case 0x0c:\t\/* ENHANCED_TIPB_CNTL *\/\n\n        s->width_intr = !(value & 2);\n\n        s->enh_control = value & 0x000f;\n\n        break;\n\n\n\n    case 0x10:\t\/* ADDRESS_DBG *\/\n\n    case 0x14:\t\/* DATA_DEBUG_LOW *\/\n\n    case 0x18:\t\/* DATA_DEBUG_HIGH *\/\n\n    case 0x1c:\t\/* DEBUG_CNTR_SIG *\/\n\n        OMAP_RO_REG(addr);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n","idx":308,"target":0}
{"code":"PCIDevice *pci_register_device(PCIBus *bus, const char *name,\n\n                               int instance_size, int devfn,\n\n                               PCIConfigReadFunc *config_read,\n\n                               PCIConfigWriteFunc *config_write)\n\n{\n\n    PCIDevice *pci_dev;\n\n\n\n    pci_dev = qemu_mallocz(instance_size);\n\n    pci_dev = do_pci_register_device(pci_dev, bus, name, devfn,\n\n                                     config_read, config_write);\n\n    return pci_dev;\n\n}\n","idx":309,"target":0}
{"code":"bool error_is_type(Error *err, const char *fmt)\n\n{\n\n    const char *error_class;\n\n    char *ptr;\n\n    char *end;\n\n\n\n    if (!err) {\n\n        return false;\n\n    }\n\n\n\n    ptr = strstr(fmt, \"'class': '\");\n\n    assert(ptr != NULL);\n\n    ptr += strlen(\"'class': '\");\n\n\n\n    end = strchr(ptr, '\\'');\n\n    assert(end != NULL);\n\n\n\n    error_class = error_get_field(err, \"class\");\n\n    if (strlen(error_class) != end - ptr) {\n\n        return false;\n\n    }\n\n\n\n    return strncmp(ptr, error_class, end - ptr) == 0;\n\n}\n","idx":311,"target":0}
{"code":"void bdrv_aio_cancel(BlockAIOCB *acb)\n\n{\n\n    qemu_aio_ref(acb);\n\n    bdrv_aio_cancel_async(acb);\n\n    while (acb->refcnt > 1) {\n\n        if (acb->aiocb_info->get_aio_context) {\n\n            aio_poll(acb->aiocb_info->get_aio_context(acb), true);\n\n        } else if (acb->bs) {\n\n            aio_poll(bdrv_get_aio_context(acb->bs), true);\n\n        } else {\n\n            abort();\n\n        }\n\n    }\n\n    qemu_aio_unref(acb);\n\n}\n","idx":313,"target":0}
{"code":"static void vnc_listen_read(void *opaque, bool websocket)\n\n{\n\n    VncDisplay *vs = opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int csock;\n\n\n\n    \/* Catch-up *\/\n\n    graphic_hw_update(vs->dcl.con);\n\n#ifdef CONFIG_VNC_WS\n\n    if (websocket) {\n\n        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);\n\n    } else\n\n#endif \/* CONFIG_VNC_WS *\/\n\n    {\n\n        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);\n\n    }\n\n\n\n    if (csock != -1) {\n\n        socket_set_nodelay(csock);\n\n        vnc_connect(vs, csock, false, websocket);\n\n    }\n\n}\n","idx":314,"target":0}
{"code":"static PhysPageDesc *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n\n{\n\n    void **lp, **p;\n\n\n\n    p = (void **)l1_phys_map;\n\n#if TARGET_PHYS_ADDR_SPACE_BITS > 32\n\n\n\n#if TARGET_PHYS_ADDR_SPACE_BITS > (32 + L1_BITS)\n\n#error unsupported TARGET_PHYS_ADDR_SPACE_BITS\n\n#endif\n\n    lp = p + ((index >> (L1_BITS + L2_BITS)) & (L1_SIZE - 1));\n\n    p = *lp;\n\n    if (!p) {\n\n        \/* allocate if not found *\/\n\n        if (!alloc)\n\n            return NULL;\n\n        p = qemu_vmalloc(sizeof(void *) * L1_SIZE);\n\n        memset(p, 0, sizeof(void *) * L1_SIZE);\n\n        *lp = p;\n\n    }\n\n#endif\n\n    lp = p + ((index >> L2_BITS) & (L1_SIZE - 1));\n\n    p = *lp;\n\n    if (!p) {\n\n        \/* allocate if not found *\/\n\n        if (!alloc)\n\n            return NULL;\n\n        p = qemu_vmalloc(sizeof(PhysPageDesc) * L2_SIZE);\n\n        memset(p, 0, sizeof(PhysPageDesc) * L2_SIZE);\n\n        *lp = p;\n\n    }\n\n    return ((PhysPageDesc *)p) + (index & (L2_SIZE - 1));\n\n}\n","idx":317,"target":0}
{"code":"static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->bdrv_cur)\n\n        return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0;\n\n    else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}\n","idx":319,"target":0}
{"code":"static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n","idx":321,"target":0}
{"code":"void s390_pci_sclp_configure(SCCB *sccb)\n\n{\n\n    PciCfgSccb *psccb = (PciCfgSccb *)sccb;\n\n    S390PCIBusDevice *pbdev = s390_pci_find_dev_by_fid(be32_to_cpu(psccb->aid));\n\n    uint16_t rc;\n\n\n\n    if (be16_to_cpu(sccb->h.length) < 16) {\n\n        rc = SCLP_RC_INSUFFICIENT_SCCB_LENGTH;\n\n        goto out;\n\n    }\n\n\n\n    if (pbdev) {\n\n        if (pbdev->configured) {\n\n            rc = SCLP_RC_NO_ACTION_REQUIRED;\n\n        } else {\n\n            pbdev->configured = true;\n\n            rc = SCLP_RC_NORMAL_COMPLETION;\n\n        }\n\n    } else {\n\n        DPRINTF(\"sclp config no dev found\\n\");\n\n        rc = SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED;\n\n    }\n\nout:\n\n    psccb->header.response_code = cpu_to_be16(rc);\n\n}\n","idx":322,"target":0}
{"code":"static BlockJob *find_block_job(const char *device)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs || !bs->job) {\n\n        return NULL;\n\n    }\n\n    return bs->job;\n\n}\n","idx":323,"target":0}
{"code":"static void usb_host_realize(USBDevice *udev, Error **errp)\n\n{\n\n    USBHostDevice *s = USB_HOST_DEVICE(udev);\n\n\n\n    if (s->match.vendor_id > 0xffff) {\n\n        error_setg(errp, \"vendorid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.product_id > 0xffff) {\n\n        error_setg(errp, \"productid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.addr > 127) {\n\n        error_setg(errp, \"hostaddr out of range\");\n\n        return;\n\n    }\n\n\n\n    loglevel = s->loglevel;\n\n    udev->flags |= (1 << USB_DEV_FLAG_IS_HOST);\n\n    udev->auto_attach = 0;\n\n    QTAILQ_INIT(&s->requests);\n\n    QTAILQ_INIT(&s->isorings);\n\n\n\n    s->exit.notify = usb_host_exit_notifier;\n\n    qemu_add_exit_notifier(&s->exit);\n\n\n\n    QTAILQ_INSERT_TAIL(&hostdevs, s, next);\n\n    usb_host_auto_check(NULL);\n\n}\n","idx":324,"target":0}
{"code":"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n","idx":325,"target":0}
{"code":"static void rtas_int_off(sPAPREnvironment *spapr, uint32_t token,\n\n                         uint32_t nargs, target_ulong args,\n\n                         uint32_t nret, target_ulong rets)\n\n{\n\n    struct ics_state *ics = spapr->icp->ics;\n\n    uint32_t nr;\n\n\n\n    if ((nargs != 1) || (nret != 1)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    nr = rtas_ld(args, 0);\n\n\n\n    if (!ics_valid_irq(ics, nr)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    ics_write_xive(ics, nr, ics->irqs[nr - ics->offset].server, 0xff,\n\n                   ics->irqs[nr - ics->offset].priority);\n\n\n\n    rtas_st(rets, 0, 0); \/* Success *\/\n\n}\n","idx":326,"target":0}
{"code":"static void filter_mb_mbaff_edgecv( H264Context *h, uint8_t *pix, int stride, int16_t bS[7], int bsi, int qp ) {\n\n    int index_a = qp + h->slice_alpha_c0_offset;\n\n    int alpha = alpha_table[index_a];\n\n    int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0*bsi]] + 1;\n\n        tc[1] = tc0_table[index_a][bS[1*bsi]] + 1;\n\n        tc[2] = tc0_table[index_a][bS[2*bsi]] + 1;\n\n        tc[3] = tc0_table[index_a][bS[3*bsi]] + 1;\n\n        h->h264dsp.h264_h_loop_filter_chroma_mbaff(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_mbaff_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n","idx":327,"target":0}
{"code":"static void qmp_serialize(void *native_in, void **datap,\n\n                          VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = g_malloc0(sizeof(*d));\n\n\n\n    d->qov = qmp_output_visitor_new(&d->obj);\n\n    visit(d->qov, &native_in, errp);\n\n    *datap = d;\n\n}\n","idx":329,"target":0}
{"code":"static void emulate_spapr_hypercall(PPCVirtualHypervisor *vhyp,\n                                    PowerPCCPU *cpu)\n{\n    CPUPPCState *env = &cpu->env;\n    if (msr_pr) {\n        hcall_dprintf(\"Hypercall made with MSR[PR]=1\\n\");\n        env->gpr[3] = H_PRIVILEGE;\n    } else {\n        env->gpr[3] = spapr_hypercall(cpu, env->gpr[3], &env->gpr[4]);\n    }\n}","idx":331,"target":1}
{"code":"static void ahci_pci_enable(AHCIQState *ahci)\n\n{\n\n    uint8_t reg;\n\n\n\n    start_ahci_device(ahci);\n\n\n\n    switch (ahci->fingerprint) {\n\n    case AHCI_INTEL_ICH9:\n\n        \/* ICH9 has a register at PCI 0x92 that\n\n         * acts as a master port enabler mask. *\/\n\n        reg = qpci_config_readb(ahci->dev, 0x92);\n\n        reg |= 0x3F;\n\n        qpci_config_writeb(ahci->dev, 0x92, reg);\n\n        \/* 0...0111111b -- bit significant, ports 0-5 enabled. *\/\n\n        ASSERT_BIT_SET(qpci_config_readb(ahci->dev, 0x92), 0x3F);\n\n        break;\n\n    }\n\n\n\n}\n","idx":336,"target":1}
{"code":"void OPPROTO op_udivx_T1_T0(void)\n\n{\n\n\n\n\n    T0 \/= T1;\n\n    FORCE_RET();\n","idx":340,"target":1}
{"code":"void address_space_init(AddressSpace *as, MemoryRegion *root)\n\n{\n\n    memory_region_transaction_begin();\n\n    as->root = root;\n\n    as->current_map = g_new(FlatView, 1);\n\n    flatview_init(as->current_map);\n\n\n\n    QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);\n\n    as->name = NULL;\n\n    memory_region_transaction_commit();\n\n    address_space_init_dispatch(as);\n\n}","idx":341,"target":1}
{"code":"static void generate_offset_lut(DiracGolombLUT *lut, int off)\n\n{\n\n    int idx;\n\n    for (idx = 0; idx < LUT_SIZE; idx++) {\n\n        DiracGolombLUT *l = &lut[idx];\n\n\n\n        INIT_RESIDUE(res);\n\n        SET_RESIDUE(res, idx, LUT_BITS);\n\n\n\n        l->preamble      = CONVERT_TO_RESIDUE(res >> (RSIZE_BITS - off), off);\n\n        l->preamble_bits = off;\n\n        l->sign = ((l->preamble >> (RSIZE_BITS - l->preamble_bits)) & 1) ? -1 : +1;\n\n\n\n        search_for_golomb(l, res << off, LUT_BITS - off);\n\n    }\n\n}\n","idx":342,"target":1}
{"code":"ebml_read_ascii (MatroskaDemuxContext *matroska,\n\n                 uint32_t             *id,\n\n                 char                **str)\n\n{\n\n    ByteIOContext *pb = matroska->ctx->pb;\n\n    int size, res;\n\n    uint64_t rlength;\n\n\n\n    if ((res = ebml_read_element_id(matroska, id, NULL)) < 0 ||\n\n        (res = ebml_read_element_length(matroska, &rlength)) < 0)\n\n        return res;\n\n    size = rlength;\n\n\n\n    \/* ebml strings are usually not 0-terminated, so we allocate one\n\n     * byte more, read the string and NULL-terminate it ourselves. *\/\n\n    if (size < 0 || !(*str = av_malloc(size + 1))) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR, \"Memory allocation failed\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    if (get_buffer(pb, (uint8_t *) *str, size) != size) {\n\n        offset_t pos = url_ftell(pb);\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"Read error at pos. %\"PRIu64\" (0x%\"PRIx64\")\\n\", pos, pos);\n\n\n        return AVERROR(EIO);\n\n    }\n\n    (*str)[size] = '\\0';\n\n\n\n    return 0;\n\n}","idx":343,"target":1}
{"code":"vmxnet3_pop_next_tx_descr(VMXNET3State *s,\n\n                          int qidx,\n\n                          struct Vmxnet3_TxDesc *txd,\n\n                          uint32_t *descr_idx)\n\n{\n\n    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {\n\n        \/* Only read after generation field verification *\/\n\n        smp_rmb();\n\n        \/* Re-read to be sure we got the latest version *\/\n\n        vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n        VMXNET3_RING_DUMP(VMW_RIPRN, \"TX\", qidx, ring);\n\n        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);\n\n        vmxnet3_inc_tx_consumption_counter(s, qidx);\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n","idx":345,"target":1}
{"code":"RGB_FUNCTIONS(rgba32)\n\n\n\n#undef RGB_IN\n\n#undef RGB_OUT\n\n#undef BPP\n\n\n\n\n\nstatic void rgb24_to_rgb565(AVPicture *dst, AVPicture *src,\n\n                            int width, int height)\n\n{\n\n    const unsigned char *p;\n\n    unsigned char *q;\n\n    int r, g, b, dst_wrap, src_wrap;\n\n    int x, y;\n\n\n\n    p = src->data[0];\n\n    src_wrap = src->linesize[0] - 3 * width;\n\n\n\n    q = dst->data[0];\n\n    dst_wrap = dst->linesize[0] - 2 * width;\n\n\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            r = p[0];\n\n            g = p[1];\n\n            b = p[2];\n\n\n\n            ((unsigned short *)q)[0] = \n\n                ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);\n\n            q += 2;\n\n            p += 3;\n\n        }\n\n        p += src_wrap;\n\n        q += dst_wrap;\n\n    }\n\n}\n","idx":347,"target":0}
{"code":"static void avc_luma_mid_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                                int32_t src_stride,\n\n                                                uint8_t *dst,\n\n                                                int32_t dst_stride)\n\n{\n\n    avc_luma_mid_and_aver_dst_8w_msa(src, src_stride, dst, dst_stride, 16);\n\n    avc_luma_mid_and_aver_dst_8w_msa(src + 8, src_stride, dst + 8, dst_stride,\n\n                                     16);\n\n}\n","idx":348,"target":0}
{"code":"void MPV_common_init_armv4l(MpegEncContext *s)\n\n{\n\n    int i;\n\n    const int idct_algo= s->avctx->idct_algo;\n\n\n\n    ff_put_pixels_clamped = s->avctx->dsp.put_pixels_clamped;\n\n    ff_add_pixels_clamped = s->avctx->dsp.put_pixels_clamped;\n\n\n\n    if(idct_algo==FF_IDCT_AUTO || idct_algo==FF_IDCT_ARM){\n\n        s->idct_put= arm_idct_put;\n\n        s->idct_add= arm_idct_add;\n\n        s->idct_permutation_type= FF_NO_IDCT_PERM;\n\n    }\n\n}\n","idx":349,"target":0}
{"code":"void ff_rtp_send_h263(AVFormatContext *s1, const uint8_t *buf1, int size)\n\n{\n\n    RTPMuxContext *s = s1->priv_data;\n\n    int len, max_packet_size;\n\n    uint8_t *q;\n\n\n\n    max_packet_size = s->max_payload_size;\n\n\n\n    while (size > 0) {\n\n        q = s->buf;\n\n        if ((buf1[0] == 0) && (buf1[1] == 0)) {\n\n            *q++ = 0x04;\n\n            buf1 += 2;\n\n            size -= 2;\n\n        } else {\n\n            *q++ = 0;\n\n        }\n\n        *q++ = 0;\n\n\n\n        len = FFMIN(max_packet_size - 2, size);\n\n\n\n        \/* Look for a better place to split the frame into packets. *\/\n\n        if (len < size) {\n\n            const uint8_t *end = find_resync_marker_reverse(buf1, buf1 + len);\n\n            len = end - buf1;\n\n        }\n\n\n\n        memcpy(q, buf1, len);\n\n        q += len;\n\n\n\n        \/* 90 KHz time stamp *\/\n\n        s->timestamp = s->cur_timestamp;\n\n        ff_rtp_send_data(s1, s->buf, q - s->buf, (len == size));\n\n\n\n        buf1 += len;\n\n        size -= len;\n\n    }\n\n}\n","idx":352,"target":1}
{"code":"DISAS_INSN(divw)\n\n{\n\n    TCGv reg;\n\n    TCGv tmp;\n\n    TCGv src;\n\n    int sign;\n\n\n\n    sign = (insn & 0x100) != 0;\n\n    reg = DREG(insn, 9);\n\n    if (sign) {\n\n        tcg_gen_ext16s_i32(QREG_DIV1, reg);\n\n    } else {\n\n        tcg_gen_ext16u_i32(QREG_DIV1, reg);\n\n    }\n\n    SRC_EA(env, src, OS_WORD, sign, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, src);\n\n    if (sign) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(1));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(1));\n\n    }\n\n\n\n    tmp = tcg_temp_new();\n\n    src = tcg_temp_new();\n\n    tcg_gen_ext16u_i32(tmp, QREG_DIV1);\n\n    tcg_gen_shli_i32(src, QREG_DIV2, 16);\n\n    tcg_gen_or_i32(reg, tmp, src);\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n","idx":354,"target":1}
{"code":"void block_job_enter(BlockJob *job)\n\n{\n\n    if (!block_job_started(job)) {\n\n        return;\n\n    }\n\n    if (job->deferred_to_main_loop) {\n\n        return;\n\n    }\n\n\n\n    if (!job->busy) {\n\n        bdrv_coroutine_enter(blk_bs(job->blk), job->co);\n\n    }\n\n}\n","idx":356,"target":1}
{"code":"void qmp_guest_shutdown(bool has_mode, const char *mode, Error **err)\n\n{\n\n    UINT shutdown_flag = EWX_FORCE;\n\n\n\n    slog(\"guest-shutdown called, mode: %s\", mode);\n\n\n\n    if (!has_mode || strcmp(mode, \"powerdown\") == 0) {\n\n        shutdown_flag |= EWX_POWEROFF;\n\n    } else if (strcmp(mode, \"halt\") == 0) {\n\n        shutdown_flag |= EWX_SHUTDOWN;\n\n    } else if (strcmp(mode, \"reboot\") == 0) {\n\n        shutdown_flag |= EWX_REBOOT;\n\n    } else {\n\n        error_set(err, QERR_INVALID_PARAMETER_VALUE, \"mode\",\n\n                  \"halt|powerdown|reboot\");\n\n        return;\n\n    }\n\n\n\n    \/* Request a shutdown privilege, but try to shut down the system\n\n       anyway. *\/\n\n    acquire_privilege(SE_SHUTDOWN_NAME, err);\n\n    if (error_is_set(err)) {\n\n        return;\n\n    }\n\n\n\n    if (!ExitWindowsEx(shutdown_flag, SHTDN_REASON_FLAG_PLANNED)) {\n\n        slog(\"guest-shutdown failed: %d\", GetLastError());\n\n        error_set(err, QERR_UNDEFINED_ERROR);\n\n    }\n\n}\n","idx":358,"target":1}
{"code":"BlockJobInfoList *qmp_query_block_jobs(Error **errp)\n\n{\n\n    BlockJobInfoList *head = NULL, **p_next = &head;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n\n\n        if (bs->job) {\n\n            BlockJobInfoList *elem = g_new0(BlockJobInfoList, 1);\n\n            elem->value = block_job_query(bs->job);\n\n            *p_next = elem;\n\n            p_next = &elem->next;\n\n        }\n\n\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return head;\n\n}\n","idx":360,"target":1}
{"code":"DeviceState *ssi_create_slave(SSIBus *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n    dev = qdev_create(&bus->qbus, name);\n\n    qdev_init(dev);\n\n    return dev;\n\n}\n","idx":361,"target":1}
{"code":"static void v9fs_renameat(void *opaque)\n{\n    ssize_t err = 0;\n    size_t offset = 7;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t olddirfid, newdirfid;\n    V9fsString old_name, new_name;\n    v9fs_string_init(&old_name);\n    v9fs_string_init(&new_name);\n    err = pdu_unmarshal(pdu, offset, \"dsds\", &olddirfid,\n                        &old_name, &newdirfid, &new_name);\n    if (err < 0) {\n    if (name_is_illegal(old_name.data) || name_is_illegal(new_name.data)) {\n        err = -ENOENT;\n    v9fs_path_write_lock(s);\n    err = v9fs_complete_renameat(pdu, olddirfid,\n                                 &old_name, newdirfid, &new_name);\n    v9fs_path_unlock(s);\n    if (!err) {\n        err = offset;\nout_err:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&old_name);\n    v9fs_string_free(&new_name);","idx":363,"target":1}
{"code":"static void mips_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(dev);\n\n    MIPSCPUClass *mcc = MIPS_CPU_GET_CLASS(dev);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    mcc->parent_realize(dev, errp);\n\n}\n","idx":365,"target":1}
{"code":"static void RENAME(vertical_compose53iL0)(uint8_t *_b0, uint8_t *_b1, uint8_t *_b2,\n\n                                          int width)\n\n{\n\n    int i;\n\n    TYPE *b0 = (TYPE *)_b0;\n\n    TYPE *b1 = (TYPE *)_b1;\n\n    TYPE *b2 = (TYPE *)_b2;\n\n    for (i = 0; i < width; i++)\n\n        b1[i] -= (b0[i] + b2[i] + 2) >> 2;\n\n}\n","idx":368,"target":1}
{"code":"void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n","idx":369,"target":1}
{"code":"void virtqueue_discard(VirtQueue *vq, const VirtQueueElement *elem,\n\n                       unsigned int len)\n\n{\n\n    vq->last_avail_idx--;\n\n\n    virtqueue_unmap_sg(vq, elem, len);\n\n}","idx":370,"target":1}
{"code":"static void arm_gic_common_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->reset = arm_gic_common_reset;\n\n    dc->realize = arm_gic_common_realize;\n\n    dc->props = arm_gic_common_properties;\n\n    dc->vmsd = &vmstate_gic;\n\n    dc->no_user = 1;\n\n}\n","idx":371,"target":1}
{"code":"static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n","idx":373,"target":1}
{"code":"static CharDriverState *qemu_chr_open_tty(QemuOpts *opts)\n\n{\n\n    const char *filename = qemu_opt_get(opts, \"path\");\n\n    CharDriverState *chr;\n\n    int fd;\n\n\n\n    TFR(fd = open(filename, O_RDWR | O_NONBLOCK));\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    tty_serial_init(fd, 115200, 'N', 8, 1);\n\n    chr = qemu_chr_open_fd(fd, fd);\n\n    if (!chr) {\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n    chr->chr_ioctl = tty_serial_ioctl;\n\n    chr->chr_close = qemu_chr_close_tty;\n\n    return chr;\n\n}\n","idx":374,"target":1}
{"code":"void object_property_set_qobject(Object *obj, QObject *value,\n\n                                 const char *name, Error **errp)\n\n{\n\n    Visitor *v;\n\n    \/* TODO: Should we reject, rather than ignore, excess input? *\/\n\n    v = qobject_input_visitor_new(value, false);\n\n    object_property_set(obj, v, name, errp);\n\n    visit_free(v);\n\n}\n","idx":375,"target":1}
{"code":"static int stellaris_sys_init(uint32_t base, qemu_irq irq,\n\n                              stellaris_board_info * board,\n\n                              uint8_t *macaddr)\n\n{\n\n    ssys_state *s;\n\n\n\n    s = (ssys_state *)g_malloc0(sizeof(ssys_state));\n\n    s->irq = irq;\n\n    s->board = board;\n\n    \/* Most devices come preprogrammed with a MAC address in the user data. *\/\n\n    s->user0 = macaddr[0] | (macaddr[1] << 8) | (macaddr[2] << 16);\n\n    s->user1 = macaddr[3] | (macaddr[4] << 8) | (macaddr[5] << 16);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &ssys_ops, s, \"ssys\", 0x00001000);\n\n    memory_region_add_subregion(get_system_memory(), base, &s->iomem);\n\n    ssys_reset(s);\n\n    vmstate_register(NULL, -1, &vmstate_stellaris_sys, s);\n\n    return 0;\n\n}\n","idx":377,"target":1}
{"code":"static void handle_user_command(Monitor *mon, const char *cmdline)\n\n{\n\n    QDict *qdict;\n\n    const mon_cmd_t *cmd;\n\n\n\n    qdict = qdict_new();\n\n\n\n    cmd = monitor_parse_command(mon, cmdline, 0, mon->cmd_table, qdict);\n\n    if (!cmd)\n\n        goto out;\n\n\n\n    if (handler_is_async(cmd)) {\n\n        user_async_cmd_handler(mon, cmd, qdict);\n\n    } else if (handler_is_qobject(cmd)) {\n\n        QObject *data = NULL;\n\n\n\n        \/* XXX: ignores the error code *\/\n\n        cmd->mhandler.cmd_new(mon, qdict, &data);\n\n        assert(!monitor_has_error(mon));\n\n        if (data) {\n\n            cmd->user_print(mon, data);\n\n            qobject_decref(data);\n\n        }\n\n    } else {\n\n        cmd->mhandler.cmd(mon, qdict);\n\n    }\n\n\n\nout:\n\n    QDECREF(qdict);\n\n}\n","idx":378,"target":1}
{"code":"static int kvm_recommended_vcpus(KVMState *s)\n\n{\n\n    int ret = kvm_check_extension(s, KVM_CAP_NR_VCPUS);\n\n    return (ret) ? ret : 4;\n\n}\n","idx":379,"target":1}
{"code":"static void reschedule_dma(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    qemu_bh_delete(dbs->bh);\n\n    dbs->bh = NULL;\n\n    dma_bdrv_cb(opaque, 0);\n\n}\n","idx":380,"target":1}
{"code":"static coroutine_fn void test_multi_co_schedule_entry(void *opaque)\n\n{\n\n    g_assert(to_schedule[id] == NULL);\n\n    atomic_mb_set(&to_schedule[id], qemu_coroutine_self());\n\n\n\n    while (!atomic_mb_read(&now_stopping)) {\n\n        int n;\n\n\n\n        n = g_test_rand_int_range(0, NUM_CONTEXTS);\n\n        schedule_next(n);\n\n        qemu_coroutine_yield();\n\n\n\n        g_assert(to_schedule[id] == NULL);\n\n        atomic_mb_set(&to_schedule[id], qemu_coroutine_self());\n\n    }\n\n}\n","idx":382,"target":1}
{"code":"static int mkv_check_tag(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t = NULL;\n\n\n\n    while ((t = av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)))\n\n        if (av_strcasecmp(t->key, \"title\") && av_strcasecmp(t->key, \"stereo_mode\"))\n\n            return 1;\n\n\n\n    return 0;\n\n}\n","idx":386,"target":0}
{"code":"static void gen_exception_return(DisasContext *s, TCGv pc)\n\n{\n\n    TCGv tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, 0xffffffff);\n\n    dead_tmp(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n","idx":390,"target":1}
{"code":"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n","idx":391,"target":1}
{"code":"static void pci_edu_realize(PCIDevice *pdev, Error **errp)\n\n{\n\n    EduState *edu = DO_UPCAST(EduState, pdev, pdev);\n\n    uint8_t *pci_conf = pdev->config;\n\n\n\n    timer_init_ms(&edu->dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);\n\n\n\n    qemu_mutex_init(&edu->thr_mutex);\n\n    qemu_cond_init(&edu->thr_cond);\n\n    qemu_thread_create(&edu->thread, \"edu\", edu_fact_thread,\n\n                       edu, QEMU_THREAD_JOINABLE);\n\n\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    if (msi_init(pdev, 0, 1, true, false, errp)) {\n\n        return;\n\n    }\n\n\n\n    memory_region_init_io(&edu->mmio, OBJECT(edu), &edu_mmio_ops, edu,\n\n                    \"edu-mmio\", 1 << 20);\n\n    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &edu->mmio);\n\n}\n","idx":392,"target":1}
{"code":"static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"\/dev\/fd\", NULL))\n\n        prio = 50;\n\n\n\n    fd = open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    \/* Attempt to detect via a floppy specific ioctl *\/\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    close(fd);\n\nout:\n\n    return prio;\n\n}\n","idx":397,"target":0}
{"code":"struct XenDevice *xen_be_find_xendev(const char *type, int dom, int dev)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    TAILQ_FOREACH(xendev, &xendevs, next) {\n\n\tif (xendev->dom != dom)\n\n\t    continue;\n\n\tif (xendev->dev != dev)\n\n\t    continue;\n\n\tif (strcmp(xendev->type, type) != 0)\n\n\t    continue;\n\n\treturn xendev;\n\n    }\n\n    return NULL;\n\n}\n","idx":398,"target":0}
{"code":"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n","idx":399,"target":0}
{"code":"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n","idx":402,"target":0}
{"code":"void qemu_system_debug_request(void)\n\n{\n\n    debug_requested = 1;\n\n    vm_stop(VMSTOP_DEBUG);\n\n}\n","idx":403,"target":0}
{"code":"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n","idx":404,"target":0}
{"code":"static int coroutine_fn raw_co_pwrite_zeroes(BlockDriverState *bs,\n\n                                             int64_t offset, int count,\n\n                                             BdrvRequestFlags flags)\n\n{\n\n    return bdrv_co_pwrite_zeroes(bs->file->bs, offset, count, flags);\n\n}\n","idx":405,"target":0}
{"code":"void monitor_flush(Monitor *mon)\n\n{\n\n    int i;\n\n    if (term_outbuf_index > 0) {\n\n        for (i = 0; i < MAX_MON; i++)\n\n            if (monitor_hd[i] && monitor_hd[i]->focus == 0)\n\n                qemu_chr_write(monitor_hd[i], term_outbuf, term_outbuf_index);\n\n        term_outbuf_index = 0;\n\n    }\n\n}\n","idx":406,"target":0}
{"code":"void qemu_co_queue_restart_all(CoQueue *queue)\n\n{\n\n    while (qemu_co_queue_next(queue)) {\n\n        \/* Do nothing *\/\n\n    }\n\n}\n","idx":407,"target":0}
{"code":"static void tftp_send_error(struct tftp_session *spt,\n\n                            uint16_t errorcode, const char *msg,\n\n                            struct tftp_t *recv_tp)\n\n{\n\n  struct sockaddr_in saddr, daddr;\n\n  struct mbuf *m;\n\n  struct tftp_t *tp;\n\n\n\n  m = m_get(spt->slirp);\n\n\n\n  if (!m) {\n\n    goto out;\n\n  }\n\n\n\n  memset(m->m_data, 0, m->m_size);\n\n\n\n  m->m_data += IF_MAXLINKHDR;\n\n  tp = (void *)m->m_data;\n\n  m->m_data += sizeof(struct udpiphdr);\n\n\n\n  tp->tp_op = htons(TFTP_ERROR);\n\n  tp->x.tp_error.tp_error_code = htons(errorcode);\n\n  pstrcpy((char *)tp->x.tp_error.tp_msg, sizeof(tp->x.tp_error.tp_msg), msg);\n\n\n\n  saddr.sin_addr = recv_tp->ip.ip_dst;\n\n  saddr.sin_port = recv_tp->udp.uh_dport;\n\n\n\n  daddr.sin_addr = spt->client_ip;\n\n  daddr.sin_port = spt->client_port;\n\n\n\n  m->m_len = sizeof(struct tftp_t) - 514 + 3 + strlen(msg) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n\n\n  udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n\n\nout:\n\n  tftp_session_terminate(spt);\n\n}\n","idx":409,"target":0}
{"code":"static void omap_rtc_alarm_update(struct omap_rtc_s *s)\n\n{\n\n    s->alarm_ti = mktimegm(&s->alarm_tm);\n\n    if (s->alarm_ti == -1)\n\n        printf(\"%s: conversion failed\\n\", __FUNCTION__);\n\n}\n","idx":410,"target":0}
{"code":"static inline bool vtd_iova_range_check(uint64_t iova, VTDContextEntry *ce)\n\n{\n\n    \/*\n\n     * Check if @iova is above 2^X-1, where X is the minimum of MGAW\n\n     * in CAP_REG and AW in context-entry.\n\n     *\/\n\n    return !(iova & ~(vtd_iova_limit(ce) - 1));\n\n}\n","idx":412,"target":0}
{"code":"void qerror_report_internal(const char *file, int linenr, const char *func,\n\n                            const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    QError *qerror;\n\n\n\n    va_start(va, fmt);\n\n    qerror = qerror_from_info(file, linenr, func, fmt, &va);\n\n    va_end(va);\n\n\n\n    if (cur_mon) {\n\n        monitor_set_error(cur_mon, qerror);\n\n    } else {\n\n        qerror_print(qerror);\n\n        QDECREF(qerror);\n\n    }\n\n}\n","idx":414,"target":0}
{"code":"static void qdev_prop_set(DeviceState *dev, const char *name, void *src, enum PropertyType type)\n\n{\n\n    Property *prop;\n\n\n\n    prop = qdev_prop_find(dev, name);\n\n    if (!prop) {\n\n        fprintf(stderr, \"%s: property \\\"%s.%s\\\" not found\\n\",\n\n                __FUNCTION__, object_get_typename(OBJECT(dev)), name);\n\n        abort();\n\n    }\n\n    if (prop->info->type != type) {\n\n        fprintf(stderr, \"%s: property \\\"%s.%s\\\" type mismatch\\n\",\n\n                __FUNCTION__, object_get_typename(OBJECT(dev)), name);\n\n        abort();\n\n    }\n\n    qdev_prop_cpy(dev, prop, src);\n\n}\n","idx":415,"target":0}
{"code":"void qdev_prop_set_drive_nofail(DeviceState *dev, const char *name,\n\n                                BlockDriverState *value)\n\n{\n\n    if (qdev_prop_set_drive(dev, name, value) < 0) {\n\n        exit(1);\n\n    }\n\n}\n","idx":416,"target":0}
{"code":"static int piix3_post_load(void *opaque, int version_id)\n\n{\n\n    PIIX3State *piix3 = opaque;\n\n    int pirq;\n\n\n\n    \/* Because the i8259 has not been deserialized yet, qemu_irq_raise\n\n     * might bring the system to a different state than the saved one;\n\n     * for example, the interrupt could be masked but the i8259 would\n\n     * not know that yet and would trigger an interrupt in the CPU.\n\n     *\n\n     * Here, we update irq levels without raising the interrupt.\n\n     * Interrupt state will be deserialized separately through the i8259.\n\n     *\/\n\n    piix3->pic_levels = 0;\n\n    for (pirq = 0; pirq < PIIX_NUM_PIRQS; pirq++) {\n\n        piix3_set_irq_level_internal(piix3, pirq,\n\n                            pci_bus_get_irq_level(piix3->dev.bus, pirq));\n\n    }\n\n    return 0;\n\n}\n","idx":417,"target":0}
{"code":"static void unset_dirty_tracking(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        aio_context_acquire(blk_get_aio_context(bmds->blk));\n\n        bdrv_release_dirty_bitmap(blk_bs(bmds->blk), bmds->dirty_bitmap);\n\n        aio_context_release(blk_get_aio_context(bmds->blk));\n\n    }\n\n}\n","idx":418,"target":0}
{"code":"static void cb_hmp_change_bdrv_pwd(Monitor *mon, const char *password,\n\n                                   void *opaque)\n\n{\n\n    Error *encryption_err = opaque;\n\n    Error *err = NULL;\n\n    const char *device;\n\n\n\n    device = error_get_field(encryption_err, \"device\");\n\n\n\n    qmp_block_passwd(device, password, &err);\n\n    hmp_handle_error(mon, &err);\n\n    error_free(encryption_err);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n","idx":419,"target":0}
{"code":"static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) {\n\n    int num_pos_channels = 0;\n\n    int first_cpe = 0;\n\n    int sce_parity = 0;\n\n    int i;\n\n    for (i = *current; i < tags; i++) {\n\n        if (layout_map[i][2] != pos)\n\n            break;\n\n        if (layout_map[i][0] == TYPE_CPE) {\n\n            if (sce_parity) {\n\n                if (pos == AAC_CHANNEL_FRONT || !first_cpe) {\n\n                    sce_parity = 0;\n\n                } else {\n\n                    return -1;\n\n                }\n\n            }\n\n            num_pos_channels += 2;\n\n            first_cpe = 1;\n\n        } else {\n\n            num_pos_channels++;\n\n            sce_parity ^= 1;\n\n        }\n\n    }\n\n    if (sce_parity &&\n\n        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))\n\n            return -1;\n\n    *current = i;\n\n    return num_pos_channels;\n\n}\n","idx":420,"target":0}
{"code":"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n\n{\n\n    IVI45DecContext *ctx = avctx->priv_data;\n\n\n\n    ivi_free_buffers(&ctx->planes[0]);\n\n\n\n    if (ctx->mb_vlc.cust_tab.table)\n\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n\n\n\n#if IVI4_STREAM_ANALYSER\n\n    if (ctx->is_indeo4) {\n\n    if (ctx->is_scalable)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses scalability mode!\\n\");\n\n    if (ctx->uses_tiling)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses local decoding!\\n\");\n\n    if (ctx->has_b_frames)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video contains B-frames!\\n\");\n\n    if (ctx->has_transp)\n\n        av_log(avctx, AV_LOG_ERROR, \"Transparency mode is enabled!\\n\");\n\n    if (ctx->uses_haar)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses Haar transform!\\n\");\n\n    if (ctx->uses_fullpel)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses fullpel motion vectors!\\n\");\n\n    }\n\n#endif\n\n\n\n    av_frame_free(&ctx->p_frame);\n\n\n\n    return 0;\n\n}\n","idx":421,"target":0}
{"code":"static av_cold int cinepak_decode_init(AVCodecContext *avctx)\n\n{\n\n    CinepakContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->width = (avctx->width + 3) & ~3;\n\n    s->height = (avctx->height + 3) & ~3;\n\n    s->sega_film_skip_bytes = -1;  \/* uninitialized state *\/\n\n\n\n    \/\/ check for paletted data\n\n    if (avctx->bits_per_coded_sample != 8) {\n\n        s->palette_video = 0;\n\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    } else {\n\n        s->palette_video = 1;\n\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n","idx":422,"target":0}
{"code":"static int xen_host_pci_config_open(XenHostPCIDevice *d)\n\n{\n\n    char path[PATH_MAX];\n\n    int rc;\n\n\n\n    rc = xen_host_pci_sysfs_path(d, \"config\", path, sizeof (path));\n\n    if (rc) {\n\n        return rc;\n\n    }\n\n    d->config_fd = open(path, O_RDWR);\n\n    if (d->config_fd < 0) {\n\n        return -errno;\n\n    }\n\n    return 0;\n\n}\n","idx":423,"target":1}
{"code":"static int vhost_set_vring_file(struct vhost_dev *dev,\n\n                                VhostUserRequest request,\n\n                                struct vhost_vring_file *file)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    size_t fd_num = 0;\n\n    VhostUserMsg msg = {\n\n        .request = request,\n\n        .flags = VHOST_USER_VERSION,\n\n        .payload.u64 = file->index & VHOST_USER_VRING_IDX_MASK,\n\n        .size = sizeof(msg.payload.u64),\n\n    };\n\n\n\n    if (ioeventfd_enabled() && file->fd > 0) {\n\n        fds[fd_num++] = file->fd;\n\n    } else {\n\n        msg.payload.u64 |= VHOST_USER_VRING_NOFD_MASK;\n\n    }\n\n\n\n    vhost_user_write(dev, &msg, fds, fd_num);\n\n\n\n    return 0;\n\n}\n","idx":425,"target":1}
{"code":"char *qdist_pr(const struct qdist *dist, size_t n_bins, uint32_t opt)\n\n{\n\n    const char *border = opt & QDIST_PR_BORDER ? \"|\" : \"\";\n\n    char *llabel, *rlabel;\n\n    char *hgram;\n\n    GString *s;\n\n\n\n    if (dist->n == 0) {\n\n        return NULL;\n\n    }\n\n\n\n    s = g_string_new(\"\");\n\n\n\n    llabel = qdist_pr_label(dist, n_bins, opt, true);\n\n    rlabel = qdist_pr_label(dist, n_bins, opt, false);\n\n    hgram = qdist_pr_plain(dist, n_bins);\n\n    g_string_append_printf(s, \"%s%s%s%s%s\",\n\n                           llabel, border, hgram, border, rlabel);\n\n    g_free(llabel);\n\n    g_free(rlabel);\n\n    g_free(hgram);\n\n\n\n    return g_string_free(s, FALSE);\n\n}\n","idx":426,"target":1}
{"code":"uint64_t helper_sublv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 - op2);\n\n    if (unlikely(((~tmp) ^ op1 ^ (-1UL)) & ((~tmp) ^ op2) & (1UL << 31))) {\n\n        helper_excp(EXCP_ARITH, EXCP_ARITH_OVERFLOW);\n\n    }\n\n    return op1;\n\n}\n","idx":427,"target":1}
{"code":"static QPCIDevice *get_ahci_device(uint32_t *fingerprint)\n\n{\n\n    QPCIDevice *ahci;\n\n    uint32_t ahci_fingerprint;\n\n    QPCIBus *pcibus;\n\n\n\n    pcibus = qpci_init_pc();\n\n\n\n    \/* Find the AHCI PCI device and verify it's the right one. *\/\n\n    ahci = qpci_device_find(pcibus, QPCI_DEVFN(0x1F, 0x02));\n\n    g_assert(ahci != NULL);\n\n\n\n    ahci_fingerprint = qpci_config_readl(ahci, PCI_VENDOR_ID);\n\n\n\n    switch (ahci_fingerprint) {\n\n    case AHCI_INTEL_ICH9:\n\n        break;\n\n    default:\n\n        \/* Unknown device. *\/\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    if (fingerprint) {\n\n        *fingerprint = ahci_fingerprint;\n\n    }\n\n    return ahci;\n\n}\n","idx":431,"target":1}
{"code":"static void tpm_tis_initfn(Object *obj)\n\n{\n\n    ISADevice *dev = ISA_DEVICE(obj);\n\n    TPMState *s = TPM(obj);\n\n\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &tpm_tis_memory_ops,\n\n                          s, \"tpm-tis-mmio\",\n\n                          TPM_TIS_NUM_LOCALITIES << TPM_TIS_LOCALITY_SHIFT);\n\n    memory_region_add_subregion(isa_address_space(dev), TPM_TIS_ADDR_BASE,\n\n                                &s->mmio);\n\n}\n","idx":434,"target":1}
{"code":"static int process_frame(FFFrameSync *fs)\n\n{\n\n    AVFilterContext *ctx = fs->parent;\n\n    LUT2Context *s = fs->opaque;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFrame *out, *srcx, *srcy;\n\n    int ret;\n\n\n\n    if ((ret = ff_framesync2_get_frame(&s->fs, 0, &srcx, 0)) < 0 ||\n\n        (ret = ff_framesync2_get_frame(&s->fs, 1, &srcy, 0)) < 0)\n\n        return ret;\n\n\n\n    if (ctx->is_disabled) {\n\n        out = av_frame_clone(srcx);\n\n        if (!out)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n\n        if (!out)\n\n            return AVERROR(ENOMEM);\n\n        av_frame_copy_props(out, srcx);\n\n\n\n        s->lut2(s, out, srcx, srcy);\n\n    }\n\n\n\n    out->pts = av_rescale_q(s->fs.pts, s->fs.time_base, outlink->time_base);\n\n\n\n    return ff_filter_frame(outlink, out);\n\n}\n","idx":435,"target":1}
{"code":"int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":439,"target":1}
{"code":"static int decode_exponents(AC3DecodeContext *ctx)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i;\n\n    uint8_t *exps;\n\n    uint8_t *dexps;\n\n\n\n    if (ab->flags & AC3_AB_CPLINU && ab->cplexpstr != AC3_EXPSTR_REUSE)\n\n        if (_decode_exponents(ab->cplexpstr, ab->ncplgrps, ab->cplabsexp,\n\n                    ab->cplexps, ab->dcplexps + ab->cplstrtmant))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (ab->chexpstr[i] != AC3_EXPSTR_REUSE) {\n\n            exps = ab->exps[i];\n\n            dexps = ab->dexps[i];\n\n            if (_decode_exponents(ab->chexpstr[i], ab->nchgrps[i], exps[0], exps + 1, dexps + 1))\n\n                return -1;\n\n        }\n\n    if (ctx->bsi.flags & AC3_BSI_LFEON && ab->lfeexpstr != AC3_EXPSTR_REUSE)\n\n        if (_decode_exponents(ab->lfeexpstr, 2, ab->lfeexps[0], ab->lfeexps + 1, ab->dlfeexps))\n\n            return -1;\n\n    return 0;\n\n}\n","idx":440,"target":0}
{"code":"void block_job_yield(BlockJob *job)\n\n{\n\n    assert(job->busy);\n\n\n\n    \/* Check cancellation *before* setting busy = false, too!  *\/\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    job->busy = false;\n\n    if (!block_job_should_pause(job)) {\n\n        qemu_coroutine_yield();\n\n    }\n\n    job->busy = true;\n\n\n\n    block_job_pause_point(job);\n\n}\n","idx":442,"target":1}
{"code":"static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"\/dev\/fd\", NULL) &&\n\n        !strstart(filename, \"\/dev\/fdset\/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    \/* Attempt to detect via a floppy specific ioctl *\/\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n","idx":444,"target":1}
{"code":"static int udp_close(URLContext *h)\n\n{\n\n    UDPContext *s = h->priv_data;\n\n\n\n    if (s->is_multicast && (h->flags & AVIO_FLAG_READ))\n\n        udp_leave_multicast_group(s->udp_fd, (struct sockaddr *)&s->dest_addr,(struct sockaddr *)&s->local_addr_storage);\n\n    closesocket(s->udp_fd);\n\n#if HAVE_PTHREAD_CANCEL\n\n    if (s->thread_started) {\n\n        int ret;\n\n        pthread_cancel(s->circular_buffer_thread);\n\n        ret = pthread_join(s->circular_buffer_thread, NULL);\n\n        if (ret != 0)\n\n            av_log(h, AV_LOG_ERROR, \"pthread_join(): %s\\n\", strerror(ret));\n\n        pthread_mutex_destroy(&s->mutex);\n\n        pthread_cond_destroy(&s->cond);\n\n    }\n\n#endif\n\n    av_fifo_freep(&s->fifo);\n\n    return 0;\n\n}\n","idx":445,"target":1}
{"code":"void ff_decode_dxt1(const uint8_t *s, uint8_t *dst,\n\n                    const unsigned int w, const unsigned int h,\n\n                    const unsigned int stride) {\n\n    unsigned int bx, by, qstride = stride\/4;\n\n    uint32_t *d = (uint32_t *) dst;\n\n\n\n    for (by=0; by < h\/4; by++, d += stride-w)\n\n        for (bx=0; bx < w\/4; bx++, s+=8, d+=4)\n\n            dxt1_decode_pixels(s, d, qstride, 0, 0LL);\n\n}\n","idx":448,"target":1}
{"code":"static const HWAccel *get_hwaccel(enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n    for (i = 0; hwaccels[i].name; i++)\n\n        if (hwaccels[i].pix_fmt == pix_fmt)\n\n            return &hwaccels[i];\n\n    return NULL;\n\n}\n","idx":450,"target":0}
{"code":"static enum AVHWDeviceType hw_device_match_type_in_name(const char *codec_name)\n\n{\n\n    const char *type_name;\n\n    enum AVHWDeviceType type;\n\n    for (type = av_hwdevice_iterate_types(AV_HWDEVICE_TYPE_NONE);\n\n         type != AV_HWDEVICE_TYPE_NONE;\n\n         type = av_hwdevice_iterate_types(type)) {\n\n        type_name = av_hwdevice_get_type_name(type);\n\n        if (strstr(codec_name, type_name))\n\n            return type;\n\n    }\n\n    return AV_HWDEVICE_TYPE_NONE;\n\n}\n","idx":455,"target":0}
{"code":"static av_cold int encode_close(AVCodecContext* avc_context)\n\n{\n\n    TheoraContext *h = avc_context->priv_data;\n\n\n\n    th_encode_free(h->t_state);\n\n    av_freep(&h->stats);\n\n    av_freep(&avc_context->coded_frame);\n\n    av_freep(&avc_context->stats_out);\n\n    av_freep(&avc_context->extradata);\n\n    avc_context->extradata_size = 0;\n\n\n\n    return 0;\n\n}\n","idx":456,"target":0}
{"code":"static char *assign_name(NetClientState *nc1, const char *model)\n\n{\n\n    NetClientState *nc;\n\n    char buf[256];\n\n    int id = 0;\n\n\n\n    QTAILQ_FOREACH(nc, &net_clients, next) {\n\n        if (nc == nc1) {\n\n            continue;\n\n        }\n\n        \/* For compatibility only bump id for net clients on a vlan *\/\n\n        if (strcmp(nc->model, model) == 0 &&\n\n            net_hub_id_for_client(nc, NULL) == 0) {\n\n            id++;\n\n        }\n\n    }\n\n\n\n    snprintf(buf, sizeof(buf), \"%s.%d\", model, id);\n\n\n\n    return g_strdup(buf);\n\n}\n","idx":458,"target":0}
{"code":"static void nbd_accept(void *opaque)\n\n{\n\n    int server_fd = (uintptr_t) opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addr_len = sizeof(addr);\n\n\n\n    int fd = accept(server_fd, (struct sockaddr *)&addr, &addr_len);\n\n    nbd_started = true;\n\n    if (fd >= 0 && nbd_client_new(exp, fd, nbd_client_closed)) {\n\n        nb_fds++;\n\n    }\n\n}\n","idx":459,"target":0}
{"code":"static inline bool migration_bitmap_test_and_reset_dirty(MemoryRegion *mr,\n\n                                                         ram_addr_t offset)\n\n{\n\n    bool ret;\n\n    int nr = (mr->ram_addr + offset) >> TARGET_PAGE_BITS;\n\n\n\n    ret = test_and_clear_bit(nr, migration_bitmap);\n\n\n\n    if (ret) {\n\n        migration_dirty_pages--;\n\n    }\n\n    return ret;\n\n}\n","idx":462,"target":0}
{"code":"static inline void gen_op_eval_bge(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_V(cpu_tmp0, src);\n\n    gen_mov_reg_N(dst, src);\n\n    tcg_gen_xor_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n","idx":463,"target":0}
{"code":"static int qcow_set_key(BlockDriverState *bs, const char *key)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint8_t keybuf[16];\n\n    int len, i;\n\n    Error *err;\n\n\n\n    memset(keybuf, 0, 16);\n\n    len = strlen(key);\n\n    if (len > 16)\n\n        len = 16;\n\n    \/* XXX: we could compress the chars to 7 bits to increase\n\n       entropy *\/\n\n    for(i = 0;i < len;i++) {\n\n        keybuf[i] = key[i];\n\n    }\n\n    assert(bs->encrypted);\n\n\n\n    qcrypto_cipher_free(s->cipher);\n\n    s->cipher = qcrypto_cipher_new(\n\n        QCRYPTO_CIPHER_ALG_AES_128,\n\n        QCRYPTO_CIPHER_MODE_CBC,\n\n        keybuf, G_N_ELEMENTS(keybuf),\n\n        &err);\n\n\n\n    if (!s->cipher) {\n\n        \/* XXX would be nice if errors in this method could\n\n         * be properly propagate to the caller. Would need\n\n         * the bdrv_set_key() API signature to be fixed. *\/\n\n        error_free(err);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n","idx":464,"target":0}
{"code":"static void fw_cfg_mem_realize(DeviceState *dev, Error **errp)\n\n{\n\n    FWCfgMemState *s = FW_CFG_MEM(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    memory_region_init_io(&s->ctl_iomem, OBJECT(s), &fw_cfg_ctl_mem_ops,\n\n                          FW_CFG(s), \"fwcfg.ctl\", FW_CFG_SIZE);\n\n    sysbus_init_mmio(sbd, &s->ctl_iomem);\n\n\n\n    memory_region_init_io(&s->data_iomem, OBJECT(s), &fw_cfg_data_mem_ops,\n\n                          FW_CFG(s), \"fwcfg.data\",\n\n                          fw_cfg_data_mem_ops.valid.max_access_size);\n\n    sysbus_init_mmio(sbd, &s->data_iomem);\n\n}\n","idx":466,"target":0}
{"code":"void ide_bus_reset(IDEBus *bus)\n\n{\n\n    bus->unit = 0;\n\n    bus->cmd = 0;\n\n    ide_reset(&bus->ifs[0]);\n\n    ide_reset(&bus->ifs[1]);\n\n    ide_clear_hob(bus);\n\n\n\n    \/* pending async DMA *\/\n\n    if (bus->dma->aiocb) {\n\n#ifdef DEBUG_AIO\n\n        printf(\"aio_cancel\\n\");\n\n#endif\n\n        bdrv_aio_cancel(bus->dma->aiocb);\n\n        bus->dma->aiocb = NULL;\n\n    }\n\n\n\n    \/* reset dma provider too *\/\n\n    if (bus->dma->ops->reset) {\n\n        bus->dma->ops->reset(bus->dma);\n\n    }\n\n}\n","idx":469,"target":0}
{"code":"MacIONVRAMState *macio_nvram_init (target_phys_addr_t size,\n\n                                   unsigned int it_shift)\n\n{\n\n    MacIONVRAMState *s;\n\n\n\n    s = g_malloc0(sizeof(MacIONVRAMState));\n\n    s->data = g_malloc0(size);\n\n    s->size = size;\n\n    s->it_shift = it_shift;\n\n\n\n    memory_region_init_io(&s->mem, &macio_nvram_ops, s, \"macio-nvram\",\n\n                          size << it_shift);\n\n    vmstate_register(NULL, -1, &vmstate_macio_nvram, s);\n\n    qemu_register_reset(macio_nvram_reset, s);\n\n\n\n    return s;\n\n}\n","idx":471,"target":0}
{"code":"static void cmd646_data_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t data, unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (size == 1) {\n\n        ide_ioport_write(cmd646bar->bus, addr, data);\n\n    } else if (addr == 0) {\n\n        if (size == 2) {\n\n            ide_data_writew(cmd646bar->bus, addr, data);\n\n        } else {\n\n            ide_data_writel(cmd646bar->bus, addr, data);\n\n        }\n\n    }\n\n}\n","idx":472,"target":0}
{"code":"static uint64_t kvm_apic_mem_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    return ~(uint64_t)0;\n\n}\n","idx":473,"target":0}
{"code":"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n","idx":474,"target":0}
{"code":"static uint64_t bonito_cop_readl(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    uint32_t val;\n\n    PCIBonitoState *s = opaque;\n\n\n\n    val = ((uint32_t *)(&s->boncop))[addr\/sizeof(uint32_t)];\n\n\n\n    return val;\n\n}\n","idx":475,"target":0}
{"code":"size_t iov_memset(const struct iovec *iov, const unsigned int iov_cnt,\n\n                 size_t iov_off, int fillc, size_t size)\n\n{\n\n    size_t iovec_off, buf_off;\n\n    unsigned int i;\n\n\n\n    iovec_off = 0;\n\n    buf_off = 0;\n\n    for (i = 0; i < iov_cnt && size; i++) {\n\n        if (iov_off < (iovec_off + iov[i].iov_len)) {\n\n            size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off , size);\n\n\n\n            memset(iov[i].iov_base + (iov_off - iovec_off), fillc, len);\n\n\n\n            buf_off += len;\n\n            iov_off += len;\n\n            size -= len;\n\n        }\n\n        iovec_off += iov[i].iov_len;\n\n    }\n\n    return buf_off;\n\n}\n","idx":476,"target":0}
{"code":"static int img_open_password(BlockBackend *blk, const char *filename,\n\n                             int flags, bool quiet)\n\n{\n\n    BlockDriverState *bs;\n\n    char password[256];\n\n\n\n    bs = blk_bs(blk);\n\n    if (bdrv_is_encrypted(bs) && !(flags & BDRV_O_NO_IO)) {\n\n        qprintf(quiet, \"Disk image '%s' is encrypted.\\n\", filename);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            return -1;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n","idx":477,"target":0}
{"code":"static void iothread_complete(UserCreatable *obj, Error **errp)\n\n{\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread->stopping = false;\n\n    iothread->ctx = aio_context_new();\n\n    iothread->thread_id = -1;\n\n\n\n    qemu_mutex_init(&iothread->init_done_lock);\n\n    qemu_cond_init(&iothread->init_done_cond);\n\n\n\n    \/* This assumes we are called from a thread with useful CPU affinity for us\n\n     * to inherit.\n\n     *\/\n\n    qemu_thread_create(&iothread->thread, \"iothread\", iothread_run,\n\n                       iothread, QEMU_THREAD_JOINABLE);\n\n\n\n    \/* Wait for initialization to complete *\/\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    while (iothread->thread_id == -1) {\n\n        qemu_cond_wait(&iothread->init_done_cond,\n\n                       &iothread->init_done_lock);\n\n    }\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n}\n","idx":481,"target":1}
