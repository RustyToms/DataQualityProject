{"code":"DVMuxContext* dv_init_mux(AVFormatContext* s)\n\n{\n\n    DVMuxContext *c;\n\n    AVStream *vst = NULL;\n\n    int i;\n\n\n\n    \/* we support at most 1 video and 2 audio streams *\/\n\n    if (s->nb_streams > 3)\n\n        return NULL;\n\n\n\n    c = av_mallocz(sizeof(DVMuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->n_ast = 0;\n\n    c->ast[0] = c->ast[1] = NULL;\n\n\n\n    \/* We have to sort out where audio and where video stream is *\/\n\n    for (i=0; i<s->nb_streams; i++) {\n\n         switch (s->streams[i]->codec->codec_type) {\n\n         case CODEC_TYPE_VIDEO:\n\n               vst = s->streams[i];\n\n               break;\n\n         case CODEC_TYPE_AUDIO:\n\n             c->ast[c->n_ast++] = s->streams[i];\n\n             break;\n\n         default:\n\n               goto bail_out;\n\n         }\n\n    }\n\n\n\n    \/* Some checks -- DV format is very picky about its incoming streams *\/\n\n    if (!vst || vst->codec->codec_id != CODEC_ID_DVVIDEO)\n\n        goto bail_out;\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && (c->ast[i]->codec->codec_id != CODEC_ID_PCM_S16LE ||\n\n                          c->ast[i]->codec->sample_rate != 48000 ||\n\n                          c->ast[i]->codec->channels != 2))\n\n            goto bail_out;\n\n    }\n\n    c->sys = dv_codec_profile(vst->codec);\n\n    if (!c->sys)\n\n        goto bail_out;\n\n\n\n    if((c->n_ast > 1) && (c->sys->n_difchan < 2)) {\n\n        \/* only 1 stereo pair is allowed in 25Mbps mode *\/\n\n        goto bail_out;\n\n    }\n\n\n\n    \/* Ok, everything seems to be in working order *\/\n\n    c->frames = 0;\n\n    c->has_audio = 0;\n\n    c->has_video = 0;\n\n    c->start_time = (time_t)s->timestamp;\n\n\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && av_fifo_init(&c->audio_data[i], 100*AVCODEC_MAX_AUDIO_FRAME_SIZE) < 0) {\n\n            while (i>0) {\n\n                i--;\n\n                av_fifo_free(&c->audio_data[i]);\n\n            }\n\n            goto bail_out;\n\n        }\n\n    }\n\n\n\n    return c;\n\n\n\nbail_out:\n\n    av_free(c);\n\n    return NULL;\n\n}\n","idx":4229,"target":1}
{"code":"static void adpcm_compress_trellis(AVCodecContext *avctx,\n\n                                   const int16_t *samples, uint8_t *dst,\n\n                                   ADPCMChannelStatus *c, int n, int stride)\n\n{\n\n    \/\/FIXME 6% faster if frontier is a compile-time constant\n\n    ADPCMEncodeContext *s = avctx->priv_data;\n\n    const int frontier = 1 << avctx->trellis;\n\n    const int version  = avctx->codec->id;\n\n    TrellisPath *paths       = s->paths, *p;\n\n    TrellisNode *node_buf    = s->node_buf;\n\n    TrellisNode **nodep_buf  = s->nodep_buf;\n\n    TrellisNode **nodes      = nodep_buf; \/\/ nodes[] is always sorted by .ssd\n\n    TrellisNode **nodes_next = nodep_buf + frontier;\n\n    int pathn = 0, froze = -1, i, j, k, generation = 0;\n\n    uint8_t *hash = s->trellis_hash;\n\n    memset(hash, 0xff, 65536 * sizeof(*hash));\n\n\n\n    memset(nodep_buf, 0, 2 * frontier * sizeof(*nodep_buf));\n\n    nodes[0]          = node_buf + frontier;\n\n    nodes[0]->ssd     = 0;\n\n    nodes[0]->path    = 0;\n\n    nodes[0]->step    = c->step_index;\n\n    nodes[0]->sample1 = c->sample1;\n\n    nodes[0]->sample2 = c->sample2;\n\n    if (version == AV_CODEC_ID_ADPCM_IMA_WAV ||\n\n        version == AV_CODEC_ID_ADPCM_IMA_QT  ||\n\n        version == AV_CODEC_ID_ADPCM_SWF)\n\n        nodes[0]->sample1 = c->prev_sample;\n\n    if (version == AV_CODEC_ID_ADPCM_MS)\n\n        nodes[0]->step = c->idelta;\n\n    if (version == AV_CODEC_ID_ADPCM_YAMAHA) {\n\n        if (c->step == 0) {\n\n            nodes[0]->step    = 127;\n\n            nodes[0]->sample1 = 0;\n\n        } else {\n\n            nodes[0]->step    = c->step;\n\n            nodes[0]->sample1 = c->predictor;\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < n; i++) {\n\n        TrellisNode *t = node_buf + frontier*(i&1);\n\n        TrellisNode **u;\n\n        int sample   = samples[i * stride];\n\n        int heap_pos = 0;\n\n        memset(nodes_next, 0, frontier * sizeof(TrellisNode*));\n\n        for (j = 0; j < frontier && nodes[j]; j++) {\n\n            \/\/ higher j have higher ssd already, so they're likely\n\n            \/\/ to yield a suboptimal next sample too\n\n            const int range = (j < frontier \/ 2) ? 1 : 0;\n\n            const int step  = nodes[j]->step;\n\n            int nidx;\n\n            if (version == AV_CODEC_ID_ADPCM_MS) {\n\n                const int predictor = ((nodes[j]->sample1 * c->coeff1) +\n\n                                       (nodes[j]->sample2 * c->coeff2)) \/ 64;\n\n                const int div  = (sample - predictor) \/ step;\n\n                const int nmin = av_clip(div-range, -8, 6);\n\n                const int nmax = av_clip(div+range, -7, 7);\n\n                for (nidx = nmin; nidx <= nmax; nidx++) {\n\n                    const int nibble = nidx & 0xf;\n\n                    int dec_sample   = predictor + nidx * step;\n\n#define STORE_NODE(NAME, STEP_INDEX)\\\n\n                    int d;\\\n\n                    uint32_t ssd;\\\n\n                    int pos;\\\n\n                    TrellisNode *u;\\\n\n                    uint8_t *h;\\\n\n                    dec_sample = av_clip_int16(dec_sample);\\\n\n                    d = sample - dec_sample;\\\n\n                    ssd = nodes[j]->ssd + d*d;\\\n\n                    \/* Check for wraparound, skip such samples completely. \\\n\n                     * Note, changing ssd to a 64 bit variable would be \\\n\n                     * simpler, avoiding this check, but it's slower on \\\n\n                     * x86 32 bit at the moment. *\/\\\n\n                    if (ssd < nodes[j]->ssd)\\\n\n                        goto next_##NAME;\\\n\n                    \/* Collapse any two states with the same previous sample value. \\\n\n                     * One could also distinguish states by step and by 2nd to last\n\n                     * sample, but the effects of that are negligible.\n\n                     * Since nodes in the previous generation are iterated\n\n                     * through a heap, they're roughly ordered from better to\n\n                     * worse, but not strictly ordered. Therefore, an earlier\n\n                     * node with the same sample value is better in most cases\n\n                     * (and thus the current is skipped), but not strictly\n\n                     * in all cases. Only skipping samples where ssd >=\n\n                     * ssd of the earlier node with the same sample gives\n\n                     * slightly worse quality, though, for some reason. *\/ \\\n\n                    h = &hash[(uint16_t) dec_sample];\\\n\n                    if (*h == generation)\\\n\n                        goto next_##NAME;\\\n\n                    if (heap_pos < frontier) {\\\n\n                        pos = heap_pos++;\\\n\n                    } else {\\\n\n                        \/* Try to replace one of the leaf nodes with the new \\\n\n                         * one, but try a different slot each time. *\/\\\n\n                        pos = (frontier >> 1) +\\\n\n                              (heap_pos & ((frontier >> 1) - 1));\\\n\n                        if (ssd > nodes_next[pos]->ssd)\\\n\n                            goto next_##NAME;\\\n\n                        heap_pos++;\\\n\n                    }\\\n\n                    *h = generation;\\\n\n                    u  = nodes_next[pos];\\\n\n                    if (!u) {\\\n\n                        av_assert1(pathn < FREEZE_INTERVAL << avctx->trellis);\\\n\n                        u = t++;\\\n\n                        nodes_next[pos] = u;\\\n\n                        u->path = pathn++;\\\n\n                    }\\\n\n                    u->ssd  = ssd;\\\n\n                    u->step = STEP_INDEX;\\\n\n                    u->sample2 = nodes[j]->sample1;\\\n\n                    u->sample1 = dec_sample;\\\n\n                    paths[u->path].nibble = nibble;\\\n\n                    paths[u->path].prev   = nodes[j]->path;\\\n\n                    \/* Sift the newly inserted node up in the heap to \\\n\n                     * restore the heap property. *\/\\\n\n                    while (pos > 0) {\\\n\n                        int parent = (pos - 1) >> 1;\\\n\n                        if (nodes_next[parent]->ssd <= ssd)\\\n\n                            break;\\\n\n                        FFSWAP(TrellisNode*, nodes_next[parent], nodes_next[pos]);\\\n\n                        pos = parent;\\\n\n                    }\\\n\n                    next_##NAME:;\n\n                    STORE_NODE(ms, FFMAX(16,\n\n                               (ff_adpcm_AdaptationTable[nibble] * step) >> 8));\n\n                }\n\n            } else if (version == AV_CODEC_ID_ADPCM_IMA_WAV ||\n\n                       version == AV_CODEC_ID_ADPCM_IMA_QT  ||\n\n                       version == AV_CODEC_ID_ADPCM_SWF) {\n\n#define LOOP_NODES(NAME, STEP_TABLE, STEP_INDEX)\\\n\n                const int predictor = nodes[j]->sample1;\\\n\n                const int div = (sample - predictor) * 4 \/ STEP_TABLE;\\\n\n                int nmin = av_clip(div - range, -7, 6);\\\n\n                int nmax = av_clip(div + range, -6, 7);\\\n\n                if (nmin <= 0)\\\n\n                    nmin--; \/* distinguish -0 from +0 *\/\\\n\n                if (nmax < 0)\\\n\n                    nmax--;\\\n\n                for (nidx = nmin; nidx <= nmax; nidx++) {\\\n\n                    const int nibble = nidx < 0 ? 7 - nidx : nidx;\\\n\n                    int dec_sample = predictor +\\\n\n                                    (STEP_TABLE *\\\n\n                                     ff_adpcm_yamaha_difflookup[nibble]) \/ 8;\\\n\n                    STORE_NODE(NAME, STEP_INDEX);\\\n\n                }\n\n                LOOP_NODES(ima, ff_adpcm_step_table[step],\n\n                           av_clip(step + ff_adpcm_index_table[nibble], 0, 88));\n\n            } else { \/\/AV_CODEC_ID_ADPCM_YAMAHA\n\n                LOOP_NODES(yamaha, step,\n\n                           av_clip((step * ff_adpcm_yamaha_indexscale[nibble]) >> 8,\n\n                                   127, 24567));\n\n#undef LOOP_NODES\n\n#undef STORE_NODE\n\n            }\n\n        }\n\n\n\n        u = nodes;\n\n        nodes = nodes_next;\n\n        nodes_next = u;\n\n\n\n        generation++;\n\n        if (generation == 255) {\n\n            memset(hash, 0xff, 65536 * sizeof(*hash));\n\n            generation = 0;\n\n        }\n\n\n\n        \/\/ prevent overflow\n\n        if (nodes[0]->ssd > (1 << 28)) {\n\n            for (j = 1; j < frontier && nodes[j]; j++)\n\n                nodes[j]->ssd -= nodes[0]->ssd;\n\n            nodes[0]->ssd = 0;\n\n        }\n\n\n\n        \/\/ merge old paths to save memory\n\n        if (i == froze + FREEZE_INTERVAL) {\n\n            p = &paths[nodes[0]->path];\n\n            for (k = i; k > froze; k--) {\n\n                dst[k] = p->nibble;\n\n                p = &paths[p->prev];\n\n            }\n\n            froze = i;\n\n            pathn = 0;\n\n            \/\/ other nodes might use paths that don't coincide with the frozen one.\n\n            \/\/ checking which nodes do so is too slow, so just kill them all.\n\n            \/\/ this also slightly improves quality, but I don't know why.\n\n            memset(nodes + 1, 0, (frontier - 1) * sizeof(TrellisNode*));\n\n        }\n\n    }\n\n\n\n    p = &paths[nodes[0]->path];\n\n    for (i = n - 1; i > froze; i--) {\n\n        dst[i] = p->nibble;\n\n        p = &paths[p->prev];\n\n    }\n\n\n\n    c->predictor  = nodes[0]->sample1;\n\n    c->sample1    = nodes[0]->sample1;\n\n    c->sample2    = nodes[0]->sample2;\n\n    c->step_index = nodes[0]->step;\n\n    c->step       = nodes[0]->step;\n\n    c->idelta     = nodes[0]->step;\n\n}\n","idx":14295,"target":1}
{"code":"static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if ((layer_info->channel_info[channel].type < -1) &&\n      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))\n    {\n      const char\n        *option;\n\n      \/*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      *\/\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n       if ((layer_info->channel_info[channel].type != -2) ||\n           (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n            (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n      }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n       if (mask != (Image *) NULL)\n        {\n          SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n","idx":183188,"target":1}
{"code":"static void perf_lifecycle(void)\n\n{\n\n    Coroutine *coroutine;\n\n    unsigned int i, max;\n\n    double duration;\n\n\n\n    max = 1000000;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < max; i++) {\n\n        coroutine = qemu_coroutine_create(empty_coroutine);\n\n        qemu_coroutine_enter(coroutine, NULL);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Lifecycle %u iterations: %f s\\n\", max, duration);\n\n}\n","idx":6630,"target":1}
{"code":"CPUState *ppc440ep_init(ram_addr_t *ram_size, PCIBus **pcip,\n\n                        const unsigned int pci_irq_nrs[4], int do_init,\n\n                        const char *cpu_model)\n\n{\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"405\"; \/\/ XXX: should be 440EP\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    \/* interrupt controller *\/\n\n    irqs = qemu_mallocz(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    \/* SDRAM controller *\/\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    \/* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. *\/\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_bases,\n\n                      ram_sizes, do_init);\n\n\n\n    \/* PCI *\/\n\n    pci_irqs = qemu_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[0], 1, 1);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[1], 1, 1);\n\n    }\n\n\n\n    return env;\n\n}\n","idx":14618,"target":1}
{"code":"static void encode_gray_bitstream(HYuvContext *s, int count){\n\n    int i;\n\n    \n\n    count\/=2;\n\n    if(s->flags&CODEC_FLAG_PASS1){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n        }\n\n    }else if(s->context){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }else{\n\n        for(i=0; i<count; i++){\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }\n\n}\n","idx":27219,"target":1}
{"code":"void PrintPreviewDataService::RemoveEntry(\n    const std::string& preview_ui_addr_str) {\n  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);\n  if (it != data_store_map_.end())\n    data_store_map_.erase(it);\n }\n","idx":184397,"target":1}
{"code":"static void m68k_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    M68kCPU *cpu = M68K_CPU(dev);\n\n    M68kCPUClass *mcc = M68K_CPU_GET_CLASS(dev);\n\n\n\n    m68k_cpu_init_gdb(cpu);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    mcc->parent_realize(dev, errp);\n\n}\n","idx":18694,"target":1}
{"code":"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    AVFrame *const p   = data;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n    const uint8_t *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin       = AV_RL16(buf + 4);\n\n    ymin       = AV_RL16(buf + 6);\n\n    xmax       = AV_RL16(buf + 8);\n\n    ymax       = AV_RL16(buf + 10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf + 66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) \/ 8 ||\n\n        (!compressed && bytes_per_scanline > buf_size \/ h)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes << 8) + bits_per_pixel) {\n\n    case 0x0308:\n\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n        break;\n\n    case 0x0108:\n\n    case 0x0104:\n\n    case 0x0102:\n\n    case 0x0101:\n\n    case 0x0401:\n\n    case 0x0301:\n\n    case 0x0201:\n\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y = 0; y < h; y++) {\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x = 0; x < w; x++) {\n\n                ptr[3 * x]     = scanline[x];\n\n                ptr[3 * x + 1] = scanline[x + bytes_per_line];\n\n                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        if (buf_size < 769) {\n\n            av_log(avctx, AV_LOG_ERROR, \"File is too short\\n\");\n\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n\n                  AVERROR_INVALIDDATA : buf_size;\n\n            goto end;\n\n        }\n\n\n\n        for (y = 0; y < h; y++, ptr += stride) {\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n\n                  AVERROR_INVALIDDATA : buf_size;\n\n            goto end;\n\n        }\n\n    } else if (nplanes == 1) {   \/* all packed formats, max. 16 colors *\/\n\n        GetBitContext s;\n\n\n\n        for (y = 0; y < h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n\n\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x = 0; x < w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n    } else {    \/* planar, 4, 8 or 16 colors *\/\n\n        int i;\n\n\n\n        for (y = 0; y < h; y++) {\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x = 0; x < w; x++) {\n\n                int m = 0x80 >> (x & 7), v = 0;\n\n                for (i = nplanes - 1; i >= 0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart + 16;\n\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n","idx":15259,"target":1}
{"code":"static int announce_self_create(uint8_t *buf, \n\n\t\t\t\tuint8_t *mac_addr)\n\n{\n\n    uint32_t magic = EXPERIMENTAL_MAGIC;\n\n    uint16_t proto = htons(ETH_P_EXPERIMENTAL);\n\n\n\n    \/* FIXME: should we send a different packet (arp\/rarp\/ping)? *\/\n\n\n\n    memset(buf, 0, 64);\n\n    memset(buf, 0xff, 6);         \/* h_dst *\/\n\n    memcpy(buf + 6, mac_addr, 6); \/* h_src *\/\n\n    memcpy(buf + 12, &proto, 2);  \/* h_proto *\/\n\n    memcpy(buf + 14, &magic, 4);  \/* magic *\/\n\n\n\n    return 64; \/* len *\/\n\n}\n","idx":18951,"target":1}
{"code":"static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    switch(w->abt_type_table[n]){\n\n    case 0:\n\n        if (s->block_last_index[n] >= 0) {\n\n            s->dsp.idct_add (dst, stride, block1);\n\n        }\n\n        break;\n\n    case 1:\n\n        simple_idct84_add(dst           , stride, block1);\n\n        simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    case 2:\n\n        simple_idct48_add(dst           , stride, block1);\n\n        simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    default:\n\n        av_log(s->avctx, AV_LOG_ERROR, \"internal error in WMV2 abt\\n\");\n\n    }\n\n}\n","idx":11866,"target":1}
{"code":"int attribute_align_arg avresample_convert(AVAudioResampleContext *avr,\n\n                                           uint8_t **output, int out_plane_size,\n\n                                           int out_samples, uint8_t **input,\n\n                                           int in_plane_size, int in_samples)\n\n{\n\n    AudioData input_buffer;\n\n    AudioData output_buffer;\n\n    AudioData *current_buffer;\n\n    int ret, direct_output;\n\n\n\n    \/* reset internal buffers *\/\n\n    if (avr->in_buffer) {\n\n        avr->in_buffer->nb_samples = 0;\n\n        ff_audio_data_set_channels(avr->in_buffer,\n\n                                   avr->in_buffer->allocated_channels);\n\n    }\n\n    if (avr->resample_out_buffer) {\n\n        avr->resample_out_buffer->nb_samples = 0;\n\n        ff_audio_data_set_channels(avr->resample_out_buffer,\n\n                                   avr->resample_out_buffer->allocated_channels);\n\n    }\n\n    if (avr->out_buffer) {\n\n        avr->out_buffer->nb_samples = 0;\n\n        ff_audio_data_set_channels(avr->out_buffer,\n\n                                   avr->out_buffer->allocated_channels);\n\n    }\n\n\n\n    av_dlog(avr, \"[start conversion]\\n\");\n\n\n\n    \/* initialize output_buffer with output data *\/\n\n    direct_output = output && av_audio_fifo_size(avr->out_fifo) == 0;\n\n    if (output) {\n\n        ret = ff_audio_data_init(&output_buffer, output, out_plane_size,\n\n                                 avr->out_channels, out_samples,\n\n                                 avr->out_sample_fmt, 0, \"output\");\n\n        if (ret < 0)\n\n            return ret;\n\n        output_buffer.nb_samples = 0;\n\n    }\n\n\n\n    if (input) {\n\n        \/* initialize input_buffer with input data *\/\n\n        ret = ff_audio_data_init(&input_buffer, input, in_plane_size,\n\n                                 avr->in_channels, in_samples,\n\n                                 avr->in_sample_fmt, 1, \"input\");\n\n        if (ret < 0)\n\n            return ret;\n\n        current_buffer = &input_buffer;\n\n\n\n        if (avr->upmix_needed && !avr->in_convert_needed && !avr->resample_needed &&\n\n            !avr->out_convert_needed && direct_output && out_samples >= in_samples) {\n\n            \/* in some rare cases we can copy input to output and upmix\n\n               directly in the output buffer *\/\n\n            av_dlog(avr, \"[copy] %s to output\\n\", current_buffer->name);\n\n            ret = ff_audio_data_copy(&output_buffer, current_buffer,\n\n                                     avr->remap_point == REMAP_OUT_COPY ?\n\n                                     &avr->ch_map_info : NULL);\n\n            if (ret < 0)\n\n                return ret;\n\n            current_buffer = &output_buffer;\n\n        } else if (avr->remap_point == REMAP_OUT_COPY &&\n\n                   (!direct_output || out_samples < in_samples)) {\n\n            \/* if remapping channels during output copy, we may need to\n\n             * use an intermediate buffer in order to remap before adding\n\n             * samples to the output fifo *\/\n\n            av_dlog(avr, \"[copy] %s to out_buffer\\n\", current_buffer->name);\n\n            ret = ff_audio_data_copy(avr->out_buffer, current_buffer,\n\n                                     &avr->ch_map_info);\n\n            if (ret < 0)\n\n                return ret;\n\n            current_buffer = avr->out_buffer;\n\n        } else if (avr->in_copy_needed || avr->in_convert_needed) {\n\n            \/* if needed, copy or convert input to in_buffer, and downmix if\n\n               applicable *\/\n\n            if (avr->in_convert_needed) {\n\n                ret = ff_audio_data_realloc(avr->in_buffer,\n\n                                            current_buffer->nb_samples);\n\n                if (ret < 0)\n\n                    return ret;\n\n                av_dlog(avr, \"[convert] %s to in_buffer\\n\", current_buffer->name);\n\n                ret = ff_audio_convert(avr->ac_in, avr->in_buffer,\n\n                                       current_buffer);\n\n                if (ret < 0)\n\n                    return ret;\n\n            } else {\n\n                av_dlog(avr, \"[copy] %s to in_buffer\\n\", current_buffer->name);\n\n                ret = ff_audio_data_copy(avr->in_buffer, current_buffer,\n\n                                         avr->remap_point == REMAP_IN_COPY ?\n\n                                         &avr->ch_map_info : NULL);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n            ff_audio_data_set_channels(avr->in_buffer, avr->in_channels);\n\n            if (avr->downmix_needed) {\n\n                av_dlog(avr, \"[downmix] in_buffer\\n\");\n\n                ret = ff_audio_mix(avr->am, avr->in_buffer);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n            current_buffer = avr->in_buffer;\n\n        }\n\n    } else {\n\n        \/* flush resampling buffer and\/or output FIFO if input is NULL *\/\n\n        if (!avr->resample_needed)\n\n            return handle_buffered_output(avr, output ? &output_buffer : NULL,\n\n                                          NULL);\n\n        current_buffer = NULL;\n\n    }\n\n\n\n    if (avr->resample_needed) {\n\n        AudioData *resample_out;\n\n\n\n        if (!avr->out_convert_needed && direct_output && out_samples > 0)\n\n            resample_out = &output_buffer;\n\n        else\n\n            resample_out = avr->resample_out_buffer;\n\n        av_dlog(avr, \"[resample] %s to %s\\n\", current_buffer->name,\n\n                resample_out->name);\n\n        ret = ff_audio_resample(avr->resample, resample_out,\n\n                                current_buffer);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        \/* if resampling did not produce any samples, just return 0 *\/\n\n        if (resample_out->nb_samples == 0) {\n\n            av_dlog(avr, \"[end conversion]\\n\");\n\n            return 0;\n\n        }\n\n\n\n        current_buffer = resample_out;\n\n    }\n\n\n\n    if (avr->upmix_needed) {\n\n        av_dlog(avr, \"[upmix] %s\\n\", current_buffer->name);\n\n        ret = ff_audio_mix(avr->am, current_buffer);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    \/* if we resampled or upmixed directly to output, return here *\/\n\n    if (current_buffer == &output_buffer) {\n\n        av_dlog(avr, \"[end conversion]\\n\");\n\n        return current_buffer->nb_samples;\n\n    }\n\n\n\n    if (avr->out_convert_needed) {\n\n        if (direct_output && out_samples >= current_buffer->nb_samples) {\n\n            \/* convert directly to output *\/\n\n            av_dlog(avr, \"[convert] %s to output\\n\", current_buffer->name);\n\n            ret = ff_audio_convert(avr->ac_out, &output_buffer, current_buffer);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            av_dlog(avr, \"[end conversion]\\n\");\n\n            return output_buffer.nb_samples;\n\n        } else {\n\n            ret = ff_audio_data_realloc(avr->out_buffer,\n\n                                        current_buffer->nb_samples);\n\n            if (ret < 0)\n\n                return ret;\n\n            av_dlog(avr, \"[convert] %s to out_buffer\\n\", current_buffer->name);\n\n            ret = ff_audio_convert(avr->ac_out, avr->out_buffer,\n\n                                   current_buffer);\n\n            if (ret < 0)\n\n                return ret;\n\n            current_buffer = avr->out_buffer;\n\n        }\n\n    }\n\n\n\n    return handle_buffered_output(avr, output ? &output_buffer : NULL,\n\n                                  current_buffer);\n\n}\n","idx":24111,"target":1}
{"code":"static void tcp_wait_for_connect(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    int val, ret;\n\n    socklen_t valsize = sizeof(val);\n\n\n\n    DPRINTF(\"connect completed\\n\");\n\n    do {\n\n        ret = getsockopt(s->fd, SOL_SOCKET, SO_ERROR, (void *) &val, &valsize);\n\n    } while (ret == -1 && (socket_error()) == EINTR);\n\n\n\n    if (ret < 0) {\n\n        migrate_fd_error(s);\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s->fd, NULL, NULL, NULL, NULL);\n\n\n\n    if (val == 0)\n\n        migrate_fd_connect(s);\n\n    else {\n\n        DPRINTF(\"error connecting %d\\n\", val);\n\n        migrate_fd_error(s);\n\n    }\n\n}\n","idx":23032,"target":1}
{"code":"static void read_apic(AVFormatContext *s, AVIOContext *pb, int taglen, char *tag, ID3v2ExtraMeta **extra_meta)\n\n{\n\n    int enc, pic_type;\n\n    char             mimetype[64];\n\n    const CodecMime     *mime = ff_id3v2_mime_tags;\n\n    enum AVCodecID           id = AV_CODEC_ID_NONE;\n\n    ID3v2ExtraMetaAPIC  *apic = NULL;\n\n    ID3v2ExtraMeta *new_extra = NULL;\n\n    int64_t               end = avio_tell(pb) + taglen;\n\n\n\n    if (taglen <= 4)\n\n        goto fail;\n\n\n\n    new_extra = av_mallocz(sizeof(*new_extra));\n\n    apic      = av_mallocz(sizeof(*apic));\n\n    if (!new_extra || !apic)\n\n        goto fail;\n\n\n\n    enc = avio_r8(pb);\n\n    taglen--;\n\n\n\n    \/* mimetype *\/\n\n    taglen -= avio_get_str(pb, taglen, mimetype, sizeof(mimetype));\n\n    while (mime->id != AV_CODEC_ID_NONE) {\n\n        if (!av_strncasecmp(mime->str, mimetype, sizeof(mimetype))) {\n\n            id = mime->id;\n\n            break;\n\n        }\n\n        mime++;\n\n    }\n\n    if (id == AV_CODEC_ID_NONE) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture mimetype: %s, skipping.\\n\", mimetype);\n\n        goto fail;\n\n    }\n\n    apic->id = id;\n\n\n\n    \/* picture type *\/\n\n    pic_type = avio_r8(pb);\n\n    taglen--;\n\n    if (pic_type < 0 || pic_type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type %d.\\n\", pic_type);\n\n        pic_type = 0;\n\n    }\n\n    apic->type = ff_id3v2_picture_types[pic_type];\n\n\n\n    \/* description and picture data *\/\n\n    if (decode_str(s, pb, enc, &apic->description, &taglen) < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"Error decoding attached picture description.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    apic->buf = av_buffer_alloc(taglen);\n\n    if (!apic->buf || !taglen || avio_read(pb, apic->buf->data, taglen) != taglen)\n\n        goto fail;\n\n\n\n    new_extra->tag    = \"APIC\";\n\n    new_extra->data   = apic;\n\n    new_extra->next   = *extra_meta;\n\n    *extra_meta       = new_extra;\n\n\n\n    return;\n\n\n\nfail:\n\n    if (apic)\n\n        free_apic(apic);\n\n    av_freep(&new_extra);\n\n    avio_seek(pb, end, SEEK_SET);\n\n}\n","idx":6127,"target":1}
{"code":"OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","idx":188225,"target":1}
{"code":"OMX_ERRORTYPE SoftFlacEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamAudioPcm)\");\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams = (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 ALOGE(\"SoftFlacEncoder::internalSetParameter() Error #1\");\n                 return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n            ALOGV(\"will encode %d channels at %dHz\", mNumChannels, mSampleRate);\n\n return configureEncoder();\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\");\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                     \"audio_encoder.flac\",\n                     OMX_MAX_STRINGNAME_SIZE - 1)) {\n                ALOGE(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\"\n \"error\");\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioFlac:\n\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             mCompressionLevel = flacParams->nCompressionLevel; \/\/ range clamping done inside encoder\n             return OMX_ErrorNone;\n         }\n\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex == 0) {\n                 if (defParams->nBufferSize > kMaxInputBufferSize) {\n                     ALOGE(\"Input buffer size must be at most %d bytes\",\n                        kMaxInputBufferSize);\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n }\n\n default:\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(default)\");\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","idx":188226,"target":1}
{"code":"av_cold static int auto_matrix(SwrContext *s)\n\n{\n\n    int i, j, out_i;\n\n    double matrix[NUM_NAMED_CHANNELS][NUM_NAMED_CHANNELS]={{0}};\n\n    int64_t unaccounted, in_ch_layout, out_ch_layout;\n\n    double maxcoef=0;\n\n    char buf[128];\n\n    const int matrix_encoding = s->matrix_encoding;\n\n    float maxval;\n\n\n\n    in_ch_layout = clean_layout(s, s->in_ch_layout);\n\n    out_ch_layout = clean_layout(s, s->out_ch_layout);\n\n\n\n    if(   out_ch_layout == AV_CH_LAYOUT_STEREO_DOWNMIX\n\n       && (in_ch_layout & AV_CH_LAYOUT_STEREO_DOWNMIX) == 0\n\n    )\n\n        out_ch_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n    if(    in_ch_layout == AV_CH_LAYOUT_STEREO_DOWNMIX\n\n       && (out_ch_layout & AV_CH_LAYOUT_STEREO_DOWNMIX) == 0\n\n    )\n\n        in_ch_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n    if(!sane_layout(in_ch_layout)){\n\n        av_get_channel_layout_string(buf, sizeof(buf), -1, s->in_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Input channel layout '%s' is not supported\\n\", buf);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(!sane_layout(out_ch_layout)){\n\n        av_get_channel_layout_string(buf, sizeof(buf), -1, s->out_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Output channel layout '%s' is not supported\\n\", buf);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    memset(s->matrix, 0, sizeof(s->matrix));\n\n    for(i=0; i<FF_ARRAY_ELEMS(matrix); i++){\n\n        if(in_ch_layout & out_ch_layout & (1ULL<<i))\n\n            matrix[i][i]= 1.0;\n\n    }\n\n\n\n    unaccounted= in_ch_layout & ~out_ch_layout;\n\n\n\n\/\/FIXME implement dolby surround\n\n\/\/FIXME implement full ac3\n\n\n\n\n\n    if(unaccounted & AV_CH_FRONT_CENTER){\n\n        if((out_ch_layout & AV_CH_LAYOUT_STEREO) == AV_CH_LAYOUT_STEREO){\n\n            if(in_ch_layout & AV_CH_LAYOUT_STEREO) {\n\n                matrix[ FRONT_LEFT][FRONT_CENTER]+= s->clev;\n\n                matrix[FRONT_RIGHT][FRONT_CENTER]+= s->clev;\n\n            } else {\n\n                matrix[ FRONT_LEFT][FRONT_CENTER]+= M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][FRONT_CENTER]+= M_SQRT1_2;\n\n            }\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n    if(unaccounted & AV_CH_LAYOUT_STEREO){\n\n        if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[FRONT_CENTER][ FRONT_LEFT]+= M_SQRT1_2;\n\n            matrix[FRONT_CENTER][FRONT_RIGHT]+= M_SQRT1_2;\n\n            if(in_ch_layout & AV_CH_FRONT_CENTER)\n\n                matrix[FRONT_CENTER][ FRONT_CENTER] = s->clev*sqrt(2);\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n\n\n    if(unaccounted & AV_CH_BACK_CENTER){\n\n        if(out_ch_layout & AV_CH_BACK_LEFT){\n\n            matrix[ BACK_LEFT][BACK_CENTER]+= M_SQRT1_2;\n\n            matrix[BACK_RIGHT][BACK_CENTER]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_SIDE_LEFT){\n\n            matrix[ SIDE_LEFT][BACK_CENTER]+= M_SQRT1_2;\n\n            matrix[SIDE_RIGHT][BACK_CENTER]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            if (matrix_encoding == AV_MATRIX_ENCODING_DOLBY ||\n\n                matrix_encoding == AV_MATRIX_ENCODING_DPLII) {\n\n                if (unaccounted & (AV_CH_BACK_LEFT | AV_CH_SIDE_LEFT)) {\n\n                    matrix[FRONT_LEFT ][BACK_CENTER] -= s->slev * M_SQRT1_2;\n\n                    matrix[FRONT_RIGHT][BACK_CENTER] += s->slev * M_SQRT1_2;\n\n                } else {\n\n                    matrix[FRONT_LEFT ][BACK_CENTER] -= s->slev;\n\n                    matrix[FRONT_RIGHT][BACK_CENTER] += s->slev;\n\n                }\n\n            } else {\n\n                matrix[ FRONT_LEFT][BACK_CENTER]+= s->slev*M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_CENTER]+= s->slev*M_SQRT1_2;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][BACK_CENTER]+= s->slev*M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n    if(unaccounted & AV_CH_BACK_LEFT){\n\n        if(out_ch_layout & AV_CH_BACK_CENTER){\n\n            matrix[BACK_CENTER][ BACK_LEFT]+= M_SQRT1_2;\n\n            matrix[BACK_CENTER][BACK_RIGHT]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_SIDE_LEFT){\n\n            if(in_ch_layout & AV_CH_SIDE_LEFT){\n\n                matrix[ SIDE_LEFT][ BACK_LEFT]+= M_SQRT1_2;\n\n                matrix[SIDE_RIGHT][BACK_RIGHT]+= M_SQRT1_2;\n\n            }else{\n\n            matrix[ SIDE_LEFT][ BACK_LEFT]+= 1.0;\n\n            matrix[SIDE_RIGHT][BACK_RIGHT]+= 1.0;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            if (matrix_encoding == AV_MATRIX_ENCODING_DOLBY) {\n\n                matrix[FRONT_LEFT ][BACK_LEFT ] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_LEFT ][BACK_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_RIGHT] += s->slev * M_SQRT1_2;\n\n            } else if (matrix_encoding == AV_MATRIX_ENCODING_DPLII) {\n\n                matrix[FRONT_LEFT ][BACK_LEFT ] -= s->slev * SQRT3_2;\n\n                matrix[FRONT_LEFT ][BACK_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_RIGHT] += s->slev * SQRT3_2;\n\n            } else {\n\n                matrix[ FRONT_LEFT][ BACK_LEFT] += s->slev;\n\n                matrix[FRONT_RIGHT][BACK_RIGHT] += s->slev;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][BACK_LEFT ]+= s->slev*M_SQRT1_2;\n\n            matrix[ FRONT_CENTER][BACK_RIGHT]+= s->slev*M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n\n\n    if(unaccounted & AV_CH_SIDE_LEFT){\n\n        if(out_ch_layout & AV_CH_BACK_LEFT){\n\n            \/* if back channels do not exist in the input, just copy side\n\n               channels to back channels, otherwise mix side into back *\/\n\n            if (in_ch_layout & AV_CH_BACK_LEFT) {\n\n                matrix[BACK_LEFT ][SIDE_LEFT ] += M_SQRT1_2;\n\n                matrix[BACK_RIGHT][SIDE_RIGHT] += M_SQRT1_2;\n\n            } else {\n\n                matrix[BACK_LEFT ][SIDE_LEFT ] += 1.0;\n\n                matrix[BACK_RIGHT][SIDE_RIGHT] += 1.0;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_BACK_CENTER){\n\n            matrix[BACK_CENTER][ SIDE_LEFT]+= M_SQRT1_2;\n\n            matrix[BACK_CENTER][SIDE_RIGHT]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            if (matrix_encoding == AV_MATRIX_ENCODING_DOLBY) {\n\n                matrix[FRONT_LEFT ][SIDE_LEFT ] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_LEFT ][SIDE_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_RIGHT] += s->slev * M_SQRT1_2;\n\n            } else if (matrix_encoding == AV_MATRIX_ENCODING_DPLII) {\n\n                matrix[FRONT_LEFT ][SIDE_LEFT ] -= s->slev * SQRT3_2;\n\n                matrix[FRONT_LEFT ][SIDE_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_RIGHT] += s->slev * SQRT3_2;\n\n            } else {\n\n                matrix[ FRONT_LEFT][ SIDE_LEFT] += s->slev;\n\n                matrix[FRONT_RIGHT][SIDE_RIGHT] += s->slev;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][SIDE_LEFT ]+= s->slev*M_SQRT1_2;\n\n            matrix[ FRONT_CENTER][SIDE_RIGHT]+= s->slev*M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n\n\n    if(unaccounted & AV_CH_FRONT_LEFT_OF_CENTER){\n\n        if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            matrix[ FRONT_LEFT][ FRONT_LEFT_OF_CENTER]+= 1.0;\n\n            matrix[FRONT_RIGHT][FRONT_RIGHT_OF_CENTER]+= 1.0;\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][ FRONT_LEFT_OF_CENTER]+= M_SQRT1_2;\n\n            matrix[ FRONT_CENTER][FRONT_RIGHT_OF_CENTER]+= M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n    \/* mix LFE into front left\/right or center *\/\n\n    if (unaccounted & AV_CH_LOW_FREQUENCY) {\n\n        if (out_ch_layout & AV_CH_FRONT_CENTER) {\n\n            matrix[FRONT_CENTER][LOW_FREQUENCY] += s->lfe_mix_level;\n\n        } else if (out_ch_layout & AV_CH_FRONT_LEFT) {\n\n            matrix[FRONT_LEFT ][LOW_FREQUENCY] += s->lfe_mix_level * M_SQRT1_2;\n\n            matrix[FRONT_RIGHT][LOW_FREQUENCY] += s->lfe_mix_level * M_SQRT1_2;\n\n        } else\n\n            av_assert0(0);\n\n    }\n\n\n\n    for(out_i=i=0; i<64; i++){\n\n        double sum=0;\n\n        int in_i=0;\n\n        for(j=0; j<64; j++){\n\n            if (i < FF_ARRAY_ELEMS(matrix) && j < FF_ARRAY_ELEMS(matrix[0]))\n\n                s->matrix[out_i][in_i]= matrix[i][j];\n\n            else\n\n                s->matrix[out_i][in_i]= i == j && (in_ch_layout & out_ch_layout & (1ULL<<i));\n\n            sum += fabs(s->matrix[out_i][in_i]);\n\n            if(in_ch_layout & (1ULL<<j))\n\n                in_i++;\n\n        }\n\n        maxcoef= FFMAX(maxcoef, sum);\n\n        if(out_ch_layout & (1ULL<<i))\n\n            out_i++;\n\n    }\n\n    if(s->rematrix_volume  < 0)\n\n        maxcoef = -s->rematrix_volume;\n\n\n\n    if (s->rematrix_maxval > 0) {\n\n        maxval = s->rematrix_maxval;\n\n    } else if (   av_get_packed_sample_fmt(s->out_sample_fmt) < AV_SAMPLE_FMT_FLT\n\n               || av_get_packed_sample_fmt(s->int_sample_fmt) < AV_SAMPLE_FMT_FLT) {\n\n        maxval = 1.0;\n\n    } else\n\n        maxval = INT_MAX;\n\n\n\n    if(maxcoef > maxval || s->rematrix_volume  < 0){\n\n        maxcoef \/= maxval;\n\n        for(i=0; i<SWR_CH_MAX; i++)\n\n            for(j=0; j<SWR_CH_MAX; j++){\n\n                s->matrix[i][j] \/= maxcoef;\n\n            }\n\n    }\n\n\n\n    if(s->rematrix_volume > 0){\n\n        for(i=0; i<SWR_CH_MAX; i++)\n\n            for(j=0; j<SWR_CH_MAX; j++){\n\n                s->matrix[i][j] *= s->rematrix_volume;\n\n            }\n\n    }\n\n\n\n    for(i=0; i<av_get_channel_layout_nb_channels(out_ch_layout); i++){\n\n        for(j=0; j<av_get_channel_layout_nb_channels(in_ch_layout); j++){\n\n            av_log(NULL, AV_LOG_DEBUG, \"%f \", s->matrix[i][j]);\n\n        }\n\n        av_log(NULL, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n    return 0;\n\n}\n","idx":7634,"target":1}
{"code":"av_cold int swri_rematrix_init(SwrContext *s){\n\n    int i, j;\n\n    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);\n\n    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    s->mix_any_f = NULL;\n\n\n\n    if (!s->rematrix_custom) {\n\n        int r = auto_matrix(s);\n\n        if (r)\n\n            return r;\n\n    }\n\n    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++) {\n\n            double rem = 0;\n\n\n\n            for (j = 0; j < nb_in; j++) {\n\n                double target = s->matrix[i][j] * 32768 + rem;\n\n                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);\n\n                rem += target - ((int*)s->native_matrix)[i * nb_in + j];\n\n            }\n\n        }\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));\n\n        s->native_one    = av_mallocz(sizeof(float));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((float*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(double));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((double*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n\n        \/\/ Only for dithering currently\n\n\/\/         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_one)\n\n            return AVERROR(ENOMEM);\n\n\/\/         for (i = 0; i < nb_out; i++)\n\n\/\/             for (j = 0; j < nb_in; j++)\n\n\/\/                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);\n\n    }else\n\n        av_assert0(0);\n\n    \/\/FIXME quantize for integeres\n\n    for (i = 0; i < SWR_CH_MAX; i++) {\n\n        int ch_in=0;\n\n        for (j = 0; j < SWR_CH_MAX; j++) {\n\n            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);\n\n            if(s->matrix[i][j])\n\n                s->matrix_ch[i][++ch_in]= j;\n\n        }\n\n        s->matrix_ch[i][0]= ch_in;\n\n    }\n\n\n\n    if(HAVE_YASM && HAVE_MMX)\n\n        return swri_rematrix_init_x86(s);\n\n\n\n    return 0;\n\n}\n","idx":1998,"target":1}
{"code":"hstore_from_arrays(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tDatum\t   *value_datums;\n\tbool\t   *value_nulls;\n\tint\t\t\tvalue_count;\n\tArrayType  *key_array;\n\tArrayType  *value_array;\n\tint\t\t\ti;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tkey_array = PG_GETARG_ARRAYTYPE_P(0);\n\n\tAssert(ARR_ELEMTYPE(key_array) == TEXTOID);\n\n\t\/*\n\t * must check >1 rather than != 1 because empty arrays have 0 dimensions,\n\t * not 1\n\t *\/\n\n\tif (ARR_NDIM(key_array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tdeconstruct_array(key_array,\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n \t\/* value_array might be NULL *\/\n \n \tif (PG_ARGISNULL(1))\n\t{\n\t\tvalue_array = NULL;\n\t\tvalue_count = key_count;\n\t\tvalue_datums = NULL;\n\t\tvalue_nulls = NULL;\n\t}\n\telse\n\t{\n\t\tvalue_array = PG_GETARG_ARRAYTYPE_P(1);\n\n\t\tAssert(ARR_ELEMTYPE(value_array) == TEXTOID);\n\n\t\tif (ARR_NDIM(value_array) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t\tif ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&\n\t\t\t(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||\n\t\t\t ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||\n\t\t\t ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"arrays must have same bounds\")));\n\n\t\tdeconstruct_array(value_array,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &value_datums, &value_nulls, &value_count);\n\n\t\tAssert(key_count == value_count);\n\t}\n\n\tpairs = palloc(key_count * sizeof(Pairs));\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (!value_nulls || value_nulls[i])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = VARDATA_ANY(value_datums[i]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(value_datums[i]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tkey_count = hstoreUniquePairs(pairs, key_count, &buflen);\n\n\tout = hstorePairs(pairs, key_count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n","idx":179569,"target":1}
{"code":"static void xvid_idct_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n\n{\n\n    ff_xvid_idct(block);\n\n    ff_put_pixels_clamped(block, dest, line_size);\n\n}\n","idx":22532,"target":1}
{"code":"static void destroy_buffers(SANMVideoContext *ctx)\n\n{\n\n    av_freep(&ctx->frm0);\n\n    av_freep(&ctx->frm1);\n\n    av_freep(&ctx->frm2);\n\n    av_freep(&ctx->stored_frame);\n\n    av_freep(&ctx->rle_buf);\n\n    ctx->frm0_size =\n\n    ctx->frm1_size =\n\n    ctx->frm2_size = 0;\n\n\n}","idx":615,"target":1}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    HQDN3DContext *s = inlink->dst->priv;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    int i;\n    s->hsub  = desc->log2_chroma_w;\n    s->vsub  = desc->log2_chroma_h;\n    s->depth = desc->comp[0].depth_minus1+1;\n    s->line = av_malloc(inlink->w * sizeof(*s->line));\n    if (!s->line)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < 4; i++) {\n        s->coefs[i] = precalc_coefs(s->strength[i], s->depth);\n        if (!s->coefs[i])\n            return AVERROR(ENOMEM);\n    }\n    if (ARCH_X86)\n        ff_hqdn3d_init_x86(s);\n    return 0;\n}","idx":8195,"target":1}
{"code":"int kvm_arch_init(KVMState *s)\n\n{\n\n    uint64_t identity_base = 0xfffbc000;\n\n    int ret;\n\n    struct utsname utsname;\n\n\n\n    ret = kvm_get_supported_msrs(s);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    uname(&utsname);\n\n    lm_capable_kernel = strcmp(utsname.machine, \"x86_64\") == 0;\n\n\n\n    \/*\n\n     * On older Intel CPUs, KVM uses vm86 mode to emulate 16-bit code directly.\n\n     * In order to use vm86 mode, an EPT identity map and a TSS  are needed.\n\n     * Since these must be part of guest physical memory, we need to allocate\n\n     * them, both by setting their start addresses in the kernel and by\n\n     * creating a corresponding e820 entry. We need 4 pages before the BIOS.\n\n     *\n\n     * Older KVM versions may not support setting the identity map base. In\n\n     * that case we need to stick with the default, i.e. a 256K maximum BIOS\n\n     * size.\n\n     *\/\n\n#ifdef KVM_CAP_SET_IDENTITY_MAP_ADDR\n\n    if (kvm_check_extension(s, KVM_CAP_SET_IDENTITY_MAP_ADDR)) {\n\n        \/* Allows up to 16M BIOSes. *\/\n\n        identity_base = 0xfeffc000;\n\n\n\n        ret = kvm_vm_ioctl(s, KVM_SET_IDENTITY_MAP_ADDR, &identity_base);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    \/* Set TSS base one page after EPT identity map. *\/\n\n    ret = kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, identity_base + 0x1000);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Tell fw_cfg to notify the BIOS to reserve the range. *\/\n\n    ret = e820_add_entry(identity_base, 0x4000, E820_RESERVED);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"e820_add_entry() table is full\\n\");\n\n        return ret;\n\n    }\n\n\n\n\n    return 0;\n\n}","idx":8772,"target":1}
{"code":"void hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict)\n\n{\n\n    Error *err = NULL;\n\n\n\n    qmp_block_set_io_throttle(qdict_get_str(qdict, \"device\"),\n\n                              qdict_get_int(qdict, \"bps\"),\n\n                              qdict_get_int(qdict, \"bps_rd\"),\n\n                              qdict_get_int(qdict, \"bps_wr\"),\n\n                              qdict_get_int(qdict, \"iops\"),\n\n                              qdict_get_int(qdict, \"iops_rd\"),\n\n                              qdict_get_int(qdict, \"iops_wr\"), &err);\n\n    hmp_handle_error(mon, &err);\n\n}\n","idx":5533,"target":1}
{"code":"MigrationState *tcp_start_outgoing_migration(Monitor *mon,\n\n                                             const char *host_port,\n\n                                             int64_t bandwidth_limit,\n\n                                             int detach,\n\n\t\t\t\t\t     int blk,\n\n\t\t\t\t\t     int inc)\n\n{\n\n    struct sockaddr_in addr;\n\n    FdMigrationState *s;\n\n    int ret;\n\n\n\n    if (parse_host_port(&addr, host_port) < 0)\n\n        return NULL;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->mig_state.blk = blk;\n\n    s->mig_state.shared = inc;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->mon = NULL;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n    s->fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (s->fd == -1) {\n\n        qemu_free(s);\n\n        return NULL;\n\n    }\n\n\n\n    socket_set_nonblock(s->fd);\n\n\n\n    if (!detach) {\n\n        migrate_fd_monitor_suspend(s, mon);\n\n    }\n\n\n\n    do {\n\n        ret = connect(s->fd, (struct sockaddr *)&addr, sizeof(addr));\n\n        if (ret == -1)\n\n            ret = -(s->get_error(s));\n\n\n\n        if (ret == -EINPROGRESS || ret == -EWOULDBLOCK)\n\n            qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0 && ret != -EINPROGRESS && ret != -EWOULDBLOCK) {\n\n        dprintf(\"connect failed\\n\");\n\n        close(s->fd);\n\n        qemu_free(s);\n\n        return NULL;\n\n    } else if (ret >= 0)\n\n        migrate_fd_connect(s);\n\n\n\n    return &s->mig_state;\n\n}\n","idx":13607,"target":1}
{"code":"PP_Flash_Menu* ReadMenu(int depth,\n                        const IPC::Message* m,\n                        PickleIterator* iter) {\n  if (depth > kMaxMenuDepth)\n    return NULL;\n  ++depth;\n\n  PP_Flash_Menu* menu = new PP_Flash_Menu;\n  menu->items = NULL;\n\n  if (!m->ReadUInt32(iter, &menu->count)) {\n    FreeMenu(menu);\n    return NULL;\n  }\n\n   if (menu->count == 0)\n     return menu;\n \n   menu->items = new PP_Flash_MenuItem[menu->count];\n   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);\n   for (uint32_t i = 0; i < menu->count; ++i) {\n    if (!ReadMenuItem(depth, m, iter, menu->items + i)) {\n      FreeMenu(menu);\n      return NULL;\n    }\n  }\n  return menu;\n}\n","idx":185099,"target":1}
{"code":"static int decode_blocks(SnowContext *s){\n\n    int x, y;\n\n    int w= s->b_width;\n\n    int h= s->b_height;\n\n    int res;\n\n\n\n    for(y=0; y<h; y++){\n\n        for(x=0; x<w; x++){\n\n\n\n            if ((res = decode_q_branch(s, 0, x, y)) < 0)\n\n                return res;\n\n        }\n\n    }\n\n    return 0;\n\n}","idx":5360,"target":1}
{"code":"void helper_divl_EAX_T0(void)\n\n{\n\n    unsigned int den, q, r;\n\n    uint64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = div32(&q, num, den);\n\n#else\n\n    q = (num \/ den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n","idx":13902,"target":1}
{"code":"void ff_celt_quant_bands(CeltFrame *f, OpusRangeCoder *rc)\n\n{\n\n    float lowband_scratch[8 * 22];\n\n    float norm1[2 * 8 * 100];\n\n    float *norm2 = norm1 + 8 * 100;\n\n\n\n    int totalbits = (f->framebits << 3) - f->anticollapse_needed;\n\n\n\n    int update_lowband = 1;\n\n    int lowband_offset = 0;\n\n\n\n    int i, j;\n\n\n\n    for (i = f->start_band; i < f->end_band; i++) {\n\n        uint32_t cm[2] = { (1 << f->blocks) - 1, (1 << f->blocks) - 1 };\n\n        int band_offset = ff_celt_freq_bands[i] << f->size;\n\n        int band_size   = ff_celt_freq_range[i] << f->size;\n\n        float *X = f->block[0].coeffs + band_offset;\n\n        float *Y = (f->channels == 2) ? f->block[1].coeffs + band_offset : NULL;\n\n        float *norm_loc1, *norm_loc2;\n\n\n\n        int consumed = opus_rc_tell_frac(rc);\n\n        int effective_lowband = -1;\n\n        int b = 0;\n\n\n\n        \/* Compute how many bits we want to allocate to this band *\/\n\n        if (i != f->start_band)\n\n            f->remaining -= consumed;\n\n        f->remaining2 = totalbits - consumed - 1;\n\n        if (i <= f->coded_bands - 1) {\n\n            int curr_balance = f->remaining \/ FFMIN(3, f->coded_bands-i);\n\n            b = av_clip_uintp2(FFMIN(f->remaining2 + 1, f->pulses[i] + curr_balance), 14);\n\n        }\n\n\n\n        if ((ff_celt_freq_bands[i] - ff_celt_freq_range[i] >= ff_celt_freq_bands[f->start_band] ||\n\n            i == f->start_band + 1) && (update_lowband || lowband_offset == 0))\n\n            lowband_offset = i;\n\n\n\n        if (i == f->start_band + 1) {\n\n            \/* Special Hybrid Folding (RFC 8251 section 9). Copy the first band into\n\n            the second to ensure the second band never has to use the LCG. *\/\n\n            int offset = 8 * ff_celt_freq_bands[i];\n\n            int count = 8 * (ff_celt_freq_range[i] - ff_celt_freq_range[i-1]);\n\n\n\n            memcpy(&norm1[offset], &norm1[offset - count], count * sizeof(float));\n\n\n\n            if (f->channels == 2)\n\n                memcpy(&norm2[offset], &norm2[offset - count], count * sizeof(float));\n\n        }\n\n\n\n        \/* Get a conservative estimate of the collapse_mask's for the bands we're\n\n           going to be folding from. *\/\n\n        if (lowband_offset != 0 && (f->spread != CELT_SPREAD_AGGRESSIVE ||\n\n                                    f->blocks > 1 || f->tf_change[i] < 0)) {\n\n            int foldstart, foldend;\n\n\n\n            \/* This ensures we never repeat spectral content within one band *\/\n\n            effective_lowband = FFMAX(ff_celt_freq_bands[f->start_band],\n\n                                      ff_celt_freq_bands[lowband_offset] - ff_celt_freq_range[i]);\n\n            foldstart = lowband_offset;\n\n            while (ff_celt_freq_bands[--foldstart] > effective_lowband);\n\n            foldend = lowband_offset - 1;\n\n            while (++foldend < i && ff_celt_freq_bands[foldend] < effective_lowband + ff_celt_freq_range[i]);\n\n\n\n            cm[0] = cm[1] = 0;\n\n            for (j = foldstart; j < foldend; j++) {\n\n                cm[0] |= f->block[0].collapse_masks[j];\n\n                cm[1] |= f->block[f->channels - 1].collapse_masks[j];\n\n            }\n\n        }\n\n\n\n        if (f->dual_stereo && i == f->intensity_stereo) {\n\n            \/* Switch off dual stereo to do intensity *\/\n\n            f->dual_stereo = 0;\n\n            for (j = ff_celt_freq_bands[f->start_band] << f->size; j < band_offset; j++)\n\n                norm1[j] = (norm1[j] + norm2[j]) \/ 2;\n\n        }\n\n\n\n        norm_loc1 = effective_lowband != -1 ? norm1 + (effective_lowband << f->size) : NULL;\n\n        norm_loc2 = effective_lowband != -1 ? norm2 + (effective_lowband << f->size) : NULL;\n\n\n\n        if (f->dual_stereo) {\n\n            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X, NULL, band_size, b >> 1,\n\n                                       f->blocks, norm_loc1, f->size,\n\n                                       norm1 + band_offset, 0, 1.0f,\n\n                                       lowband_scratch, cm[0]);\n\n\n\n            cm[1] = f->pvq->quant_band(f->pvq, f, rc, i, Y, NULL, band_size, b >> 1,\n\n                                       f->blocks, norm_loc2, f->size,\n\n                                       norm2 + band_offset, 0, 1.0f,\n\n                                       lowband_scratch, cm[1]);\n\n        } else {\n\n            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X,    Y, band_size, b >> 0,\n\n                                       f->blocks, norm_loc1, f->size,\n\n                                       norm1 + band_offset, 0, 1.0f,\n\n                                       lowband_scratch, cm[0] | cm[1]);\n\n            cm[1] = cm[0];\n\n        }\n\n\n\n        f->block[0].collapse_masks[i]               = (uint8_t)cm[0];\n\n        f->block[f->channels - 1].collapse_masks[i] = (uint8_t)cm[1];\n\n        f->remaining += f->pulses[i] + consumed;\n\n\n\n        \/* Update the folding position only as long as we have 1 bit\/sample depth *\/\n\n        update_lowband = (b > band_size << 3);\n\n    }\n\n}\n","idx":11106,"target":1}
{"code":"static int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length, AVFrame *p)\n\n{\n\n    int ret;\n\n    size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n\n\n\n    if (!(s->state & PNG_IHDR)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"IDAT without IHDR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!(s->state & PNG_IDAT)) {\n\n        \/* init image info *\/\n\n        avctx->width  = s->width;\n\n        avctx->height = s->height;\n\n\n\n        s->channels       = ff_png_get_nb_channels(s->color_type);\n\n        s->bits_per_pixel = s->bit_depth * s->channels;\n\n        s->bpp            = (s->bits_per_pixel + 7) >> 3;\n\n        s->row_size       = (s->cur_w * s->bits_per_pixel + 7) >> 3;\n\n\n\n        if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n\n            avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n\n            avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB48BE;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n\n        } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n        } else if (s->bit_depth == 1 && s->bits_per_pixel == 1 && avctx->codec_id != AV_CODEC_ID_APNG) {\n\n            avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n\n        } else if (s->bit_depth == 8 &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_YA8;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n\n        } else {\n\n            av_log(avctx, AV_LOG_ERROR, \"unsupported bit depth %d \"\n\n                    \"and color type %d\\n\",\n\n                    s->bit_depth, s->color_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n\n            switch (avctx->pix_fmt) {\n\n            case AV_PIX_FMT_RGB24:\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n                break;\n\n\n\n            case AV_PIX_FMT_RGB48BE:\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n\n                break;\n\n\n\n            case AV_PIX_FMT_GRAY8:\n\n                avctx->pix_fmt = AV_PIX_FMT_YA8;\n\n                break;\n\n\n\n            case AV_PIX_FMT_GRAY16BE:\n\n                avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n\n                break;\n\n\n\n            default:\n\n                avpriv_request_sample(avctx, \"bit depth %d \"\n\n                        \"and color type %d with TRNS\",\n\n                        s->bit_depth, s->color_type);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            s->bpp += byte_depth;\n\n        }\n\n\n\n        if ((ret = ff_thread_get_buffer(avctx, &s->picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n            return ret;\n\n        if (avctx->codec_id == AV_CODEC_ID_APNG && s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n            ff_thread_release_buffer(avctx, &s->previous_picture);\n\n            if ((ret = ff_thread_get_buffer(avctx, &s->previous_picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n                return ret;\n\n        }\n\n        ff_thread_finish_setup(avctx);\n\n\n\n        p->pict_type        = AV_PICTURE_TYPE_I;\n\n        p->key_frame        = 1;\n\n        p->interlaced_frame = !!s->interlace_type;\n\n\n\n        \/* compute the compressed row size *\/\n\n        if (!s->interlace_type) {\n\n            s->crow_size = s->row_size + 1;\n\n        } else {\n\n            s->pass          = 0;\n\n            s->pass_row_size = ff_png_pass_row_size(s->pass,\n\n                    s->bits_per_pixel,\n\n                    s->cur_w);\n\n            s->crow_size = s->pass_row_size + 1;\n\n        }\n\n        ff_dlog(avctx, \"row_size=%d crow_size =%d\\n\",\n\n                s->row_size, s->crow_size);\n\n        s->image_buf      = p->data[0];\n\n        s->image_linesize = p->linesize[0];\n\n        \/* copy the palette if needed *\/\n\n        if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n\n            memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n\n        \/* empty row is used if differencing to the first row *\/\n\n        av_fast_padded_mallocz(&s->last_row, &s->last_row_size, s->row_size);\n\n        if (!s->last_row)\n\n            return AVERROR_INVALIDDATA;\n\n        if (s->interlace_type ||\n\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n\n            av_fast_padded_malloc(&s->tmp_row, &s->tmp_row_size, s->row_size);\n\n            if (!s->tmp_row)\n\n                return AVERROR_INVALIDDATA;\n\n        }\n\n        \/* compressed row *\/\n\n        av_fast_padded_malloc(&s->buffer, &s->buffer_size, s->row_size + 16);\n\n        if (!s->buffer)\n\n            return AVERROR(ENOMEM);\n\n\n\n        \/* we want crow_buf+1 to be 16-byte aligned *\/\n\n        s->crow_buf          = s->buffer + 15;\n\n        s->zstream.avail_out = s->crow_size;\n\n        s->zstream.next_out  = s->crow_buf;\n\n    }\n\n\n\n    s->state |= PNG_IDAT;\n\n\n\n    \/* set image to non-transparent bpp while decompressing *\/\n\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n\n        s->bpp -= byte_depth;\n\n\n\n    ret = png_decode_idat(s, length);\n\n\n\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n\n        s->bpp += byte_depth;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    bytestream2_skip(&s->gb, 4); \/* crc *\/\n\n\n\n    return 0;\n\n}\n","idx":11243,"target":1}
{"code":"BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\n\t{\n\t\/* k = SHA1(PAD(A) || PAD(B) ) -- tls-srp draft 8 *\/\n\n\tBIGNUM *u;\t\n\tunsigned char cu[SHA_DIGEST_LENGTH];\n\tunsigned char *cAB;\n\tEVP_MD_CTX ctxt;\n\tint longN;  \n\tif ((A == NULL) ||(B == NULL) || (N == NULL))\n\t\treturn NULL;\n\n        if ((A == NULL) ||(B == NULL) || (N == NULL))\n                return NULL;\n \n        longN= BN_num_bytes(N);\n \n        if ((cAB = OPENSSL_malloc(2*longN)) == NULL) \n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);\n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);\n\tOPENSSL_free(cAB);\n\tEVP_DigestFinal_ex(&ctxt, cu, NULL);\n\tEVP_MD_CTX_cleanup(&ctxt);\n\n\tif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\n\t\treturn NULL;\n\tif (!BN_is_zero(u))\n\t\treturn u;\n\tBN_free(u);\n\treturn NULL;\n}\n","idx":178344,"target":1}
{"code":"static int gdb_handle_packet(GDBState *s, const char *line_buf)\n\n{\n\n    CPUArchState *env;\n\n    const char *p;\n\n    uint32_t thread;\n\n    int ch, reg_size, type, res;\n\n    char buf[MAX_PACKET_LENGTH];\n\n    uint8_t mem_buf[MAX_PACKET_LENGTH];\n\n    uint8_t *registers;\n\n    target_ulong addr, len;\n\n\n\n#ifdef DEBUG_GDB\n\n    printf(\"command='%s'\\n\", line_buf);\n\n#endif\n\n    p = line_buf;\n\n    ch = *p++;\n\n    switch(ch) {\n\n    case '?':\n\n        \/* TODO: Make this return the correct value for user-mode.  *\/\n\n        snprintf(buf, sizeof(buf), \"T%02xthread:%02x;\", GDB_SIGNAL_TRAP,\n\n                 cpu_index(ENV_GET_CPU(s->c_cpu)));\n\n        put_packet(s, buf);\n\n        \/* Remove all the breakpoints when this query is issued,\n\n         * because gdb is doing and initial connect and the state\n\n         * should be cleaned up.\n\n         *\/\n\n        gdb_breakpoint_remove_all();\n\n        break;\n\n    case 'c':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        s->signal = 0;\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'C':\n\n        s->signal = gdb_signal_to_target (strtoul(p, (char **)&p, 16));\n\n        if (s->signal == -1)\n\n            s->signal = 0;\n\n        gdb_continue(s);\n\n        return RS_IDLE;\n\n    case 'v':\n\n        if (strncmp(p, \"Cont\", 4) == 0) {\n\n            int res_signal, res_thread;\n\n\n\n            p += 4;\n\n            if (*p == '?') {\n\n                put_packet(s, \"vCont;c;C;s;S\");\n\n                break;\n\n            }\n\n            res = 0;\n\n            res_signal = 0;\n\n            res_thread = 0;\n\n            while (*p) {\n\n                int action, signal;\n\n\n\n                if (*p++ != ';') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                action = *p++;\n\n                signal = 0;\n\n                if (action == 'C' || action == 'S') {\n\n                    signal = strtoul(p, (char **)&p, 16);\n\n                } else if (action != 'c' && action != 's') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                thread = 0;\n\n                if (*p == ':') {\n\n                    thread = strtoull(p+1, (char **)&p, 16);\n\n                }\n\n                action = tolower(action);\n\n                if (res == 0 || (res == 'c' && action == 's')) {\n\n                    res = action;\n\n                    res_signal = signal;\n\n                    res_thread = thread;\n\n                }\n\n            }\n\n            if (res) {\n\n                if (res_thread != -1 && res_thread != 0) {\n\n                    env = find_cpu(res_thread);\n\n                    if (env == NULL) {\n\n                        put_packet(s, \"E22\");\n\n                        break;\n\n                    }\n\n                    s->c_cpu = env;\n\n                }\n\n                if (res == 's') {\n\n                    cpu_single_step(s->c_cpu, sstep_flags);\n\n                }\n\n                s->signal = res_signal;\n\n                gdb_continue(s);\n\n                return RS_IDLE;\n\n            }\n\n            break;\n\n        } else {\n\n            goto unknown_command;\n\n        }\n\n    case 'k':\n\n#ifdef CONFIG_USER_ONLY\n\n        \/* Kill the target *\/\n\n        fprintf(stderr, \"\\nQEMU: Terminated via GDBstub\\n\");\n\n        exit(0);\n\n#endif\n\n    case 'D':\n\n        \/* Detach packet *\/\n\n        gdb_breakpoint_remove_all();\n\n        gdb_syscall_mode = GDB_SYS_DISABLED;\n\n        gdb_continue(s);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 's':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        cpu_single_step(s->c_cpu, sstep_flags);\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'F':\n\n        {\n\n            target_ulong ret;\n\n            target_ulong err;\n\n\n\n            ret = strtoull(p, (char **)&p, 16);\n\n            if (*p == ',') {\n\n                p++;\n\n                err = strtoull(p, (char **)&p, 16);\n\n            } else {\n\n                err = 0;\n\n            }\n\n            if (*p == ',')\n\n                p++;\n\n            type = *p;\n\n            if (s->current_syscall_cb) {\n\n                s->current_syscall_cb(s->c_cpu, ret, err);\n\n                s->current_syscall_cb = NULL;\n\n            }\n\n            if (type == 'C') {\n\n                put_packet(s, \"T02\");\n\n            } else {\n\n                gdb_continue(s);\n\n            }\n\n        }\n\n        break;\n\n    case 'g':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        len = 0;\n\n        for (addr = 0; addr < num_g_regs; addr++) {\n\n            reg_size = gdb_read_register(s->g_cpu, mem_buf + len, addr);\n\n            len += reg_size;\n\n        }\n\n        memtohex(buf, mem_buf, len);\n\n        put_packet(s, buf);\n\n        break;\n\n    case 'G':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        registers = mem_buf;\n\n        len = strlen(p) \/ 2;\n\n        hextomem((uint8_t *)registers, p, len);\n\n        for (addr = 0; addr < num_g_regs && len > 0; addr++) {\n\n            reg_size = gdb_write_register(s->g_cpu, registers, addr);\n\n            len -= reg_size;\n\n            registers += reg_size;\n\n        }\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'm':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, NULL, 16);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 0) != 0) {\n\n            put_packet (s, \"E14\");\n\n        } else {\n\n            memtohex(buf, mem_buf, len);\n\n            put_packet(s, buf);\n\n        }\n\n        break;\n\n    case 'M':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (*p == ':')\n\n            p++;\n\n        hextomem(mem_buf, p, len);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 1) != 0) {\n\n            put_packet(s, \"E14\");\n\n        } else {\n\n            put_packet(s, \"OK\");\n\n        }\n\n        break;\n\n    case 'p':\n\n        \/* Older gdb are really dumb, and don't use 'g' if 'p' is avaialable.\n\n           This works, but can be very slow.  Anything new enough to\n\n           understand XML also knows how to use this properly.  *\/\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        reg_size = gdb_read_register(s->g_cpu, mem_buf, addr);\n\n        if (reg_size) {\n\n            memtohex(buf, mem_buf, reg_size);\n\n            put_packet(s, buf);\n\n        } else {\n\n            put_packet(s, \"E14\");\n\n        }\n\n        break;\n\n    case 'P':\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == '=')\n\n            p++;\n\n        reg_size = strlen(p) \/ 2;\n\n        hextomem(mem_buf, p, reg_size);\n\n        gdb_write_register(s->g_cpu, mem_buf, addr);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'Z':\n\n    case 'z':\n\n        type = strtoul(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (ch == 'Z')\n\n            res = gdb_breakpoint_insert(addr, len, type);\n\n        else\n\n            res = gdb_breakpoint_remove(addr, len, type);\n\n        if (res >= 0)\n\n             put_packet(s, \"OK\");\n\n        else if (res == -ENOSYS)\n\n            put_packet(s, \"\");\n\n        else\n\n            put_packet(s, \"E22\");\n\n        break;\n\n    case 'H':\n\n        type = *p++;\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        if (thread == -1 || thread == 0) {\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n        env = find_cpu(thread);\n\n        if (env == NULL) {\n\n            put_packet(s, \"E22\");\n\n            break;\n\n        }\n\n        switch (type) {\n\n        case 'c':\n\n            s->c_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        case 'g':\n\n            s->g_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        default:\n\n             put_packet(s, \"E22\");\n\n             break;\n\n        }\n\n        break;\n\n    case 'T':\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        env = find_cpu(thread);\n\n\n\n        if (env != NULL) {\n\n            put_packet(s, \"OK\");\n\n        } else {\n\n            put_packet(s, \"E22\");\n\n        }\n\n        break;\n\n    case 'q':\n\n    case 'Q':\n\n        \/* parse any 'q' packets here *\/\n\n        if (!strcmp(p,\"qemu.sstepbits\")) {\n\n            \/* Query Breakpoint bit definitions *\/\n\n            snprintf(buf, sizeof(buf), \"ENABLE=%x,NOIRQ=%x,NOTIMER=%x\",\n\n                     SSTEP_ENABLE,\n\n                     SSTEP_NOIRQ,\n\n                     SSTEP_NOTIMER);\n\n            put_packet(s, buf);\n\n            break;\n\n        } else if (strncmp(p,\"qemu.sstep\",10) == 0) {\n\n            \/* Display or change the sstep_flags *\/\n\n            p += 10;\n\n            if (*p != '=') {\n\n                \/* Display current setting *\/\n\n                snprintf(buf, sizeof(buf), \"0x%x\", sstep_flags);\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            p++;\n\n            type = strtoul(p, (char **)&p, 16);\n\n            sstep_flags = type;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        } else if (strcmp(p,\"C\") == 0) {\n\n            \/* \"Current thread\" remains vague in the spec, so always return\n\n             *  the first CPU (gdb returns the first thread). *\/\n\n            put_packet(s, \"QC1\");\n\n            break;\n\n        } else if (strcmp(p,\"fThreadInfo\") == 0) {\n\n            s->query_cpu = first_cpu->env_ptr;\n\n            goto report_cpuinfo;\n\n        } else if (strcmp(p,\"sThreadInfo\") == 0) {\n\n        report_cpuinfo:\n\n            if (s->query_cpu) {\n\n                snprintf(buf, sizeof(buf), \"m%x\",\n\n                         cpu_index(ENV_GET_CPU(s->query_cpu)));\n\n                put_packet(s, buf);\n\n                s->query_cpu = ENV_GET_CPU(s->query_cpu)->next_cpu->env_ptr;\n\n            } else\n\n                put_packet(s, \"l\");\n\n            break;\n\n        } else if (strncmp(p,\"ThreadExtraInfo,\", 16) == 0) {\n\n            thread = strtoull(p+16, (char **)&p, 16);\n\n            env = find_cpu(thread);\n\n            if (env != NULL) {\n\n                CPUState *cpu = ENV_GET_CPU(env);\n\n                cpu_synchronize_state(cpu);\n\n                len = snprintf((char *)mem_buf, sizeof(mem_buf),\n\n                               \"CPU#%d [%s]\", cpu->cpu_index,\n\n                               cpu->halted ? \"halted \" : \"running\");\n\n                memtohex(buf, mem_buf, len);\n\n                put_packet(s, buf);\n\n            }\n\n            break;\n\n        }\n\n#ifdef CONFIG_USER_ONLY\n\n        else if (strncmp(p, \"Offsets\", 7) == 0) {\n\n            TaskState *ts = s->c_cpu->opaque;\n\n\n\n            snprintf(buf, sizeof(buf),\n\n                     \"Text=\" TARGET_ABI_FMT_lx \";Data=\" TARGET_ABI_FMT_lx\n\n                     \";Bss=\" TARGET_ABI_FMT_lx,\n\n                     ts->info->code_offset,\n\n                     ts->info->data_offset,\n\n                     ts->info->data_offset);\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#else \/* !CONFIG_USER_ONLY *\/\n\n        else if (strncmp(p, \"Rcmd,\", 5) == 0) {\n\n            int len = strlen(p + 5);\n\n\n\n            if ((len % 2) != 0) {\n\n                put_packet(s, \"E01\");\n\n                break;\n\n            }\n\n            hextomem(mem_buf, p + 5, len);\n\n            len = len \/ 2;\n\n            mem_buf[len++] = 0;\n\n            qemu_chr_be_write(s->mon_chr, mem_buf, len);\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n#endif \/* !CONFIG_USER_ONLY *\/\n\n        if (strncmp(p, \"Supported\", 9) == 0) {\n\n            snprintf(buf, sizeof(buf), \"PacketSize=%x\", MAX_PACKET_LENGTH);\n\n#ifdef GDB_CORE_XML\n\n            pstrcat(buf, sizeof(buf), \";qXfer:features:read+\");\n\n#endif\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#ifdef GDB_CORE_XML\n\n        if (strncmp(p, \"Xfer:features:read:\", 19) == 0) {\n\n            const char *xml;\n\n            target_ulong total_len;\n\n\n\n            gdb_has_xml = 1;\n\n            p += 19;\n\n            xml = get_feature_xml(p, &p);\n\n            if (!xml) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n\n\n            if (*p == ':')\n\n                p++;\n\n            addr = strtoul(p, (char **)&p, 16);\n\n            if (*p == ',')\n\n                p++;\n\n            len = strtoul(p, (char **)&p, 16);\n\n\n\n            total_len = strlen(xml);\n\n            if (addr > total_len) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            if (len > (MAX_PACKET_LENGTH - 5) \/ 2)\n\n                len = (MAX_PACKET_LENGTH - 5) \/ 2;\n\n            if (len < total_len - addr) {\n\n                buf[0] = 'm';\n\n                len = memtox(buf + 1, xml + addr, len);\n\n            } else {\n\n                buf[0] = 'l';\n\n                len = memtox(buf + 1, xml + addr, total_len - addr);\n\n            }\n\n            put_packet_binary(s, buf, len + 1);\n\n            break;\n\n        }\n\n#endif\n\n        \/* Unrecognised 'q' command.  *\/\n\n        goto unknown_command;\n\n\n\n    default:\n\n    unknown_command:\n\n        \/* put empty packet *\/\n\n        buf[0] = '\\0';\n\n        put_packet(s, buf);\n\n        break;\n\n    }\n\n    return RS_IDLE;\n\n}\n","idx":23774,"target":1}
{"code":"int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t\/*\n\t * This also sets hw\/phys segments, boundary and size\n\t *\/\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }\n","idx":182934,"target":1}
{"code":"int qcow2_alloc_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int n_start, int n_end, int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret, sectors;\n\n    uint64_t *l2_table;\n\n    unsigned int nb_clusters, keep_clusters;\n\n    uint64_t cluster_offset;\n\n\n\n    trace_qcow2_alloc_clusters_offset(qemu_coroutine_self(), offset,\n\n                                      n_start, n_end);\n\n\n\n    \/* Find L2 entry for the first involved cluster *\/\n\nagain:\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/*\n\n     * Calculate the number of clusters to look for. We stop at L2 table\n\n     * boundaries to keep things simple.\n\n     *\/\n\n    nb_clusters = MIN(size_to_clusters(s, n_end << BDRV_SECTOR_BITS),\n\n                      s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    \/*\n\n     * Check how many clusters are already allocated and don't need COW, and how\n\n     * many need a new allocation.\n\n     *\/\n\n    if (qcow2_get_cluster_type(cluster_offset) == QCOW2_CLUSTER_NORMAL\n\n        && (cluster_offset & QCOW_OFLAG_COPIED))\n\n    {\n\n        \/* We keep all QCOW_OFLAG_COPIED clusters *\/\n\n        keep_clusters =\n\n            count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                                      &l2_table[l2_index], 0,\n\n                                      QCOW_OFLAG_COPIED | QCOW_OFLAG_ZERO);\n\n        assert(keep_clusters <= nb_clusters);\n\n        nb_clusters -= keep_clusters;\n\n    } else {\n\n        \/* For the moment, overwrite compressed clusters one by one *\/\n\n        if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            nb_clusters = 1;\n\n        } else {\n\n            nb_clusters = count_cow_clusters(s, nb_clusters, l2_table, l2_index);\n\n        }\n\n\n\n        keep_clusters = 0;\n\n        cluster_offset = 0;\n\n    }\n\n\n\n    cluster_offset &= L2E_OFFSET_MASK;\n\n\n\n    \/*\n\n     * The L2 table isn't used any more after this. As long as the cache works\n\n     * synchronously, it's important to release it before calling\n\n     * do_alloc_cluster_offset, which may yield if we need to wait for another\n\n     * request to complete. If we still had the reference, we could use up the\n\n     * whole cache with sleeping requests.\n\n     *\/\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* If there is something left to allocate, do that now *\/\n\n    *m = (QCowL2Meta) {\n\n        .cluster_offset     = cluster_offset,\n\n        .nb_clusters        = 0,\n\n    };\n\n    qemu_co_queue_init(&m->dependent_requests);\n\n\n\n    if (nb_clusters > 0) {\n\n        uint64_t alloc_offset;\n\n        uint64_t alloc_cluster_offset;\n\n        uint64_t keep_bytes = keep_clusters * s->cluster_size;\n\n\n\n        \/* Calculate start and size of allocation *\/\n\n        alloc_offset = offset + keep_bytes;\n\n\n\n        if (keep_clusters == 0) {\n\n            alloc_cluster_offset = 0;\n\n        } else {\n\n            alloc_cluster_offset = cluster_offset + keep_bytes;\n\n        }\n\n\n\n        \/* Allocate, if necessary at a given offset in the image file *\/\n\n        ret = do_alloc_cluster_offset(bs, alloc_offset, &alloc_cluster_offset,\n\n                                      &nb_clusters);\n\n        if (ret == -EAGAIN) {\n\n            goto again;\n\n        } else if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        \/* save info needed for meta data update *\/\n\n        if (nb_clusters > 0) {\n\n            int requested_sectors = n_end - keep_clusters * s->cluster_sectors;\n\n            int avail_sectors = (keep_clusters + nb_clusters)\n\n                                << (s->cluster_bits - BDRV_SECTOR_BITS);\n\n\n\n            *m = (QCowL2Meta) {\n\n                .cluster_offset = keep_clusters == 0 ?\n\n                                  alloc_cluster_offset : cluster_offset,\n\n                .alloc_offset   = alloc_cluster_offset,\n\n                .offset         = alloc_offset,\n\n                .n_start        = keep_clusters == 0 ? n_start : 0,\n\n                .nb_clusters    = nb_clusters,\n\n                .nb_available   = MIN(requested_sectors, avail_sectors),\n\n            };\n\n            qemu_co_queue_init(&m->dependent_requests);\n\n            QLIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n        }\n\n    }\n\n\n\n    \/* Some cleanup work *\/\n\n    sectors = (keep_clusters + nb_clusters) << (s->cluster_bits - 9);\n\n    if (sectors > n_end) {\n\n        sectors = n_end;\n\n    }\n\n\n\n    assert(sectors > n_start);\n\n    *num = sectors - n_start;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (m->nb_clusters > 0) {\n\n        QLIST_REMOVE(m, next_in_flight);\n\n    }\n\n    return ret;\n\n}\n","idx":22580,"target":1}
{"code":"int recv_files(int f_in, int f_out, char *local_name)\n{\n\tint fd1,fd2;\n\tSTRUCT_STAT st;\n\tint iflags, xlen;\n\tchar *fname, fbuf[MAXPATHLEN];\n\tchar xname[MAXPATHLEN];\n\tchar fnametmp[MAXPATHLEN];\n\tchar *fnamecmp, *partialptr;\n\tchar fnamecmpbuf[MAXPATHLEN];\n\tuchar fnamecmp_type;\n\tstruct file_struct *file;\n\tint itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;\n\tenum logcode log_code = log_before_transfer ? FLOG : FINFO;\n\tint max_phase = protocol_version >= 29 ? 2 : 1;\n\tint dflt_perms = (ACCESSPERMS & ~orig_umask);\n#ifdef SUPPORT_ACLS\n\tconst char *parent_dirname = \"\";\n#endif\n\tint ndx, recv_ok;\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO, \"recv_files(%d) starting\\n\", cur_flist->used);\n\n\tif (delay_updates)\n\t\tdelayed_bits = bitbag_create(cur_flist->used + 1);\n\n\twhile (1) {\n\t\tcleanup_disable();\n\n\t\t\/* This call also sets cur_flist. *\/\n\t\tndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,\n\t\t\t\t\t xname, &xlen);\n\t\tif (ndx == NDX_DONE) {\n\t\t\tif (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {\n\t\t\t\tset_current_file_index(NULL, 0);\n\t\t\t\tend_progress(0);\n\t\t\t}\n\t\t\tif (inc_recurse && first_flist) {\n\t\t\t\tif (read_batch) {\n\t\t\t\t\tndx = first_flist->used + first_flist->ndx_start;\n\t\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t\t}\n\t\t\t\tflist_free(first_flist);\n\t\t\t\tif (first_flist)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (read_batch && first_flist) {\n\t\t\t\tndx = first_flist->used;\n\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t}\n\t\t\tif (++phase > max_phase)\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\t\trprintf(FINFO, \"recv_files phase=%d\\n\", phase);\n\t\t\tif (phase == 2 && delay_updates)\n\t\t\t\thandle_delayed_updates(local_name);\n\t\t\twrite_int(f_out, NDX_DONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ndx - cur_flist->ndx_start >= 0)\n\t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];\n\t\telse\n\t\t\tfile = dir_flist->files[cur_flist->parent_ndx];\n\t\tfname = local_name ? local_name : f_name(file, fbuf);\n\n\t\tif (daemon_filter_list.head\n\t\t    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {\n\t\t\trprintf(FERROR, \"attempt to hack rsync failed.\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\trprintf(FINFO, \"recv_files(%s)\\n\", fname);\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))\n\t\t\trecv_xattr_request(file, f_in);\n#endif\n\n\t\tif (!(iflags & ITEM_TRANSFER)) {\n\t\t\tmaybe_log_item(file, iflags, itemizing, xname);\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t\t && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))\n\t\t\t\tset_file_attrs(fname, file, NULL, fname, 0);\n#endif\n\t\t\tif (iflags & ITEM_IS_NEW) {\n\t\t\t\tstats.created_files++;\n\t\t\t\tif (S_ISREG(file->mode)) {\n\t\t\t\t\t\/* Nothing further to count. *\/\n\t\t\t\t} else if (S_ISDIR(file->mode))\n\t\t\t\t\tstats.created_dirs++;\n#ifdef SUPPORT_LINKS\n\t\t\t\telse if (S_ISLNK(file->mode))\n\t\t\t\t\tstats.created_symlinks++;\n#endif\n\t\t\t\telse if (IS_DEVICE(file->mode))\n\t\t\t\t\tstats.created_devices++;\n\t\t\t\telse\n\t\t\t\t\tstats.created_specials++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (phase == 2) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"got transfer request in phase 2 [%s]\\n\",\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (file->flags & FLAG_FILE_SENT) {\n\t\t\tif (csum_length == SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups; \/* prevents double backup *\/\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SUM_LENGTH;\n\t\t\t\tredoing = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (csum_length != SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups;\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SHORT_SUM_LENGTH;\n\t\t\t\tredoing = 0;\n\t\t\t}\n\t\t\tif (iflags & ITEM_IS_NEW)\n\t\t\t\tstats.created_files++;\n\t\t}\n\n\t\tif (!am_server && INFO_GTE(PROGRESS, 1))\n\t\t\tset_current_file_index(file, ndx);\n\t\tstats.xferred_files++;\n\t\tstats.total_transferred_size += F_LENGTH(file);\n\n\t\tcleanup_got_literal = 0;\n\n\t\tif (read_batch) {\n\t\t\tint wanted = redoing\n\t\t\t\t   ? we_want_redo(ndx)\n\t\t\t\t   : gen_wants_ndx(ndx, cur_flist->flist_num);\n\t\t\tif (!wanted) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"(Skipping batched update for%s \\\"%s\\\")\\n\",\n\t\t\t\t\tredoing ? \" resend of\" : \"\",\n\t\t\t\t\tfname);\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tremember_initial_stats();\n\n\t\tif (!do_xfers) { \/* log the transfer *\/\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (read_batch)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tcontinue;\n\t\t}\n\t\tif (write_batch < 0) {\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (!am_server)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpartialptr = partial_dir ? partial_dir_fname(fname) : fname;\n\n\t\tif (protocol_version >= 29) {\n\t\t\tswitch (fnamecmp_type) {\n\t\t\tcase FNAMECMP_FNAME:\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_PARTIAL_DIR:\n\t\t\t\tfnamecmp = partialptr;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_BACKUP:\n\t\t\t\tfnamecmp = get_backup_name(fname);\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_FUZZY:\n\t\t\t\tif (file->dirname) {\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);\n\t\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\t} else\n\t\t\t\t\tfnamecmp = xname;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {\n\t\t\t\t\tfnamecmp_type -= FNAMECMP_FUZZY + 1;\n\t\t\t\t\tif (file->dirname) {\n\t\t\t\t\t\tstringjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t\t\t   basis_dir[fnamecmp_type], \"\/\", file->dirname, \"\/\", xname, NULL);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);\n\t\t\t\t} else if (fnamecmp_type >= basis_dir_cnt) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"invalid basis_dir index: %d.\\n\",\n\t\t\t\t\t\tfnamecmp_type);\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t} else\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n                                break;\n                        }\n                        if (!fnamecmp || (daemon_filter_list.head\n                         && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {\n                                fnamecmp = fname;\n                                fnamecmp_type = FNAMECMP_FNAME;\n                        }\n\t\t} else {\n\t\t\t\/* Reminder: --inplace && --partial-dir are never\n\t\t\t * enabled at the same time. *\/\n\t\t\tif (inplace && make_backups > 0) {\n\t\t\t\tif (!(fnamecmp = get_backup_name(fname)))\n\t\t\t\t\tfnamecmp = fname;\n\t\t\t\telse\n\t\t\t\t\tfnamecmp_type = FNAMECMP_BACKUP;\n\t\t\t} else if (partial_dir && partialptr)\n\t\t\t\tfnamecmp = partialptr;\n\t\t\telse\n\t\t\t\tfnamecmp = fname;\n\t\t}\n\n\t\t\/* open the file *\/\n\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\n\t\tif (fd1 == -1 && protocol_version < 29) {\n\t\t\tif (fnamecmp != fname) {\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\n\t\t\tif (fd1 == -1 && basis_dir[0]) {\n\t\t\t\t\/* pre-29 allowed only one alternate basis *\/\n\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t basis_dir[0], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\t\t}\n\n\t\tupdating_basis_or_equiv = inplace\n\t\t    && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP);\n\n\t\tif (fd1 == -1) {\n\t\t\tst.st_mode = 0;\n\t\t\tst.st_size = 0;\n\t\t} else if (do_fstat(fd1,&st) != 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"fstat %s failed\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {\n\t\t\t\/* this special handling for directories\n\t\t\t * wouldn't be necessary if robust_rename()\n\t\t\t * and the underlying robust_unlink could cope\n\t\t\t * with directories\n\t\t\t *\/\n\t\t\trprintf(FERROR_XFER, \"recv_files: %s is a directory\\n\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && !S_ISREG(st.st_mode)) {\n\t\t\tclose(fd1);\n\t\t\tfd1 = -1;\n\t\t}\n\n\t\t\/* If we're not preserving permissions, change the file-list's\n\t\t * mode based on the local permissions and some heuristics. *\/\n\t\tif (!preserve_perms) {\n\t\t\tint exists = fd1 != -1;\n#ifdef SUPPORT_ACLS\n\t\t\tconst char *dn = file->dirname ? file->dirname : \".\";\n\t\t\tif (parent_dirname != dn\n\t\t\t && strcmp(parent_dirname, dn) != 0) {\n\t\t\t\tdflt_perms = default_perms_for_dir(dn);\n\t\t\t\tparent_dirname = dn;\n\t\t\t}\n#endif\n\t\t\tfile->mode = dest_mode(file->mode, st.st_mode,\n\t\t\t\t\t       dflt_perms, exists);\n\t\t}\n\n\t\t\/* We now check to see if we are writing the file \"inplace\" *\/\n\t\tif (inplace)  {\n\t\t\tfd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);\n\t\t\tif (fd2 == -1) {\n\t\t\t\trsyserr(FERROR_XFER, errno, \"open %s failed\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t} else if (updating_basis_or_equiv)\n\t\t\t\tcleanup_set(NULL, NULL, file, fd1, fd2);\n\t\t} else {\n\t\t\tfd2 = open_tmpfile(fnametmp, fname, file);\n\t\t\tif (fd2 != -1)\n\t\t\t\tcleanup_set(fnametmp, partialptr, file, fd1, fd2);\n\t\t}\n\n\t\tif (fd2 == -1) {\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (fd1 != -1)\n\t\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\/* log the transfer *\/\n\t\tif (log_before_transfer)\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\telse if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))\n\t\t\trprintf(FINFO, \"%s\\n\", fname);\n\n\t\t\/* recv file data *\/\n\t\trecv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,\n\t\t\t\t       fname, fd2, F_LENGTH(file));\n\n\t\tlog_item(log_code, file, iflags, NULL);\n\n\t\tif (fd1 != -1)\n\t\t\tclose(fd1);\n\t\tif (close(fd2) < 0) {\n\t\t\trsyserr(FERROR, errno, \"close failed on %s\",\n\t\t\t\tfull_fname(fnametmp));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\n\t\tif ((recv_ok && (!delay_updates || !partialptr)) || inplace) {\n\t\t\tif (partialptr == fname)\n\t\t\t\tpartialptr = NULL;\n\t\t\tif (!finish_transfer(fname, fnametmp, fnamecmp,\n\t\t\t\t\t     partialptr, file, recv_ok, 1))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (fnamecmp == partialptr) {\n\t\t\t\tdo_unlink(partialptr);\n\t\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);\n\t\t\t}\n\t\t} else if (keep_partial && partialptr) {\n\t\t\tif (!handle_partial_dir(partialptr, PDIR_CREATE)) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t    \"Unable to create partial-dir for %s -- discarding %s.\\n\",\n\t\t\t\t    local_name ? local_name : f_name(file, NULL),\n\t\t\t\t    recv_ok ? \"completed file\" : \"partial file\");\n\t\t\t\tdo_unlink(fnametmp);\n\t\t\t\trecv_ok = -1;\n\t\t\t} else if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,\n\t\t\t\t\t\t    file, recv_ok, !partial_dir))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (delay_updates && recv_ok) {\n\t\t\t\tbitbag_set_bit(delayed_bits, ndx);\n\t\t\t\trecv_ok = 2;\n\t\t\t} else\n\t\t\t\tpartialptr = NULL;\n\t\t} else\n\t\t\tdo_unlink(fnametmp);\n\n\t\tcleanup_disable();\n\n\t\tif (read_batch)\n\t\t\tfile->flags |= FLAG_FILE_SENT;\n\n\t\tswitch (recv_ok) {\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (remove_source_files || inc_recurse\n\t\t\t || (preserve_hard_links && F_IS_HLINKED(file)))\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tbreak;\n\t\tcase 0: {\n\t\t\tenum logcode msgtype = redoing ? FERROR_XFER : FWARNING;\n\t\t\tif (msgtype == FERROR_XFER || INFO_GTE(NAME, 1)) {\n\t\t\t\tchar *errstr, *redostr, *keptstr;\n\t\t\t\tif (!(keep_partial && partialptr) && !inplace)\n\t\t\t\t\tkeptstr = \"discarded\";\n\t\t\t\telse if (partial_dir)\n\t\t\t\t\tkeptstr = \"put into partial-dir\";\n\t\t\t\telse\n\t\t\t\t\tkeptstr = \"retained\";\n\t\t\t\tif (msgtype == FERROR_XFER) {\n\t\t\t\t\terrstr = \"ERROR\";\n\t\t\t\t\tredostr = \"\";\n\t\t\t\t} else {\n\t\t\t\t\terrstr = \"WARNING\";\n\t\t\t\t\tredostr = read_batch ? \" (may try again)\"\n\t\t\t\t\t\t\t     : \" (will try again)\";\n\t\t\t\t}\n\t\t\t\trprintf(msgtype,\n\t\t\t\t\t\"%s: %s failed verification -- update %s%s.\\n\",\n\t\t\t\t\terrstr, local_name ? f_name(file, NULL) : fname,\n\t\t\t\t\tkeptstr, redostr);\n\t\t\t}\n\t\t\tif (!redoing) {\n\t\t\t\tif (read_batch)\n\t\t\t\t\tflist_ndx_push(&batch_redo_list, ndx);\n\t\t\t\tsend_msg_int(MSG_REDO, ndx);\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t} else if (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t    }\n\t\tcase -1:\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (make_backups < 0)\n\t\tmake_backups = -make_backups;\n\n\tif (phase == 2 && delay_updates) \/* for protocol_version < 29 *\/\n\t\thandle_delayed_updates(local_name);\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO,\"recv_files finished\\n\");\n\n\treturn 0;\n}\n","idx":177769,"target":1}
{"code":"WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n  const int argc,const char **argv,Image **images,ExceptionInfo *exception)\n{\n  ChannelType\n    channel;\n\n  const char\n    *option;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index;\n\n  \/*\n    Apply options to the image list.\n  *\/\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image **) NULL);\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  mogrify_info=CloneImageInfo(image_info);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  channel=mogrify_info->channel;\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    if (*images == (Image *) NULL)\n      break;\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"affinity\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                InheritException(exception,&(*images)->exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"append\",option+1) == 0)\n          {\n            Image\n              *append_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            append_image=AppendImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            if (append_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=append_image;\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          {\n            Image\n              *average_image;\n\n            \/*\n              Average an image sequence (deprecated).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            average_image=EvaluateImages(*images,MeanEvaluateOperator,\n              exception);\n            if (average_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=average_image;\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                channel=DefaultChannels;\n                break;\n              }\n            channel=(ChannelType) ParseChannelOption(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          {\n            Image\n              *clut_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            clut_image=RemoveFirstImageFromList(images);\n            if (clut_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) ClutImageChannel(image,channel,clut_image);\n            clut_image=DestroyImage(clut_image);\n            InheritException(exception,&image->exception);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          {\n            Image\n              *coalesce_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            coalesce_image=CoalesceImages(*images,exception);\n            if (coalesce_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=coalesce_image;\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            Image\n              *combine_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            combine_image=CombineImages(*images,channel,exception);\n            if (combine_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=combine_image;\n            break;\n          }\n        if (LocaleCompare(\"compare\",option+1) == 0)\n          {\n            const char\n              *option;\n\n            double\n              distortion;\n\n            Image\n              *difference_image,\n              *image,\n              *reconstruct_image;\n\n            MetricType\n              metric;\n\n            \/*\n              Mathematically and visually annotate the difference between an\n              image and its reconstruction.\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            reconstruct_image=RemoveFirstImageFromList(images);\n            if (reconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            metric=UndefinedMetric;\n            option=GetImageOption(image_info,\"metric\");\n            if (option != (const char *) NULL)\n              metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n                MagickFalse,option);\n            difference_image=CompareImageChannels(image,reconstruct_image,\n               channel,metric,&distortion,exception);\n             if (difference_image == (Image *) NULL)\n               break;\n             if (*images != (Image *) NULL)\n               *images=DestroyImageList(*images);\n             *images=difference_image;\n            break;\n          }\n        if (LocaleCompare(\"complex\",option+1) == 0)\n          {\n            ComplexOperator\n              op;\n\n            Image\n              *complex_images;\n\n            (void) SyncImageSettings(mogrify_info,*images);\n            op=(ComplexOperator) ParseCommandOption(MagickComplexOptions,\n              MagickFalse,argv[i+1]);\n            complex_images=ComplexImages(*images,op,exception);\n            if (complex_images == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=complex_images;\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          {\n            Image\n              *mask_image,\n              *composite_image,\n              *image;\n\n            RectangleInfo\n              geometry;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            composite_image=RemoveFirstImageFromList(images);\n            if (composite_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) TransformImage(&composite_image,(char *) NULL,\n              composite_image->geometry);\n            SetGeometry(composite_image,&geometry);\n            (void) ParseAbsoluteGeometry(composite_image->geometry,&geometry);\n            GravityAdjustGeometry(image->columns,image->rows,image->gravity,\n              &geometry);\n            mask_image=RemoveFirstImageFromList(images);\n            if (mask_image != (Image *) NULL)\n              {\n                if ((image->compose == DisplaceCompositeOp) ||\n                    (image->compose == DistortCompositeOp))\n                  {\n                    \/*\n                      Merge Y displacement into X displacement image.\n                    *\/\n                    (void) CompositeImage(composite_image,CopyGreenCompositeOp,\n                      mask_image,0,0);\n                    mask_image=DestroyImage(mask_image);\n                  }\n                else\n                  {\n                    \/*\n                      Set a blending mask for the composition.\n                    *\/\n                    if (image->mask != (Image *) NULL)\n                      image->mask=DestroyImage(image->mask);\n                    image->mask=mask_image;\n                    (void) NegateImage(image->mask,MagickFalse);\n                  }\n              }\n            (void) CompositeImageChannel(image,channel,image->compose,\n              composite_image,geometry.x,geometry.y);\n            if (mask_image != (Image *) NULL)\n              {\n                image->mask=DestroyImage(image->mask);\n                mask_image=image->mask;\n              }\n            composite_image=DestroyImage(composite_image);\n            InheritException(exception,&image->exception);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            \/*\n              Copy image pixels.\n            *\/\n            (void) SyncImageSettings(mogrify_info,*images);\n            (void) ParsePageGeometry(*images,argv[i+2],&geometry,exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=(*images);\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,argv[i+1],&geometry,\n              exception);\n            status=CopyImagePixels(*images,source_image,&geometry,&offset,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          {\n            Image\n              *deconstruct_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            deconstruct_image=DeconstructImages(*images,exception);\n            if (deconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=deconstruct_image;\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              DeleteImages(images,\"-1\",exception);\n            else\n              DeleteImages(images,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither=MagickFalse;\n                break;\n              }\n            quantize_info->dither=MagickTrue;\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            Image\n              *duplicate_images;\n\n            if (*option == '+')\n              duplicate_images=DuplicateImages(*images,1,\"-1\",exception);\n            else\n              {\n                const char\n                  *p;\n\n                size_t\n                  number_duplicates;\n\n                number_duplicates=(size_t) StringToLong(argv[i+1]);\n                p=strchr(argv[i+1],',');\n                if (p == (const char *) NULL)\n                  duplicate_images=DuplicateImages(*images,number_duplicates,\n                    \"-1\",exception);\n                else\n                  duplicate_images=DuplicateImages(*images,number_duplicates,p,\n                    exception);\n              }\n            AppendImageToList(images, duplicate_images);\n            (void) SyncImagesSettings(mogrify_info,*images);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            Image\n              *evaluate_image;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*images);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            evaluate_image=EvaluateImages(*images,op,exception);\n            if (evaluate_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=evaluate_image;\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"fft\",option+1) == 0)\n          {\n            Image\n              *fourier_image;\n\n            \/*\n              Implements the discrete Fourier transform (DFT).\n            *\/\n            (void) SyncImageSettings(mogrify_info,*images);\n            fourier_image=ForwardFourierTransformImage(*images,*option == '-' ?\n              MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          {\n            Image\n              *flatten_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            flatten_image=MergeImageLayers(*images,FlattenLayer,exception);\n            if (flatten_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=flatten_image;\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            Image\n              *fx_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            fx_image=FxImageChannel(*images,channel,argv[i+1],exception);\n            if (fx_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=fx_image;\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          {\n            Image\n              *hald_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            hald_image=RemoveFirstImageFromList(images);\n            if (hald_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) HaldClutImageChannel(image,channel,hald_image);\n            hald_image=DestroyImage(hald_image);\n            InheritException(exception,&image->exception);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"ift\",option+1) == 0)\n          {\n            Image\n              *fourier_image,\n              *magnitude_image,\n              *phase_image;\n\n            \/*\n              Implements the inverse fourier discrete Fourier transform (DFT).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            magnitude_image=RemoveFirstImageFromList(images);\n            phase_image=RemoveFirstImageFromList(images);\n            if (phase_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            fourier_image=InverseFourierTransformImage(magnitude_image,\n              phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"insert\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q;\n\n            index=0;\n            if (*option != '+')\n              index=(ssize_t) StringToLong(argv[i+1]);\n            p=RemoveLastImageFromList(images);\n            if (p == (Image *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                status=MagickFalse;\n                break;\n              }\n            q=p;\n            if (index == 0)\n              PrependImageToList(images,q);\n            else\n              if (index == (ssize_t) GetImageListLength(*images))\n                AppendImageToList(images,q);\n              else\n                {\n                    q=GetImageFromList(*images,index-1);\n                    if (q == (Image *) NULL)\n                      {\n                        (void) ThrowMagickException(exception,GetMagickModule(),\n                          OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                        status=MagickFalse;\n                       break;\n                     }\n                  InsertImageInList(&q,p);\n                }\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            Image\n              *layers;\n\n            ImageLayerMethod\n              method;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            layers=(Image *) NULL;\n            method=(ImageLayerMethod) ParseCommandOption(MagickLayerOptions,\n              MagickFalse,argv[i+1]);\n            switch (method)\n            {\n              case CoalesceLayer:\n              {\n                layers=CoalesceImages(*images,exception);\n                break;\n              }\n              case CompareAnyLayer:\n              case CompareClearLayer:\n              case CompareOverlayLayer:\n              default:\n              {\n                layers=CompareImageLayers(*images,method,exception);\n                break;\n              }\n              case MergeLayer:\n              case FlattenLayer:\n              case MosaicLayer:\n              case TrimBoundsLayer:\n              {\n                layers=MergeImageLayers(*images,method,exception);\n                break;\n              }\n              case DisposeLayer:\n              {\n                layers=DisposeImages(*images,exception);\n                break;\n              }\n              case OptimizeImageLayer:\n              {\n                layers=OptimizeImageLayers(*images,exception);\n                break;\n              }\n              case OptimizePlusLayer:\n              {\n                layers=OptimizePlusImageLayers(*images,exception);\n                break;\n              }\n              case OptimizeTransLayer:\n              {\n                OptimizeImageTransparency(*images,exception);\n                break;\n              }\n              case RemoveDupsLayer:\n              {\n                RemoveDuplicateLayers(images,exception);\n                break;\n              }\n              case RemoveZeroLayer:\n              {\n                RemoveZeroDelayLayers(images,exception);\n                break;\n              }\n              case OptimizeLayer:\n              {\n                \/*\n                  General Purpose, GIF Animation Optimizer.\n                *\/\n                layers=CoalesceImages(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                InheritException(exception,&layers->exception);\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=OptimizeImageLayers(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                InheritException(exception,&layers->exception);\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=(Image *) NULL;\n                OptimizeImageTransparency(*images,exception);\n                InheritException(exception,&(*images)->exception);\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                break;\n              }\n              case CompositeLayer:\n              {\n                CompositeOperator\n                  compose;\n\n                Image\n                  *source;\n\n                RectangleInfo\n                  geometry;\n\n                \/*\n                  Split image sequence at the first 'NULL:' image.\n                *\/\n                source=(*images);\n                while (source != (Image *) NULL)\n                {\n                  source=GetNextImageInList(source);\n                  if ((source != (Image *) NULL) &&\n                      (LocaleCompare(source->magick,\"NULL\") == 0))\n                    break;\n                }\n                if (source != (Image *) NULL)\n                  {\n                    if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                        (GetNextImageInList(source) == (Image *) NULL))\n                      source=(Image *) NULL;\n                    else\n                      {\n                        \/*\n                          Separate the two lists, junk the null: image.\n                        *\/\n                        source=SplitImageList(source->previous);\n                        DeleteImageFromList(&source);\n                      }\n                  }\n                if (source == (Image *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                    status=MagickFalse;\n                    break;\n                  }\n                \/*\n                  Adjust offset with gravity and virtual canvas.\n                *\/\n                SetGeometry(*images,&geometry);\n                (void) ParseAbsoluteGeometry((*images)->geometry,&geometry);\n                geometry.width=source->page.width != 0 ?\n                  source->page.width : source->columns;\n                geometry.height=source->page.height != 0 ?\n                 source->page.height : source->rows;\n                GravityAdjustGeometry((*images)->page.width != 0 ?\n                  (*images)->page.width : (*images)->columns,\n                  (*images)->page.height != 0 ? (*images)->page.height :\n                  (*images)->rows,(*images)->gravity,&geometry);\n                compose=OverCompositeOp;\n                option=GetImageOption(mogrify_info,\"compose\");\n                if (option != (const char *) NULL)\n                  compose=(CompositeOperator) ParseCommandOption(\n                    MagickComposeOptions,MagickFalse,option);\n                CompositeLayers(*images,compose,source,geometry.x,geometry.y,\n                  exception);\n                source=DestroyImageList(source);\n                break;\n              }\n            }\n            if (layers == (Image *) NULL)\n              break;\n            InheritException(exception,&layers->exception);\n            *images=DestroyImageList(*images);\n            *images=layers;\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                InheritException(exception,&(*images)->exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          {\n            Image\n              *maximum_image;\n\n            \/*\n              Maximum image sequence (deprecated).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            maximum_image=EvaluateImages(*images,MaxEvaluateOperator,exception);\n            if (maximum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=maximum_image;\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          {\n            Image\n              *minimum_image;\n\n            \/*\n              Minimum image sequence (deprecated).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            minimum_image=EvaluateImages(*images,MinEvaluateOperator,exception);\n            if (minimum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=minimum_image;\n            break;\n          }\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            Image\n              *morph_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            morph_image=MorphImages(*images,StringToUnsignedLong(argv[i+1]),\n              exception);\n            if (morph_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=morph_image;\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          {\n            Image\n              *mosaic_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            mosaic_image=MergeImageLayers(*images,MosaicLayer,exception);\n            if (mosaic_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=mosaic_image;\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MaxTextExtent];\n\n            const char\n              *p;\n\n            double\n              *arguments;\n\n            Image\n              *polynomial_image;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            \/*\n              Polynomial image.\n            *\/\n            (void) SyncImageSettings(mogrify_info,*images);\n            args=InterpretImageProperties(mogrify_info,*images,argv[i+1]);\n            InheritException(exception,&(*images)->exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MaxTextExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MaxTextExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*images)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MaxTextExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MaxTextExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            polynomial_image=PolynomialImageChannel(*images,channel,\n              number_arguments >> 1,arguments,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            if (polynomial_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=polynomial_image;\n            break;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            char\n              *string;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            string=InterpretImageProperties(mogrify_info,*images,argv[i+1]);\n            if (string == (char *) NULL)\n              break;\n            InheritException(exception,&(*images)->exception);\n            (void) FormatLocaleFile(stdout,\"%s\",string);\n            string=DestroyString(string);\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            char\n              **arguments;\n\n            int\n              j,\n              number_arguments;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            arguments=StringToArgv(argv[i+1],&number_arguments);\n            if (arguments == (char **) NULL)\n              break;\n            if ((argc > 1) && (strchr(arguments[1],'=') != (char *) NULL))\n              {\n                char\n                  breaker,\n                  quote,\n                  *token;\n\n                const char\n                  *arguments;\n\n                int\n                  next,\n                  status;\n\n                size_t\n                  length;\n\n                TokenInfo\n                  *token_info;\n\n                \/*\n                  Support old style syntax, filter=\"-option arg\".\n                *\/\n                length=strlen(argv[i+1]);\n                token=(char *) NULL;\n                if (~length >= (MaxTextExtent-1))\n                  token=(char *) AcquireQuantumMemory(length+MaxTextExtent,\n                    sizeof(*token));\n                if (token == (char *) NULL)\n                  break;\n                next=0;\n                arguments=argv[i+1];\n                token_info=AcquireTokenInfo();\n                status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",\n                  \"\\\"\",'\\0',&breaker,&next,&quote);\n                token_info=DestroyTokenInfo(token_info);\n                if (status == 0)\n                  {\n                    const char\n                      *argv;\n\n                    argv=(&(arguments[next]));\n                    (void) InvokeDynamicImageFilter(token,&(*images),1,&argv,\n                      exception);\n                  }\n                token=DestroyString(token);\n                break;\n              }\n            (void) SubstituteString(&arguments[1],\"-\",\"\");\n            (void) InvokeDynamicImageFilter(arguments[1],&(*images),\n              number_arguments-2,(const char **) arguments+2,exception);\n            for (j=0; j < number_arguments; j++)\n              arguments[j]=DestroyString(arguments[j]);\n            arguments=(char **) RelinquishMagickMemory(arguments);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          {\n            ReverseImageList(images);\n            InheritException(exception,&(*images)->exception);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            Image\n              *smush_image;\n\n            ssize_t\n              offset;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            offset=(ssize_t) StringToLong(argv[i+1]);\n            smush_image=SmushImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,offset,exception);\n            if (smush_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=smush_image;\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q,\n              *u,\n              *v;\n\n            ssize_t\n              swap_index;\n\n            index=(-1);\n            swap_index=(-2);\n            if (*option != '+')\n              {\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                swap_index=(-1);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                index=(ssize_t) geometry_info.rho;\n                if ((flags & SigmaValue) != 0)\n                  swap_index=(ssize_t) geometry_info.sigma;\n              }\n            p=GetImageFromList(*images,index);\n            q=GetImageFromList(*images,swap_index);\n            if ((p == (Image *) NULL) || (q == (Image *) NULL))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",(*images)->filename);\n                status=MagickFalse;\n                break;\n              }\n            if (p == q)\n              break;\n            u=CloneImage(p,0,0,MagickTrue,exception);\n            if (u == (Image *) NULL)\n              break;\n            v=CloneImage(q,0,0,MagickTrue,exception);\n            if (v == (Image *) NULL)\n              {\n                u=DestroyImage(u);\n                break;\n              }\n            ReplaceImageInList(&p,v);\n            ReplaceImageInList(&q,u);\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            char\n              key[MaxTextExtent];\n\n            Image\n              *write_images;\n\n            ImageInfo\n              *write_info;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            (void) FormatLocaleString(key,MaxTextExtent,\"cache:%s\",argv[i+1]);\n            (void) DeleteImageRegistry(key);\n            write_images=(*images);\n            if (*option == '+')\n              write_images=CloneImageList(*images,exception);\n            write_info=CloneImageInfo(mogrify_info);\n            status&=WriteImages(write_info,write_images,argv[i+1],exception);\n            write_info=DestroyImageInfo(write_info);\n            if (*option == '+')\n              write_images=DestroyImageList(write_images);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status&=MogrifyImageInfo(image_info,argc,argv,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n","idx":182764,"target":1}
{"code":"  void CallbackAndDie(bool succeeded) {\n    v8::Isolate* isolate = context_->isolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};\n    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),\n                           arraysize(args), args);\n     delete this;\n   }\n","idx":186112,"target":1}
{"code":" pim_print(netdissect_options *ndo,\n           register const u_char *bp, register u_int len, const u_char *bp2)\n {\n\tregister const u_char *ep;\n \tregister const struct pim *pim = (const struct pim *)bp;\n \n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n #ifdef notyet\t\t\t\/* currently we see only version and type *\/\n \tND_TCHECK(pim->pim_rsv);\n #endif\n \n \tswitch (PIM_VER(pim->pim_typever)) {\n \tcase 2:\n \t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n \t\tbreak;\n \t}\n \treturn;\n }\n","idx":181026,"target":1}
{"code":"void ExtensionServiceBackend::OnExtensionInstalled(\n     const scoped_refptr<const Extension>& extension) {\n   CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n   if (frontend_.get())\n    frontend_->OnExtensionInstalled(extension);\n }\n","idx":183865,"target":1}
{"code":"static int encode_residual_ch(FlacEncodeContext *s, int ch)\n\n{\n\n    int i, n;\n\n    int min_order, max_order, opt_order, omethod;\n\n    FlacFrame *frame;\n\n    FlacSubframe *sub;\n\n    int32_t coefs[MAX_LPC_ORDER][MAX_LPC_ORDER];\n\n    int shift[MAX_LPC_ORDER];\n\n    int32_t *res, *smp;\n\n\n\n    frame = &s->frame;\n\n    sub   = &frame->subframes[ch];\n\n    res   = sub->residual;\n\n    smp   = sub->samples;\n\n    n     = frame->blocksize;\n\n\n\n    \/* CONSTANT *\/\n\n    for (i = 1; i < n; i++)\n\n        if(smp[i] != smp[0])\n\n            break;\n\n    if (i == n) {\n\n        sub->type = sub->type_code = FLAC_SUBFRAME_CONSTANT;\n\n        res[0] = smp[0];\n\n        return subframe_count_exact(s, sub, 0);\n\n    }\n\n\n\n    \/* VERBATIM *\/\n\n    if (frame->verbatim_only || n < 5) {\n\n        sub->type = sub->type_code = FLAC_SUBFRAME_VERBATIM;\n\n        memcpy(res, smp, n * sizeof(int32_t));\n\n        return subframe_count_exact(s, sub, 0);\n\n    }\n\n\n\n    min_order  = s->options.min_prediction_order;\n\n    max_order  = s->options.max_prediction_order;\n\n    omethod    = s->options.prediction_order_method;\n\n\n\n    \/* FIXED *\/\n\n    sub->type = FLAC_SUBFRAME_FIXED;\n\n    if (s->options.lpc_type == FF_LPC_TYPE_NONE  ||\n\n        s->options.lpc_type == FF_LPC_TYPE_FIXED || n <= max_order) {\n\n        uint32_t bits[MAX_FIXED_ORDER+1];\n\n        if (max_order > MAX_FIXED_ORDER)\n\n            max_order = MAX_FIXED_ORDER;\n\n        opt_order = 0;\n\n        bits[0]   = UINT32_MAX;\n\n        for (i = min_order; i <= max_order; i++) {\n\n            encode_residual_fixed(res, smp, n, i);\n\n            bits[i] = find_subframe_rice_params(s, sub, i);\n\n            if (bits[i] < bits[opt_order])\n\n                opt_order = i;\n\n        }\n\n        sub->order     = opt_order;\n\n        sub->type_code = sub->type | sub->order;\n\n        if (sub->order != max_order) {\n\n            encode_residual_fixed(res, smp, n, sub->order);\n\n            find_subframe_rice_params(s, sub, sub->order);\n\n        }\n\n        return subframe_count_exact(s, sub, sub->order);\n\n    }\n\n\n\n    \/* LPC *\/\n\n    sub->type = FLAC_SUBFRAME_LPC;\n\n    opt_order = ff_lpc_calc_coefs(&s->lpc_ctx, smp, n, min_order, max_order,\n\n                                  s->options.lpc_coeff_precision, coefs, shift, s->options.lpc_type,\n\n                                  s->options.lpc_passes, omethod,\n\n                                  MAX_LPC_SHIFT, 0);\n\n\n\n    if (omethod == ORDER_METHOD_2LEVEL ||\n\n        omethod == ORDER_METHOD_4LEVEL ||\n\n        omethod == ORDER_METHOD_8LEVEL) {\n\n        int levels = 1 << omethod;\n\n        uint32_t bits[1 << ORDER_METHOD_8LEVEL];\n\n        int order;\n\n        int opt_index   = levels-1;\n\n        opt_order       = max_order-1;\n\n        bits[opt_index] = UINT32_MAX;\n\n        for (i = levels-1; i >= 0; i--) {\n\n            order = min_order + (((max_order-min_order+1) * (i+1)) \/ levels)-1;\n\n            if (order < 0)\n\n                order = 0;\n\n            encode_residual_lpc(res, smp, n, order+1, coefs[order], shift[order]);\n\n            bits[i] = find_subframe_rice_params(s, sub, order+1);\n\n            if (bits[i] < bits[opt_index]) {\n\n                opt_index = i;\n\n                opt_order = order;\n\n            }\n\n        }\n\n        opt_order++;\n\n    } else if (omethod == ORDER_METHOD_SEARCH) {\n\n        \/\/ brute-force optimal order search\n\n        uint32_t bits[MAX_LPC_ORDER];\n\n        opt_order = 0;\n\n        bits[0]   = UINT32_MAX;\n\n        for (i = min_order-1; i < max_order; i++) {\n\n            encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n\n            bits[i] = find_subframe_rice_params(s, sub, i+1);\n\n            if (bits[i] < bits[opt_order])\n\n                opt_order = i;\n\n        }\n\n        opt_order++;\n\n    } else if (omethod == ORDER_METHOD_LOG) {\n\n        uint32_t bits[MAX_LPC_ORDER];\n\n        int step;\n\n\n\n        opt_order = min_order - 1 + (max_order-min_order)\/3;\n\n        memset(bits, -1, sizeof(bits));\n\n\n\n        for (step = 16; step; step >>= 1) {\n\n            int last = opt_order;\n\n            for (i = last-step; i <= last+step; i += step) {\n\n                if (i < min_order-1 || i >= max_order || bits[i] < UINT32_MAX)\n\n                    continue;\n\n                encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n\n                bits[i] = find_subframe_rice_params(s, sub, i+1);\n\n                if (bits[i] < bits[opt_order])\n\n                    opt_order = i;\n\n            }\n\n        }\n\n        opt_order++;\n\n    }\n\n\n\n    sub->order     = opt_order;\n\n    sub->type_code = sub->type | (sub->order-1);\n\n    sub->shift     = shift[sub->order-1];\n\n    for (i = 0; i < sub->order; i++)\n\n        sub->coefs[i] = coefs[sub->order-1][i];\n\n\n\n    encode_residual_lpc(res, smp, n, sub->order, sub->coefs, sub->shift);\n\n\n\n    find_subframe_rice_params(s, sub, sub->order);\n\n\n\n    return subframe_count_exact(s, sub, sub->order);\n\n}\n","idx":9234,"target":1}
{"code":"static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n \t\treturn;\n \t}\n \tif (status) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n \t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n \t\t\/* These are unsolicited reports from the firmware, hence no\n \t\t   waiting command to wakeup *\/\n \t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n \t\tmemcpy(command_info->result_buffer, &data[1],\n \t\t\t\t\t\turb->actual_length - 1);\n \t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t\/* Continue trying to always read *\/\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\n","idx":179541,"target":1}
{"code":"void ASessionDescription::getFormatType(\n size_t index, unsigned long *PT,\n AString *desc, AString *params) const {\n AString format;\n    getFormat(index, &format);\n\n const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n char *end;\n unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n \n     *PT = x;\n \n    char key[20];\n    sprintf(key, \"a=rtpmap:%lu\", x);\n \n     CHECK(findAttribute(index, key, desc));\n \n    sprintf(key, \"a=fmtp:%lu\", x);\n     if (!findAttribute(index, key, params)) {\n         params->clear();\n     }\n}\n","idx":187433,"target":1}
{"code":"static void ehci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    EHCIPCIInfo *i = data;\n\n\n\n    k->init = usb_ehci_pci_initfn;\n\n    k->vendor_id = i->vendor_id;\n\n    k->device_id = i->device_id;\n\n    k->revision = i->revision;\n\n    k->class_id = PCI_CLASS_SERIAL_USB;\n\n    k->config_write = usb_ehci_pci_write_config;\n\n\n    dc->vmsd = &vmstate_ehci_pci;\n\n    dc->props = ehci_pci_properties;\n\n}","idx":21407,"target":1}
{"code":"static int bdrv_qed_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = 0; \/* ret should always be 0 or -errno *\/\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        \/* image uses unsupported feature bits *\/\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bs->device_name, \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    \/* Round down file size to the last cluster *\/\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) \/\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    \/* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     *\/\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        \/* From here on only known autoclear feature bits are valid *\/\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    \/* If image was not closed cleanly, check consistency *\/\n\n    if (s->header.features & QED_F_NEED_CHECK) {\n\n        \/* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         *\/\n\n        if (!bdrv_is_read_only(bs->file)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (!ret && !result.corruptions && !result.check_errors) {\n\n                \/* Ensure fixes reach storage before clearing check bit *\/\n\n                bdrv_flush(s->bs);\n\n\n\n                s->header.features &= ~QED_F_NEED_CHECK;\n\n                qed_write_header_sync(s);\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n","idx":6631,"target":1}
{"code":"static void render_line(int x0, int y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { \/\/ optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base = dy \/ adx;\n\n        int x    = x0;\n\n        int y    = y0;\n\n        int err  = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n","idx":15155,"target":1}
{"code":"static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) \/* {{{ *\/\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n \tif (intern->oth_handler && intern->oth_handler->dtor) {\n \t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n \t}\n \tzend_object_std_dtor(&intern->std TSRMLS_CC);\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n \t\t}\n \t\tif (intern->u.dir.sub_path) {\n \t\t\tefree(intern->u.dir.sub_path);\n\t\t}\t\t\n \t\tbreak;\n \tcase SPL_FS_FILE:\n \t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n\/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*\/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n } \/* }}} *\/\n","idx":180255,"target":1}
{"code":"static av_cold int ulti_decode_init(AVCodecContext *avctx)\n\n{\n\n    UltimotionDecodeContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n    s->blocks = (s->width \/ 8) * (s->height \/ 8);\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n\n    s->ulti_codebook = ulti_codebook;\n\n\n\n    s->frame = av_frame_alloc();\n\n    if (!s->frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    return 0;\n\n}","idx":18716,"target":1}
{"code":"static int decode_frame_header(NUTContext *nut, int64_t *pts, int *stream_id,\n\n                               uint8_t *header_idx, int frame_code)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    StreamContext *stc;\n\n    int size, flags, size_mul, pts_delta, i, reserved_count;\n\n    uint64_t tmp;\n\n\n\n    if (avio_tell(bc) > nut->last_syncpoint_pos + nut->max_distance) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Last frame must have been damaged %\"PRId64\" > %\"PRId64\" + %d\\n\",\n\n               avio_tell(bc), nut->last_syncpoint_pos, nut->max_distance);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    flags          = nut->frame_code[frame_code].flags;\n\n    size_mul       = nut->frame_code[frame_code].size_mul;\n\n    size           = nut->frame_code[frame_code].size_lsb;\n\n    *stream_id     = nut->frame_code[frame_code].stream_id;\n\n    pts_delta      = nut->frame_code[frame_code].pts_delta;\n\n    reserved_count = nut->frame_code[frame_code].reserved_count;\n\n    *header_idx    = nut->frame_code[frame_code].header_idx;\n\n\n\n    if (flags & FLAG_INVALID)\n\n        return AVERROR_INVALIDDATA;\n\n    if (flags & FLAG_CODED)\n\n        flags ^= ffio_read_varlen(bc);\n\n    if (flags & FLAG_STREAM_ID) {\n\n        GET_V(*stream_id, tmp < s->nb_streams);\n\n    }\n\n    stc = &nut->stream[*stream_id];\n\n    if (flags & FLAG_CODED_PTS) {\n\n        int coded_pts = ffio_read_varlen(bc);\n\n        \/\/ FIXME check last_pts validity?\n\n        if (coded_pts < (1 << stc->msb_pts_shift)) {\n\n            *pts = ff_lsb2full(stc, coded_pts);\n\n        } else\n\n            *pts = coded_pts - (1 << stc->msb_pts_shift);\n\n    } else\n\n        *pts = stc->last_pts + pts_delta;\n\n    if (flags & FLAG_SIZE_MSB)\n\n        size += size_mul * ffio_read_varlen(bc);\n\n    if (flags & FLAG_MATCH_TIME)\n\n        get_s(bc);\n\n    if (flags & FLAG_HEADER_IDX)\n\n        *header_idx = ffio_read_varlen(bc);\n\n    if (flags & FLAG_RESERVED)\n\n        reserved_count = ffio_read_varlen(bc);\n\n    for (i = 0; i < reserved_count; i++)\n\n        ffio_read_varlen(bc);\n\n\n\n    if (*header_idx >= (unsigned)nut->header_count) {\n\n        av_log(s, AV_LOG_ERROR, \"header_idx invalid\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (size > 4096)\n\n        *header_idx = 0;\n\n    size -= nut->header_len[*header_idx];\n\n\n\n    if (flags & FLAG_CHECKSUM) {\n\n        avio_rb32(bc); \/\/ FIXME check this\n\n    } else if (size > 2 * nut->max_distance || FFABS(stc->last_pts - *pts) >\n\n               stc->max_pts_distance) {\n\n        av_log(s, AV_LOG_ERROR, \"frame size > 2max_distance and no checksum\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    stc->last_pts   = *pts;\n\n    stc->last_flags = flags;\n\n\n\n    return size;\n\n}\n","idx":20044,"target":1}
{"code":"RenderProcessImpl::RenderProcessImpl()\n     : ALLOW_THIS_IN_INITIALIZER_LIST(shared_mem_cache_cleaner_(\n           FROM_HERE, base::TimeDelta::FromSeconds(5),\n           this, &RenderProcessImpl::ClearTransportDIBCache)),\n      transport_dib_next_sequence_number_(0) {\n   in_process_plugins_ = InProcessPlugins();\n   for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i)\n     shared_mem_cache_[i] = NULL;\n\n#if defined(OS_WIN)\n  if (GetModuleHandle(L\"LPK.DLL\") == NULL) {\n    typedef BOOL (__stdcall *GdiInitializeLanguagePack)(int LoadedShapingDLLs);\n    GdiInitializeLanguagePack gdi_init_lpk =\n        reinterpret_cast<GdiInitializeLanguagePack>(GetProcAddress(\n            GetModuleHandle(L\"GDI32.DLL\"),\n            \"GdiInitializeLanguagePack\"));\n    DCHECK(gdi_init_lpk);\n    if (gdi_init_lpk) {\n      gdi_init_lpk(0);\n    }\n  }\n#endif\n\n  webkit_glue::SetJavaScriptFlags(\n      \"--debugger-auto-break\"\n      \" --prof --prof-lazy\");\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kJavaScriptFlags)) {\n    webkit_glue::SetJavaScriptFlags(\n        command_line.GetSwitchValueASCII(switches::kJavaScriptFlags));\n  }\n}\n","idx":184709,"target":1}
{"code":"static int decode_interrupt_cb(void *ctx)\n\n{\n\n    return received_nb_signals > transcode_init_done;\n\n}\n","idx":25377,"target":1}
{"code":"void ff_mpeg4_encode_picture_header(MpegEncContext *s, int picture_number)\n\n{\n\n    int time_incr;\n\n    int time_div, time_mod;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        if (!(s->avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)) {\n\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT)  \/\/ HACK, the reference sw is buggy\n\n                mpeg4_encode_visual_object_header(s);\n\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number == 0)  \/\/ HACK, the reference sw is buggy\n\n                mpeg4_encode_vol_header(s, 0, 0);\n\n        }\n\n        if (!(s->workaround_bugs & FF_BUG_MS))\n\n            mpeg4_encode_gop_header(s);\n\n    }\n\n\n\n    s->partitioned_frame = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B;\n\n\n\n    put_bits(&s->pb, 16, 0);                \/* vop header *\/\n\n    put_bits(&s->pb, 16, VOP_STARTCODE);    \/* vop header *\/\n\n    put_bits(&s->pb, 2, s->pict_type - 1);  \/* pict type: I = 0 , P = 1 *\/\n\n\n\n    time_div  = FFUDIV(s->time, s->avctx->time_base.den);\n\n    time_mod  = FFUMOD(s->time, s->avctx->time_base.den);\n\n    time_incr = time_div - s->last_time_base;\n\n    av_assert0(time_incr >= 0);\n\n    while (time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             \/* marker *\/\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); \/* time increment *\/\n\n    put_bits(&s->pb, 1, 1);                             \/* marker *\/\n\n    put_bits(&s->pb, 1, 1);                             \/* vop coded *\/\n\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    \/* rounding type *\/\n\n    }\n\n    put_bits(&s->pb, 3, 0);     \/* intra dc VLC threshold *\/\n\n    if (!s->progressive_sequence) {\n\n        put_bits(&s->pb, 1, s->current_picture_ptr->f->top_field_first);\n\n        put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    \/\/ FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code);  \/* fcode_for *\/\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code);  \/* fcode_back *\/\n\n}\n","idx":8909,"target":1}
{"code":"static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    uint8_t *outbuf;\n\n    int buflen;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case INQUIRY:\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n    case RESERVE:\n\n    case RESERVE_10:\n\n    case RELEASE:\n\n    case RELEASE_10:\n\n    case START_STOP:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case GET_CONFIGURATION:\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n    case MECHANISM_STATUS:\n\n    case REQUEST_SENSE:\n\n        break;\n\n\n\n    default:\n\n        if (s->tray_open || !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n\n\n    \/*\n\n     * FIXME: we shouldn't return anything bigger than 4k, but the code\n\n     * requires the buffer to be as big as req->cmd.xfer in several\n\n     * places.  So, do not allow CDBs with a very large ALLOCATION\n\n     * LENGTH.  The real fix would be to modify scsi_read_data and\n\n     * dma_buf_read, so that they return data beyond the buflen\n\n     * as all zeros.\n\n     *\/\n\n    if (req->cmd.xfer > 65536) {\n\n        goto illegal_request;\n\n    }\n\n    r->buflen = MAX(4096, req->cmd.xfer);\n\n\n\n    if (!r->iov.iov_base) {\n\n        r->iov.iov_base = qemu_blockalign(s->qdev.conf.bs, r->buflen);\n\n    }\n\n\n\n    buflen = req->cmd.xfer;\n\n    outbuf = r->iov.iov_base;\n\n    memset(outbuf, 0, r->buflen);\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        assert(!s->tray_open && bdrv_is_inserted(s->qdev.conf.bs));\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case START_STOP:\n\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n\n            return 0;\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        s->tray_locked = req->cmd.buf[4] & 1;\n\n        bdrv_lock_medium(s->qdev.conf.bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        \/* The normal LEN field for this command is zero.  *\/\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n        if (!nb_sectors) {\n\n            scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n            return 0;\n\n        }\n\n        if ((req->cmd.buf[8] & 1) == 0 && req->cmd.lba) {\n\n            goto illegal_request;\n\n        }\n\n        nb_sectors \/= s->qdev.blocksize \/ 512;\n\n        \/* Returned value is the address of the last sector.  *\/\n\n        nb_sectors--;\n\n        \/* Remember the new size for read\/write sanity checking. *\/\n\n        s->qdev.max_lba = nb_sectors;\n\n        \/* Clip to 2TB, instead of returning capacity modulo 2TB. *\/\n\n        if (nb_sectors > UINT32_MAX) {\n\n            nb_sectors = UINT32_MAX;\n\n        }\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->qdev.blocksize >> 8;\n\n        outbuf[7] = 0;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        \/* Just return \"NO SENSE\".  *\/\n\n        buflen = scsi_build_sense(NULL, 0, outbuf, r->buflen,\n\n                                  (req->cmd.buf[1] & 1) == 0);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n        buflen = scsi_emulate_mechanism_status(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        buflen = scsi_get_configuration(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n        buflen = scsi_get_event_status_notification(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DISC_INFORMATION:\n\n        buflen = scsi_read_disc_information(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DVD_STRUCTURE:\n\n        buflen = scsi_read_dvd_structure(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case SERVICE_ACTION_IN_16:\n\n        \/* Service Action In subcommands. *\/\n\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n            if (!nb_sectors) {\n\n                scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n                return 0;\n\n            }\n\n            if ((req->cmd.buf[14] & 1) == 0 && req->cmd.lba) {\n\n                goto illegal_request;\n\n            }\n\n            nb_sectors \/= s->qdev.blocksize \/ 512;\n\n            \/* Returned value is the address of the last sector.  *\/\n\n            nb_sectors--;\n\n            \/* Remember the new size for read\/write sanity checking. *\/\n\n            s->qdev.max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->qdev.blocksize >> 8;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            \/* set TPE bit if the format supports discard *\/\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            \/* Protection, exponent and lowest lba field left blank. *\/\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case SYNCHRONIZE_CACHE:\n\n        \/* The request is used as the AIO opaque value, so add a ref.  *\/\n\n        scsi_req_ref(&r->req);\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n\n        r->req.aiocb = bdrv_aio_flush(s->qdev.conf.bs, scsi_aio_complete, r);\n\n        return 0;\n\n    case SEEK_10:\n\n        DPRINTF(\"Seek(10) (sector %\" PRId64 \")\\n\", r->req.cmd.lba);\n\n        if (r->req.cmd.lba > s->qdev.max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n        break;\n\n    case MODE_SELECT:\n\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case MODE_SELECT_10:\n\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case UNMAP:\n\n        DPRINTF(\"Unmap (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        nb_sectors = scsi_data_cdb_length(r->req.cmd.buf);\n\n        if (bdrv_is_read_only(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));\n\n            return 0;\n\n        }\n\n        if (!check_lba_range(s, r->req.cmd.lba, nb_sectors)) {\n\n            goto illegal_lba;\n\n        }\n\n\n\n        \/*\n\n         * We only support WRITE SAME with the unmap bit set for now.\n\n         *\/\n\n        if (!(req->cmd.buf[1] & 0x8)) {\n\n            goto illegal_request;\n\n        }\n\n\n\n        \/* The request is used as the AIO opaque value, so add a ref.  *\/\n\n        scsi_req_ref(&r->req);\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        r->req.cmd.lba * (s->qdev.blocksize \/ 512),\n\n                                        nb_sectors * (s->qdev.blocksize \/ 512),\n\n                                        scsi_aio_complete, r);\n\n        return 0;\n\n    default:\n\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    }\n\n    assert(!r->req.aiocb);\n\n    r->iov.iov_len = MIN(r->buflen, req->cmd.xfer);\n\n    if (r->iov.iov_len == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        assert(r->iov.iov_len == req->cmd.xfer);\n\n        return -r->iov.iov_len;\n\n    } else {\n\n        return r->iov.iov_len;\n\n    }\n\n\n\nillegal_request:\n\n    if (r->req.status == -1) {\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    }\n\n    return 0;\n\n\n\nillegal_lba:\n\n    scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n    return 0;\n\n}\n","idx":8582,"target":1}
{"code":"modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n         if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n     }\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n","idx":180692,"target":1}
{"code":" beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n {\n \n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \/* A REQuest *\/\n \t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP END\"));\n \telse\n \t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}\n","idx":181056,"target":1}
{"code":"static int openfile(char *name, int flags, QDict *opts)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n\n    if (qemuio_blk) {\n\n        fprintf(stderr, \"file open already, try 'help close'\\n\");\n\n        QDECREF(opts);\n\n        return 1;\n\n    }\n\n\n\n    qemuio_blk = blk_new_open(\"hda\", name, NULL, opts, flags, &local_err);\n\n    if (!qemuio_blk) {\n\n        fprintf(stderr, \"%s: can't open%s%s: %s\\n\", progname,\n\n                name ? \" device \" : \"\", name ?: \"\",\n\n                error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        return 1;\n\n    }\n\n\n\n    bs = blk_bs(qemuio_blk);\n\n    if (bdrv_is_encrypted(bs)) {\n\n        char password[256];\n\n        printf(\"Disk image '%s' is encrypted.\\n\", name);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            goto error;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n\n\n    return 0;\n\n\n\n error:\n\n    blk_unref(qemuio_blk);\n\n    qemuio_blk = NULL;\n\n    return 1;\n\n}","idx":8022,"target":1}
{"code":"void gicv3_cpuif_update(GICv3CPUState *cs)\n{\n    \/* Tell the CPU about its highest priority pending interrupt *\/\n    int irqlevel = 0;\n    int fiqlevel = 0;\n    ARMCPU *cpu = ARM_CPU(cs->cpu);\n    CPUARMState *env = &cpu->env;\n    trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq,\n                             cs->hppi.grp, cs->hppi.prio);\n    if (cs->hppi.grp == GICV3_G1 && !arm_feature(env, ARM_FEATURE_EL3)) {\n        \/* If a Security-enabled GIC sends a G1S interrupt to a\n         * Security-disabled CPU, we must treat it as if it were G0.\n         *\/\n        cs->hppi.grp = GICV3_G0;\n    }\n    if (icc_hppi_can_preempt(cs)) {\n        \/* We have an interrupt: should we signal it as IRQ or FIQ?\n         * This is described in the GICv3 spec section 4.6.2.\n         *\/\n        bool isfiq;\n        switch (cs->hppi.grp) {\n        case GICV3_G0:\n            isfiq = true;\n            break;\n        case GICV3_G1:\n            isfiq = (!arm_is_secure(env) ||\n                     (arm_current_el(env) == 3 && arm_el_is_aa64(env, 3)));\n            break;\n        case GICV3_G1NS:\n            isfiq = arm_is_secure(env);\n            break;\n        default:\n            g_assert_not_reached();\n        }\n        if (isfiq) {\n            fiqlevel = 1;\n        } else {\n            irqlevel = 1;\n        }\n    }\n    trace_gicv3_cpuif_set_irqs(gicv3_redist_affid(cs), fiqlevel, irqlevel);\n    qemu_set_irq(cs->parent_fiq, fiqlevel);\n    qemu_set_irq(cs->parent_irq, irqlevel);\n}","idx":5259,"target":1}
{"code":"aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct aiptek *aiptek;\n\tstruct input_dev *inputdev;\n\tint i;\n\tint speeds[] = { 0,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_50,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_400,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_25,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_100,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_200,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_300\n\t};\n\tint err = -ENOMEM;\n\n\t\/* programmableDelay is where the command-line specified\n\t * delay is kept. We make it the first element of speeds[],\n\t * so therefore, your override speed is tried first, then the\n\t * remainder. Note that the default value of 400ms will be tried\n\t * if you do not specify any command line parameter.\n\t *\/\n\tspeeds[0] = programmableDelay;\n\n\taiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);\n\tinputdev = input_allocate_device();\n\tif (!aiptek || !inputdev) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"cannot allocate memory or input device\\n\");\n\t\tgoto fail1;\n        }\n\n\taiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,\n\t\t\t\t\t  GFP_ATOMIC, &aiptek->data_dma);\n        if (!aiptek->data) {\n\t\tdev_warn(&intf->dev, \"cannot allocate usb buffer\\n\");\n\t\tgoto fail1;\n\t}\n\n\taiptek->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!aiptek->urb) {\n\t        dev_warn(&intf->dev, \"cannot allocate urb\\n\");\n\t\tgoto fail2;\n\t}\n\n\taiptek->inputdev = inputdev;\n\taiptek->usbdev = usbdev;\n\taiptek->intf = intf;\n\taiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\taiptek->inDelay = 0;\n\taiptek->endDelay = 0;\n\taiptek->previousJitterable = 0;\n\taiptek->lastMacro = -1;\n\n\t\/* Set up the curSettings struct. Said struct contains the current\n\t * programmable parameters. The newSetting struct contains changes\n\t * the user makes to the settings via the sysfs interface. Those\n\t * changes are not \"committed\" to curSettings until the user\n\t * writes to the sysfs\/...\/execute file.\n\t *\/\n\taiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;\n\taiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;\n\taiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;\n\taiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;\n\taiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;\n\taiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;\n\taiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;\n\taiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;\n\taiptek->curSetting.jitterDelay = jitterDelay;\n\taiptek->curSetting.programmableDelay = programmableDelay;\n\n\t\/* Both structs should have equivalent settings\n\t *\/\n\taiptek->newSetting = aiptek->curSetting;\n\n\t\/* Determine the usb devices' physical path.\n\t * Asketh not why we always pretend we're using \"..\/input0\",\n\t * but I suspect this will have to be refactored one\n\t * day if a single USB device can be a keyboard & a mouse\n\t * & a tablet, and the inputX number actually will tell\n\t * us something...\n\t *\/\n\tusb_make_path(usbdev, aiptek->features.usbPath,\n\t\t\tsizeof(aiptek->features.usbPath));\n\tstrlcat(aiptek->features.usbPath, \"\/input0\",\n\t\tsizeof(aiptek->features.usbPath));\n\n\t\/* Set up client data, pointers to open and close routines\n\t * for the input device.\n\t *\/\n\tinputdev->name = \"Aiptek\";\n\tinputdev->phys = aiptek->features.usbPath;\n\tusb_to_input_id(usbdev, &inputdev->id);\n\tinputdev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(inputdev, aiptek);\n\n\tinputdev->open = aiptek_open;\n\tinputdev->close = aiptek_close;\n\n\t\/* Now program the capacities of the tablet, in terms of being\n\t * an input device.\n\t *\/\n\tfor (i = 0; i < ARRAY_SIZE(eventTypes); ++i)\n\t        __set_bit(eventTypes[i], inputdev->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(absEvents); ++i)\n\t        __set_bit(absEvents[i], inputdev->absbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(relEvents); ++i)\n\t        __set_bit(relEvents[i], inputdev->relbit);\n\n\t__set_bit(MSC_SERIAL, inputdev->mscbit);\n\n\t\/* Set up key and button codes *\/\n\tfor (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)\n\t\t__set_bit(buttonEvents[i], inputdev->keybit);\n\n\tfor (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)\n\t\t__set_bit(macroKeyEvents[i], inputdev->keybit);\n\n\t\/*\n\t * Program the input device coordinate capacities. We do not yet\n\t * know what maximum X, Y, and Z values are, so we're putting fake\n\t * values in. Later, we'll ask the tablet to put in the correct\n\t * values.\n\t *\/\n\tinput_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n \tinput_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n \tinput_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);\n \n \tendpoint = &intf->altsetting[0].endpoint[0].desc;\n \n \t\/* Go set up our URB, which is called when the tablet receives\n\t * input.\n\t *\/\n\tusb_fill_int_urb(aiptek->urb,\n\t\t\t aiptek->usbdev,\n\t\t\t usb_rcvintpipe(aiptek->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t aiptek->data, 8, aiptek_irq, aiptek,\n\t\t\t endpoint->bInterval);\n\n\taiptek->urb->transfer_dma = aiptek->data_dma;\n\taiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\/* Program the tablet. This sets the tablet up in the mode\n\t * specified in newSetting, and also queries the tablet's\n\t * physical capacities.\n\t *\n\t * Sanity check: if a tablet doesn't like the slow programmatic\n\t * delay, we often get sizes of 0x0. Let's use that as an indicator\n\t * to try faster delays, up to 25 ms. If that logic fails, well, you'll\n\t * have to explain to us how your tablet thinks it's 0x0, and yet that's\n\t * not an error :-)\n\t *\/\n\n\tfor (i = 0; i < ARRAY_SIZE(speeds); ++i) {\n\t\taiptek->curSetting.programmableDelay = speeds[i];\n\t\t(void)aiptek_program_tablet(aiptek);\n\t\tif (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) {\n\t\t\tdev_info(&intf->dev,\n\t\t\t\t \"Aiptek using %d ms programming speed\\n\",\n\t\t\t\t aiptek->curSetting.programmableDelay);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\/* Murphy says that some day someone will have a tablet that fails the\n\t   above test. That's you, Frederic Rodrigo *\/\n \tif (i == ARRAY_SIZE(speeds)) {\n \t\tdev_info(&intf->dev,\n \t\t\t \"Aiptek tried all speeds, no sane response\\n\");\n \t\tgoto fail3;\n \t}\n \n\t\/* Associate this driver's struct with the usb interface.\n\t *\/\n\tusb_set_intfdata(intf, aiptek);\n\n\t\/* Set up the sysfs files\n\t *\/\n\terr = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);\n\tif (err) {\n\t\tdev_warn(&intf->dev, \"cannot create sysfs group err: %d\\n\",\n\t\t\t err);\n\t\tgoto fail3;\n        }\n\n\t\/* Register the tablet as an Input Device\n\t *\/\n\terr = input_register_device(aiptek->inputdev);\n\tif (err) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"input_register_device returned err: %d\\n\", err);\n\t\tgoto fail4;\n        }\n\treturn 0;\n\n fail4:\tsysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);\n fail3: usb_free_urb(aiptek->urb);\n fail2:\tusb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,\n\t\t\t  aiptek->data_dma);\n fail1: usb_set_intfdata(intf, NULL);\n\tinput_free_device(inputdev);\n\tkfree(aiptek);\n\treturn err;\n}\n","idx":180731,"target":1}
{"code":"print_syscall_ret(int num, abi_long ret)\n\n{\n\n    int i;\n\n\n\n    for(i=0;i<nsyscalls;i++)\n\n        if( scnames[i].nr == num ) {\n\n            if( scnames[i].result != NULL ) {\n\n                scnames[i].result(&scnames[i],ret);\n\n            } else {\n\n                if( ret < 0 ) {\n\n                    gemu_log(\" = -1 errno=\" TARGET_ABI_FMT_ld \" (%s)\\n\", -ret, target_strerror(-ret));\n\n                } else {\n\n                    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n                }\n\n            }\n\n            break;\n\n        }\n\n}\n","idx":10957,"target":1}
{"code":"xsltAddTemplate(xsltStylesheetPtr style, xsltTemplatePtr cur,\n\t        const xmlChar *mode, const xmlChar *modeURI) {\n    xsltCompMatchPtr pat, list, next;\n    \/*\n     * 'top' will point to style->xxxMatch ptr - declaring as 'void'\n     *  avoids gcc 'type-punned pointer' warning.\n     *\/\n    void **top = NULL;\n     const xmlChar *name = NULL;\n     float priority;              \/* the priority *\/\n \n    if ((style == NULL) || (cur == NULL) || (cur->match == NULL))\n \treturn(-1);\n \n     priority = cur->priority;\n     pat = xsltCompilePatternInternal(cur->match, style->doc, cur->elem,\n \t\t    style, NULL, 1);\n    if (pat == NULL)\n\treturn(-1);\n    while (pat) {\n\tnext = pat->next;\n\tpat->next = NULL;\n\tname = NULL;\n\n\tpat->template = cur;\n\tif (mode != NULL)\n\t    pat->mode = xmlDictLookup(style->dict, mode, -1);\n\tif (modeURI != NULL)\n\t    pat->modeURI = xmlDictLookup(style->dict, modeURI, -1);\n\tif (priority != XSLT_PAT_NO_PRIORITY)\n\t    pat->priority = priority;\n\n\t\/*\n\t * insert it in the hash table list corresponding to its lookup name\n\t *\/\n\tswitch (pat->steps[0].op) {\n        case XSLT_OP_ATTR:\n\t    if (pat->steps[0].value != NULL)\n\t\tname = pat->steps[0].value;\n\t    else\n\t\ttop = &(style->attrMatch);\n\t    break;\n        case XSLT_OP_PARENT:\n        case XSLT_OP_ANCESTOR:\n\t    top = &(style->elemMatch);\n\t    break;\n        case XSLT_OP_ROOT:\n\t    top = &(style->rootMatch);\n\t    break;\n        case XSLT_OP_KEY:\n\t    top = &(style->keyMatch);\n\t    break;\n        case XSLT_OP_ID:\n\t    \/* TODO optimize ID !!! *\/\n        case XSLT_OP_NS:\n        case XSLT_OP_ALL:\n\t    top = &(style->elemMatch);\n\t    break;\n        case XSLT_OP_END:\n\tcase XSLT_OP_PREDICATE:\n\t    xsltTransformError(NULL, style, NULL,\n\t\t\t     \"xsltAddTemplate: invalid compiled pattern\\n\");\n\t    xsltFreeCompMatch(pat);\n\t    return(-1);\n\t    \/*\n\t     * TODO: some flags at the top level about type based patterns\n\t     *       would be faster than inclusion in the hash table.\n\t     *\/\n\tcase XSLT_OP_PI:\n\t    if (pat->steps[0].value != NULL)\n\t\tname = pat->steps[0].value;\n\t    else\n\t\ttop = &(style->piMatch);\n\t    break;\n\tcase XSLT_OP_COMMENT:\n\t    top = &(style->commentMatch);\n\t    break;\n\tcase XSLT_OP_TEXT:\n\t    top = &(style->textMatch);\n\t    break;\n        case XSLT_OP_ELEM:\n\tcase XSLT_OP_NODE:\n\t    if (pat->steps[0].value != NULL)\n\t\tname = pat->steps[0].value;\n\t    else\n\t\ttop = &(style->elemMatch);\n\t    break;\n\t}\n\tif (name != NULL) {\n\t    if (style->templatesHash == NULL) {\n\t\tstyle->templatesHash = xmlHashCreate(1024);\n\t\tif (style->templatesHash == NULL) {\n\t\t    xsltFreeCompMatch(pat);\n\t\t    return(-1);\n\t\t}\n\t\txmlHashAddEntry3(style->templatesHash, name, mode, modeURI, pat);\n\t    } else {\n\t\tlist = (xsltCompMatchPtr) xmlHashLookup3(style->templatesHash,\n\t\t\t\t\t\t\t name, mode, modeURI);\n\t\tif (list == NULL) {\n\t\t    xmlHashAddEntry3(style->templatesHash, name,\n\t\t\t\t     mode, modeURI, pat);\n\t\t} else {\n\t\t    \/*\n\t\t     * Note '<=' since one must choose among the matching\n\t\t     * template rules that are left, the one that occurs\n\t\t     * last in the stylesheet\n\t\t     *\/\n\t\t    if (list->priority <= pat->priority) {\n\t\t\tpat->next = list;\n\t\t\txmlHashUpdateEntry3(style->templatesHash, name,\n\t\t\t\t\t    mode, modeURI, pat, NULL);\n\t\t    } else {\n\t\t\twhile (list->next != NULL) {\n\t\t\t    if (list->next->priority <= pat->priority)\n\t\t\t\tbreak;\n\t\t\t    list = list->next;\n\t\t\t}\n\t\t\tpat->next = list->next;\n\t\t\tlist->next = pat;\n\t\t    }\n\t\t}\n\t    }\n\t} else if (top != NULL) {\n\t    list = *top;\n\t    if (list == NULL) {\n\t\t*top = pat;\n\t\tpat->next = NULL;\n\t    } else if (list->priority <= pat->priority) {\n\t\tpat->next = list;\n\t\t*top = pat;\n\t    } else {\n\t\twhile (list->next != NULL) {\n\t\t    if (list->next->priority <= pat->priority)\n\t\t\tbreak;\n\t\t    list = list->next;\n\t\t}\n\t\tpat->next = list->next;\n\t\tlist->next = pat;\n\t    }\n\t} else {\n\t    xsltTransformError(NULL, style, NULL,\n\t\t\t     \"xsltAddTemplate: invalid compiled pattern\\n\");\n\t    xsltFreeCompMatch(pat);\n\t    return(-1);\n\t}\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\tif (mode)\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"added pattern : '%s' mode '%s' priority %f\\n\",\n\t\t\t     pat->pattern, pat->mode, pat->priority);\n\telse\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"added pattern : '%s' priority %f\\n\",\n\t\t\t     pat->pattern, pat->priority);\n#endif\n\n\tpat = next;\n    }\n    return(0);\n}\n","idx":187332,"target":1}
{"code":"void ZLIB_INTERNAL inflate_fast(strm, start)\nz_streamp strm;\nunsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *in;      \/* local strm->next_in *\/\n    z_const unsigned char FAR *last;    \/* have enough input while in < last *\/\n    unsigned char FAR *out;     \/* local strm->next_out *\/\n    unsigned char FAR *beg;     \/* inflate()'s initial strm->next_out *\/\n    unsigned char FAR *end;     \/* while out < end, enough space available *\/\n#ifdef INFLATE_STRICT\n    unsigned dmax;              \/* maximum distance from zlib header *\/\n#endif\n    unsigned wsize;             \/* window size or zero if not using window *\/\n    unsigned whave;             \/* valid bytes in the window *\/\n    unsigned wnext;             \/* window write index *\/\n    unsigned char FAR *window;  \/* allocated sliding window, if wsize != 0 *\/\n    unsigned long hold;         \/* local strm->hold *\/\n    unsigned bits;              \/* local strm->bits *\/\n    code const FAR *lcode;      \/* local strm->lencode *\/\n    code const FAR *dcode;      \/* local strm->distcode *\/\n    unsigned lmask;             \/* mask for first level of length codes *\/\n    unsigned dmask;             \/* mask for first level of distance codes *\/\n    code here;                  \/* retrieved table entry *\/\n    unsigned op;                \/* code bits, operation, extra bits, or *\/\n                                \/*  window position, window bytes to copy *\/\n    unsigned len;               \/* match length, unused bytes *\/\n    unsigned dist;              \/* match distance *\/\n    unsigned char FAR *from;    \/* where to copy match from *\/\n \n     \/* copy state to local variables *\/\n     state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in - OFF;\n     last = in + (strm->avail_in - 5);\n    out = strm->next_out - OFF;\n     beg = out - (start - strm->avail_out);\n     end = out + (strm->avail_out - 257);\n #ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    \/* decode literals and length\/distances until end-of-block or not enough\n        input data or output space *\/\n     do {\n         if (bits < 15) {\n            hold += (unsigned long)(PUP(in)) << bits;\n             bits += 8;\n            hold += (unsigned long)(PUP(in)) << bits;\n             bits += 8;\n         }\n         here = lcode[hold & lmask];\n      dolen:\n        op = (unsigned)(here.bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here.op);\n        if (op == 0) {                          \/* literal *\/\n             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                     \"inflate:         literal '%c'\\n\" :\n                     \"inflate:         literal 0x%02x\\n\", here.val));\n            PUP(out) = (unsigned char)(here.val);\n         }\n         else if (op & 16) {                     \/* length base *\/\n             len = (unsigned)(here.val);\n             op &= 15;                           \/* number of extra bits *\/\n             if (op) {\n                 if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                     bits += 8;\n                 }\n                 len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n             }\n             Tracevv((stderr, \"inflate:         length %u\\n\", len));\n             if (bits < 15) {\n                hold += (unsigned long)(PUP(in)) << bits;\n                 bits += 8;\n                hold += (unsigned long)(PUP(in)) << bits;\n                 bits += 8;\n             }\n             here = dcode[hold & dmask];\n          dodist:\n            op = (unsigned)(here.bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here.op);\n            if (op & 16) {                      \/* distance base *\/\n                 dist = (unsigned)(here.val);\n                 op &= 15;                       \/* number of extra bits *\/\n                 if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                     bits += 8;\n                     if (bits < op) {\n                        hold += (unsigned long)(PUP(in)) << bits;\n                         bits += 8;\n                     }\n                 }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     \/* max distance in output *\/\n                if (dist > op) {                \/* see if copy from window *\/\n                    op = dist - op;             \/* distance back in window *\/\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                         if (len <= op - whave) {\n                             do {\n                                PUP(out) = 0;\n                             } while (--len);\n                             continue;\n                         }\n                         len -= op - whave;\n                         do {\n                            PUP(out) = 0;\n                         } while (--op > whave);\n                         if (op == 0) {\n                             from = out - dist;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--len);\n                             continue;\n                         }\n #endif\n                     }\n                    from = window - OFF;\n                     if (wnext == 0) {           \/* very common case *\/\n                         from += wsize - op;\n                         if (op < len) {         \/* some from window *\/\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                             from = out - dist;  \/* rest from output *\/\n                         }\n                    }\n                    else if (wnext < op) {      \/* wrap around window *\/\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                         if (op < len) {         \/* some from end of window *\/\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                            from = window - OFF;\n                             if (wnext < len) {  \/* some from start of window *\/\n                                 op = wnext;\n                                 len -= op;\n                                 do {\n                                    PUP(out) = PUP(from);\n                                 } while (--op);\n                                 from = out - dist;      \/* rest from output *\/\n                             }\n                        }\n                    }\n                    else {                      \/* contiguous in window *\/\n                        from += wnext - op;\n                         if (op < len) {         \/* some from window *\/\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                             from = out - dist;  \/* rest from output *\/\n                         }\n                     }\n                     while (len > 2) {\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                         len -= 3;\n                     }\n                     if (len) {\n                        PUP(out) = PUP(from);\n                         if (len > 1)\n                            PUP(out) = PUP(from);\n                     }\n                 }\n                 else {\n                     from = out - dist;          \/* copy direct from output *\/\n                     do {                        \/* minimum length is three *\/\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                         len -= 3;\n                     } while (len > 2);\n                     if (len) {\n                        PUP(out) = PUP(from);\n                         if (len > 1)\n                            PUP(out) = PUP(from);\n                     }\n                 }\n             }\n            else if ((op & 64) == 0) {          \/* 2nd level distance code *\/\n                here = dcode[here.val + (hold & ((1U << op) - 1))];\n                goto dodist;\n            }\n            else {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              \/* 2nd level length code *\/\n            here = lcode[here.val + (hold & ((1U << op) - 1))];\n            goto dolen;\n        }\n        else if (op & 32) {                     \/* end-of-block *\/\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (char *)\"invalid literal\/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    \/* return unused bytes (on entry, bits < 8, so in won't go too far back) *\/\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n     hold &= (1U << bits) - 1;\n \n     \/* update state and return *\/\n    strm->next_in = in + OFF;\n    strm->next_out = out + OFF;\n     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n     strm->avail_out = (unsigned)(out < end ?\n                                  257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n","idx":181846,"target":1}
{"code":"deinterlace_row(png_bytep buffer, png_const_bytep row,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   \/* The inverse of the above, 'row' is part of row 'y' of the output image,\n    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute\n    * the pixels of row into buffer and return the number written (to allow\n    * this to be checked).\n    *\/\n   png_uint_32 xin, xout, xstep;\n   xout = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xin=0; xout<w; xout+=xstep)\n   {\n      pixel_copy(buffer, xout, row, xin, pixel_size);\n      ++xin;\n   }\n}\n","idx":187629,"target":1}
{"code":"void gd_egl_scanout(DisplayChangeListener *dcl,\n\n                    uint32_t backing_id, bool backing_y_0_top,\n\n\n                    uint32_t x, uint32_t y,\n\n                    uint32_t w, uint32_t h)\n\n{\n\n    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);\n\n\n\n    vc->gfx.x = x;\n\n    vc->gfx.y = y;\n\n    vc->gfx.w = w;\n\n    vc->gfx.h = h;\n\n    vc->gfx.tex_id = backing_id;\n\n    vc->gfx.y0_top = backing_y_0_top;\n\n\n\n    eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,\n\n                   vc->gfx.esurface, vc->gfx.ectx);\n\n\n\n    if (vc->gfx.tex_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {\n\n        gtk_egl_set_scanout_mode(vc, false);\n\n        return;\n\n    }\n\n\n\n    gtk_egl_set_scanout_mode(vc, true);\n\n    if (!vc->gfx.fbo_id) {\n\n        glGenFramebuffers(1, &vc->gfx.fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, vc->gfx.fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, vc->gfx.tex_id, 0);\n\n}","idx":6457,"target":1}
{"code":"static int v4l2_read_header(AVFormatContext *s1)\n\n{\n\n    struct video_data *s = s1->priv_data;\n\n    AVStream *st;\n\n    int res = 0;\n\n    uint32_t desired_format;\n\n    enum AVCodecID codec_id = AV_CODEC_ID_NONE;\n\n    enum AVPixelFormat pix_fmt = AV_PIX_FMT_NONE;\n\n    struct v4l2_input input = { 0 };\n\n\n\n    st = avformat_new_stream(s1, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n#if CONFIG_LIBV4L2\n\n    \/* silence libv4l2 logging. if fopen() fails v4l2_log_file will be NULL\n\n       and errors will get sent to stderr *\/\n\n    v4l2_log_file = fopen(\"\/dev\/null\", \"w\");\n\n#endif\n\n\n\n    s->fd = device_open(s1);\n\n    if (s->fd < 0)\n\n        return s->fd;\n\n\n\n    if (s->channel != -1) {\n\n        \/* set video input *\/\n\n        av_log(s1, AV_LOG_DEBUG, \"Selecting input_channel: %d\\n\", s->channel);\n\n        if (v4l2_ioctl(s->fd, VIDIOC_S_INPUT, &s->channel) < 0) {\n\n            res = AVERROR(errno);\n\n            av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_S_INPUT): %s\\n\", av_err2str(res));\n\n            return res;\n\n        }\n\n    } else {\n\n        \/* get current video input *\/\n\n        if (v4l2_ioctl(s->fd, VIDIOC_G_INPUT, &s->channel) < 0) {\n\n            res = AVERROR(errno);\n\n            av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_G_INPUT): %s\\n\", av_err2str(res));\n\n            return res;\n\n        }\n\n    }\n\n\n\n    \/* enum input *\/\n\n    input.index = s->channel;\n\n    if (v4l2_ioctl(s->fd, VIDIOC_ENUMINPUT, &input) < 0) {\n\n        res = AVERROR(errno);\n\n        av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_ENUMINPUT): %s\\n\", av_err2str(res));\n\n        return res;\n\n    }\n\n    s->std_id = input.std;\n\n    av_log(s1, AV_LOG_DEBUG, \"Current input_channel: %d, input_name: %s\\n\",\n\n           s->channel, input.name);\n\n\n\n    if (s->list_format) {\n\n        list_formats(s1, s->fd, s->list_format);\n\n        return AVERROR_EXIT;\n\n    }\n\n\n\n    if (s->list_standard) {\n\n        list_standards(s1);\n\n        return AVERROR_EXIT;\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000000); \/* 64 bits pts in us *\/\n\n\n\n    if (s->pixel_format) {\n\n        AVCodec *codec = avcodec_find_decoder_by_name(s->pixel_format);\n\n\n\n        if (codec)\n\n            s1->video_codec_id = codec->id;\n\n\n\n        pix_fmt = av_get_pix_fmt(s->pixel_format);\n\n\n\n        if (pix_fmt == AV_PIX_FMT_NONE && !codec) {\n\n            av_log(s1, AV_LOG_ERROR, \"No such input format: %s.\\n\",\n\n                   s->pixel_format);\n\n\n\n            return AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    if (!s->width && !s->height) {\n\n        struct v4l2_format fmt;\n\n\n\n        av_log(s1, AV_LOG_VERBOSE,\n\n               \"Querying the device for the current frame size\\n\");\n\n        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n        if (v4l2_ioctl(s->fd, VIDIOC_G_FMT, &fmt) < 0) {\n\n            res = AVERROR(errno);\n\n            av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_G_FMT): %s\\n\", av_err2str(res));\n\n            return res;\n\n        }\n\n\n\n        s->width  = fmt.fmt.pix.width;\n\n        s->height = fmt.fmt.pix.height;\n\n        av_log(s1, AV_LOG_VERBOSE,\n\n               \"Setting frame size to %dx%d\\n\", s->width, s->height);\n\n    }\n\n\n\n    res = device_try_init(s1, pix_fmt, &s->width, &s->height, &desired_format, &codec_id);\n\n    if (res < 0) {\n\n        v4l2_close(s->fd);\n\n        return res;\n\n    }\n\n\n\n    \/* If no pixel_format was specified, the codec_id was not known up\n\n     * until now. Set video_codec_id in the context, as codec_id will\n\n     * not be available outside this function\n\n     *\/\n\n    if (codec_id != AV_CODEC_ID_NONE && s1->video_codec_id == AV_CODEC_ID_NONE)\n\n        s1->video_codec_id = codec_id;\n\n\n\n    if ((res = av_image_check_size(s->width, s->height, 0, s1)) < 0)\n\n        return res;\n\n\n\n    s->frame_format = desired_format;\n\n\n\n    if ((res = v4l2_set_parameters(s1)) < 0)\n\n        return res;\n\n\n\n    st->codec->pix_fmt = fmt_v4l2ff(desired_format, codec_id);\n\n    s->frame_size =\n\n        avpicture_get_size(st->codec->pix_fmt, s->width, s->height);\n\n\n\n    if ((res = mmap_init(s1)) ||\n\n        (res = mmap_start(s1)) < 0) {\n\n        v4l2_close(s->fd);\n\n        return res;\n\n    }\n\n\n\n    s->top_field_first = first_field(s->fd);\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = codec_id;\n\n    if (codec_id == AV_CODEC_ID_RAWVIDEO)\n\n        st->codec->codec_tag =\n\n            avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);\n\n    if (desired_format == V4L2_PIX_FMT_YVU420)\n\n        st->codec->codec_tag = MKTAG('Y', 'V', '1', '2');\n\n    else if (desired_format == V4L2_PIX_FMT_YVU410)\n\n        st->codec->codec_tag = MKTAG('Y', 'V', 'U', '9');\n\n    st->codec->width = s->width;\n\n    st->codec->height = s->height;\n\n    st->codec->bit_rate = s->frame_size * av_q2d(st->avg_frame_rate) * 8;\n\n\n\n    return 0;\n\n}\n","idx":17881,"target":1}
{"code":"apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t\/* Enable checks for parsed files *\/\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t\/* print silly verbose header for USG compat. *\/\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t\/* load directory or file *\/\n\t\/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. *\/\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s\/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n                                if ((filearr = CAST(char **,\n                                    erealloc(filearr, mlen))) == NULL) {\n                                        file_oomem(ms, mlen);\n                                       efree(mfn);\n                                        php_stream_closedir(dir);\n                                        errs++;\n                                        goto out;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\/* Set types of tests *\/\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t\/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t *\/\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t\/* coalesce per file arrays into a single one *\/\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}\n","idx":178054,"target":1}
{"code":"static void ptrace_hbptriggered(struct perf_event *bp, int unused,\n \t\t\t\t     struct perf_sample_data *data,\n \t\t\t\t     struct pt_regs *regs)\n {\n\tstruct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);\n\tlong num;\n\tint i;\n\tsiginfo_t info;\n\n\tfor (i = 0; i < ARM_MAX_HBP_SLOTS; ++i)\n\t\tif (current->thread.debug.hbp[i] == bp)\n\t\t\tbreak;\n\n\tnum = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i);\n\n\tinfo.si_signo\t= SIGTRAP;\n\tinfo.si_errno\t= (int)num;\n\tinfo.si_code\t= TRAP_HWBKPT;\n\tinfo.si_addr\t= (void __user *)(bkpt->trigger);\n\n\tforce_sig_info(SIGTRAP, &info, current);\n}\n","idx":178949,"target":1}
{"code":"int do_mathemu(struct pt_regs *regs, struct task_struct *fpt)\n{\n\t\/* regs->pc isn't necessarily the PC at which the offending insn is sitting.\n\t * The FPU maintains a queue of FPops which cause traps.\n\t * When it hits an instruction that requires that the trapped op succeeded\n\t * (usually because it reads a reg. that the trapped op wrote) then it\n\t * causes this exception. We need to emulate all the insns on the queue\n\t * and then allow the op to proceed.\n\t * This code should also handle the case where the trap was precise,\n\t * in which case the queue length is zero and regs->pc points at the\n\t * single FPop to be emulated. (this case is untested, though :->)\n\t * You'll need this case if you want to be able to emulate all FPops\n\t * because the FPU either doesn't exist or has been software-disabled.\n\t * [The UltraSPARC makes FP a precise trap; this isn't as stupid as it\n\t * might sound because the Ultra does funky things with a superscalar\n\t * architecture.]\n\t *\/\n\n\t\/* You wouldn't believe how often I typed 'ftp' when I meant 'fpt' :-> *\/\n\n\tint i;\n \tint retcode = 0;                               \/* assume all succeed *\/\n \tunsigned long insn;\n \n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n \n #ifdef DEBUG_MATHEMU\n \tprintk(\"In do_mathemu()... pc is %08lx\\n\", regs->pc);\n\tprintk(\"fpqdepth is %ld\\n\", fpt->thread.fpqdepth);\n\tfor (i = 0; i < fpt->thread.fpqdepth; i++)\n\t\tprintk(\"%d: %08lx at %08lx\\n\", i, fpt->thread.fpqueue[i].insn,\n\t\t       (unsigned long)fpt->thread.fpqueue[i].insn_addr);\n#endif\n\n\tif (fpt->thread.fpqdepth == 0) {                   \/* no queue, guilty insn is at regs->pc *\/\n#ifdef DEBUG_MATHEMU\n\t\tprintk(\"precise trap at %08lx\\n\", regs->pc);\n#endif\n\t\tif (!get_user(insn, (u32 __user *) regs->pc)) {\n\t\t\tretcode = do_one_mathemu(insn, &fpt->thread.fsr, fpt->thread.float_regs);\n\t\t\tif (retcode) {\n\t\t\t\t\/* in this case we need to fix up PC & nPC *\/\n\t\t\t\tregs->pc = regs->npc;\n\t\t\t\tregs->npc += 4;\n\t\t\t}\n\t\t}\n\t\treturn retcode;\n\t}\n\n\t\/* Normal case: need to empty the queue... *\/\n\tfor (i = 0; i < fpt->thread.fpqdepth; i++) {\n\t\tretcode = do_one_mathemu(fpt->thread.fpqueue[i].insn, &(fpt->thread.fsr), fpt->thread.float_regs);\n\t\tif (!retcode)                               \/* insn failed, no point doing any more *\/\n\t\t\tbreak;\n\t}\n\t\/* Now empty the queue and clear the queue_not_empty flag *\/\n\tif (retcode)\n\t\tfpt->thread.fsr &= ~(0x3000 | FSR_CEXC_MASK);\n\telse\n\t\tfpt->thread.fsr &= ~0x3000;\n\tfpt->thread.fpqdepth = 0;\n\n\treturn retcode;\n}\n","idx":178986,"target":1}
{"code":"static int mov_text_decode_close(AVCodecContext *avctx)\n\n{\n\n    MovTextContext *m = avctx->priv_data;\n\n    mov_text_cleanup_ftab(m);\n\n\n    return 0;\n\n}","idx":639,"target":1}
{"code":"static void decode_plane(FFV1Context *s, uint8_t *src,\n\n                         int w, int h, int stride, int plane_index,\n\n                         int pixel_stride)\n\n{\n\n    int x, y;\n\n    int16_t *sample[2];\n\n    sample[0] = s->sample_buffer + 3;\n\n    sample[1] = s->sample_buffer + w + 6 + 3;\n\n\n\n    s->run_index = 0;\n\n\n\n    memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));\n\n\n\n    for (y = 0; y < h; y++) {\n\n        int16_t *temp = sample[0]; \/\/ FIXME: try a normal buffer\n\n\n\n        sample[0] = sample[1];\n\n        sample[1] = temp;\n\n\n\n        sample[1][-1] = sample[0][0];\n\n        sample[0][w]  = sample[0][w - 1];\n\n\n\n\/\/ { START_TIMER\n\n        if (s->avctx->bits_per_raw_sample <= 8) {\n\n            decode_line(s, w, sample, plane_index, 8);\n\n            for (x = 0; x < w; x++)\n\n                src[x*pixel_stride + stride * y] = sample[1][x];\n\n        } else {\n\n            decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);\n\n            if (s->packed_at_lsb) {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x];\n\n                }\n\n            } else {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample) | ((uint16_t **)sample)[1][x] >> (2 * s->avctx->bits_per_raw_sample - 16);\n\n                }\n\n            }\n\n        }\n\n\/\/ STOP_TIMER(\"decode-line\") }\n\n    }\n\n}\n","idx":8200,"target":1}
{"code":"setup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n     kdc_realm_t         *newrealm;\n \n     kret = 0;\n     if (kdc_numrealms > 1) {\n         if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                          (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}\n","idx":179105,"target":1}
{"code":"static int reap_filters(void)\n\n{\n\n    AVFilterBufferRef *picref;\n\n    AVFrame *filtered_frame = NULL;\n\n    int i;\n\n    int64_t frame_pts;\n\n\n\n    \/* Reap all buffers present in the buffer sinks *\/\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n        OutputFile    *of = output_files[ost->file_index];\n\n        int ret = 0;\n\n\n\n        if (!ost->filter)\n\n            continue;\n\n\n\n        if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n\n            return AVERROR(ENOMEM);\n\n        } else\n\n            avcodec_get_frame_defaults(ost->filtered_frame);\n\n        filtered_frame = ost->filtered_frame;\n\n\n\n        while (1) {\n\n            ret = av_buffersink_get_buffer_ref(ost->filter->filter, &picref,\n\n                                               AV_BUFFERSINK_FLAG_NO_REQUEST);\n\n            if (ret < 0) {\n\n                if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF) {\n\n                    char buf[256];\n\n                    av_strerror(ret, buf, sizeof(buf));\n\n                    av_log(NULL, AV_LOG_WARNING,\n\n                           \"Error in av_buffersink_get_buffer_ref(): %s\\n\", buf);\n\n\n\n\n            frame_pts = AV_NOPTS_VALUE;\n\n            if (picref->pts != AV_NOPTS_VALUE) {\n\n                filtered_frame->pts = frame_pts = av_rescale_q(picref->pts,\n\n                                                ost->filter->filter->inputs[0]->time_base,\n\n                                                ost->st->codec->time_base) -\n\n                                    av_rescale_q(of->start_time,\n\n                                                AV_TIME_BASE_Q,\n\n                                                ost->st->codec->time_base);\n\n\n\n                if (of->start_time && filtered_frame->pts < 0) {\n\n                    avfilter_unref_buffer(picref);\n\n                    continue;\n\n\n\n            \/\/if (ost->source_index >= 0)\n\n            \/\/    *filtered_frame= *input_streams[ost->source_index]->decoded_frame; \/\/for me_threshold\n\n\n\n\n\n            switch (ost->filter->filter->inputs[0]->type) {\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                avfilter_copy_buf_props(filtered_frame, picref);\n\n                filtered_frame->pts = frame_pts;\n\n                if (!ost->frame_aspect_ratio)\n\n                    ost->st->codec->sample_aspect_ratio = picref->video->sample_aspect_ratio;\n\n\n\n                do_video_out(of->ctx, ost, filtered_frame);\n\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                avfilter_copy_buf_props(filtered_frame, picref);\n\n                filtered_frame->pts = frame_pts;\n\n\n\n\n\n\n\n                do_audio_out(of->ctx, ost, filtered_frame);\n\n\n            default:\n\n                \/\/ TODO support subtitle filters\n\n                av_assert0(0);\n\n\n\n\n            avfilter_unref_buffer(picref);\n\n\n\n\n\n    return 0;\n","idx":26140,"target":1}
{"code":"static int film_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char scratch[256];\n\n    int i;\n\n    unsigned int data_offset;\n\n    unsigned int audio_frame_counter;\n\n\n\n    film->sample_table = NULL;\n\n    film->stereo_buffer = NULL;\n\n    film->stereo_buffer_size = 0;\n\n\n\n    \/* load the main FILM header *\/\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    data_offset = AV_RB32(&scratch[4]);\n\n    film->version = AV_RB32(&scratch[8]);\n\n\n\n    \/* load the FDSC chunk *\/\n\n    if (film->version == 0) {\n\n        \/* special case for Lemmings .film files; 20-byte header *\/\n\n        if (avio_read(pb, scratch, 20) != 20)\n\n            return AVERROR(EIO);\n\n        \/* make some assumptions about the audio parameters *\/\n\n        film->audio_type = CODEC_ID_PCM_S8;\n\n        film->audio_samplerate = 22050;\n\n        film->audio_channels = 1;\n\n        film->audio_bits = 8;\n\n    } else {\n\n        \/* normal Saturn .cpk files; 32-byte header *\/\n\n        if (avio_read(pb, scratch, 32) != 32)\n\n            return AVERROR(EIO);\n\n        film->audio_samplerate = AV_RB16(&scratch[24]);\n\n        film->audio_channels = scratch[21];\n\n        film->audio_bits = scratch[22];\n\n        if (scratch[23] == 2)\n\n            film->audio_type = CODEC_ID_ADPCM_ADX;\n\n        else if (film->audio_bits == 8)\n\n            film->audio_type = CODEC_ID_PCM_S8;\n\n        else if (film->audio_bits == 16)\n\n            film->audio_type = CODEC_ID_PCM_S16BE;\n\n        else\n\n            film->audio_type = CODEC_ID_NONE;\n\n    }\n\n\n\n    if (AV_RB32(&scratch[0]) != FDSC_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (AV_RB32(&scratch[8]) == CVID_TAG) {\n\n        film->video_type = CODEC_ID_CINEPAK;\n\n    } else\n\n        film->video_type = CODEC_ID_NONE;\n\n\n\n    \/* initialize the decoder streams *\/\n\n    if (film->video_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->video_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id = film->video_type;\n\n        st->codec->codec_tag = 0;  \/* no fourcc *\/\n\n        st->codec->width = AV_RB32(&scratch[16]);\n\n        st->codec->height = AV_RB32(&scratch[12]);\n\n    }\n\n\n\n    if (film->audio_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->audio_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = film->audio_type;\n\n        st->codec->codec_tag = 1;\n\n        st->codec->channels = film->audio_channels;\n\n        st->codec->sample_rate = film->audio_samplerate;\n\n\n\n        if (film->audio_type == CODEC_ID_ADPCM_ADX) {\n\n            st->codec->bits_per_coded_sample = 18 * 8 \/ 32;\n\n            st->codec->block_align = st->codec->channels * 18;\n\n        } else {\n\n            st->codec->bits_per_coded_sample = film->audio_bits;\n\n            st->codec->block_align = st->codec->channels *\n\n                st->codec->bits_per_coded_sample \/ 8;\n\n        }\n\n\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample;\n\n    }\n\n\n\n    \/* load the sample table *\/\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    if (AV_RB32(&scratch[0]) != STAB_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n    film->base_clock = AV_RB32(&scratch[8]);\n\n    film->sample_count = AV_RB32(&scratch[12]);\n\n    if(film->sample_count >= UINT_MAX \/ sizeof(film_sample))\n\n        return -1;\n\n    film->sample_table = av_malloc(film->sample_count * sizeof(film_sample));\n\n    if (!film->sample_table)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_set_pts_info(s->streams[i], 33, 1, film->base_clock);\n\n\n\n    audio_frame_counter = 0;\n\n    for (i = 0; i < film->sample_count; i++) {\n\n        \/* load the next sample record and transfer it to an internal struct *\/\n\n        if (avio_read(pb, scratch, 16) != 16) {\n\n            av_free(film->sample_table);\n\n            return AVERROR(EIO);\n\n        }\n\n        film->sample_table[i].sample_offset =\n\n            data_offset + AV_RB32(&scratch[0]);\n\n        film->sample_table[i].sample_size = AV_RB32(&scratch[4]);\n\n        if (AV_RB32(&scratch[8]) == 0xFFFFFFFF) {\n\n            film->sample_table[i].stream = film->audio_stream_index;\n\n            film->sample_table[i].pts = audio_frame_counter;\n\n            film->sample_table[i].pts *= film->base_clock;\n\n            film->sample_table[i].pts \/= film->audio_samplerate;\n\n\n\n            if (film->audio_type == CODEC_ID_ADPCM_ADX)\n\n                audio_frame_counter += (film->sample_table[i].sample_size * 32 \/\n\n                    (18 * film->audio_channels));\n\n            else\n\n                audio_frame_counter += (film->sample_table[i].sample_size \/\n\n                    (film->audio_channels * film->audio_bits \/ 8));\n\n        } else {\n\n            film->sample_table[i].stream = film->video_stream_index;\n\n            film->sample_table[i].pts = AV_RB32(&scratch[8]) & 0x7FFFFFFF;\n\n            film->sample_table[i].keyframe = (scratch[8] & 0x80) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    film->current_sample = 0;\n\n\n\n    return 0;\n\n}\n","idx":14612,"target":1}
{"code":"static int xan_huffman_decode(unsigned char *dest, int dest_len,\n\n                              const unsigned char *src, int src_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    int ptr_len = src_len - 1 - byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    if (ptr_len < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    init_get_bits(&gb, ptr, ptr_len * 8);\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest >= dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":5130,"target":1}
{"code":"static int ea_read_header(AVFormatContext *s,\n                          AVFormatParameters *ap)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVStream *st;\n    if (!process_ea_header(s))\n        return AVERROR(EIO);\n    if (ea->video_codec) {\n        \/* initialize the video decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        ea->video_stream_index = st->index;\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id = ea->video_codec;\n        st->codec->codec_tag = 0;  \/* no fourcc *\/\n        st->codec->time_base = ea->time_base;\n        st->codec->width = ea->width;\n        st->codec->height = ea->height;\n    if (ea->num_channels <= 0) {\n        av_log(s, AV_LOG_WARNING, \"Unsupported number of channels: %d\\n\", ea->num_channels);\n    if (ea->audio_codec) {\n        \/* initialize the audio decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        av_set_pts_info(st, 33, 1, ea->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_id = ea->audio_codec;\n        st->codec->codec_tag = 0;  \/* no tag *\/\n        st->codec->channels = ea->num_channels;\n        st->codec->sample_rate = ea->sample_rate;\n        st->codec->bits_per_coded_sample = ea->bytes * 8;\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n            st->codec->bits_per_coded_sample \/ 4;\n        st->codec->block_align = st->codec->channels*st->codec->bits_per_coded_sample;\n        ea->audio_stream_index = st->index;\n        ea->audio_frame_counter = 0;\n    return 1;","idx":7050,"target":1}
{"code":"static void s390_msi_ctrl_write(void *opaque, hwaddr addr, uint64_t data,\n\n                                unsigned int size)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    uint32_t io_int_word;\n\n    uint32_t fid = data >> ZPCI_MSI_VEC_BITS;\n\n    uint32_t vec = data & ZPCI_MSI_VEC_MASK;\n\n    uint64_t ind_bit;\n\n    uint32_t sum_bit;\n\n    uint32_t e = 0;\n\n\n\n    DPRINTF(\"write_msix data 0x%\" PRIx64 \" fid %d vec 0x%x\\n\", data, fid, vec);\n\n\n\n    pbdev = s390_pci_find_dev_by_fid(fid);\n\n    if (!pbdev) {\n\n        e |= (vec << ERR_EVENT_MVN_OFFSET);\n\n        s390_pci_generate_error_event(ERR_EVENT_NOMSI, 0, fid, addr, e);\n\n        return;\n\n    }\n\n\n\n    if (pbdev->state != ZPCI_FS_ENABLED) {\n\n        return;\n\n    }\n\n\n\n    ind_bit = pbdev->routes.adapter.ind_offset;\n\n    sum_bit = pbdev->routes.adapter.summary_offset;\n\n\n\n    set_ind_atomic(pbdev->routes.adapter.ind_addr + (ind_bit + vec) \/ 8,\n\n                   0x80 >> ((ind_bit + vec) % 8));\n\n    if (!set_ind_atomic(pbdev->routes.adapter.summary_addr + sum_bit \/ 8,\n\n                                       0x80 >> (sum_bit % 8))) {\n\n        io_int_word = (pbdev->isc << 27) | IO_INT_WORD_AI;\n\n        s390_io_interrupt(0, 0, 0, io_int_word);\n\n    }\n\n}\n","idx":2226,"target":1}
{"code":"int net_init_tap(const NetClientOptions *opts, const char *name,\n                 NetClientState *peer)\n{\n    const NetdevTapOptions *tap;\n    int fd, vnet_hdr = 0, i = 0, queues;\n    \/* for the no-fd, no-helper case *\/\n    const char *script = NULL; \/* suppress wrong \"uninit'd use\" gcc warning *\/\n    const char *downscript = NULL;\n    const char *vhostfdname;\n    char ifname[128];\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_TAP);\n    tap = opts->tap;\n    queues = tap->has_queues ? tap->queues : 1;\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n    if (tap->has_fd) {\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n            tap->has_fds) {\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n                         \"helper=, queues=, and fds= are invalid with fd=\");\n        fd = monitor_handle_fd_param(cur_mon, tap->fd);\n        if (fd == -1) {\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n        if (net_init_tap_one(tap, peer, \"tap\", name, NULL,\n                             script, downscript,\n                             vhostfdname, vnet_hdr, fd)) {\n    } else if (tap->has_fds) {\n        char *fds[MAX_TAP_QUEUES];\n        char *vhost_fds[MAX_TAP_QUEUES];\n        int nfds, nvhosts;\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n            tap->has_fd) {\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n                         \"helper=, queues=, and fd= are invalid with fds=\");\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n        if (tap->has_vhostfds) {\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n            if (nfds != nvhosts) {\n                error_report(\"The number of fds passed does not match the \"\n                             \"number of vhostfds passed\");\n        for (i = 0; i < nfds; i++) {\n            fd = monitor_handle_fd_param(cur_mon, fds[i]);\n            if (fd == -1) {\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n            if (i == 0) {\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n                error_report(\"vnet_hdr not consistent across given tap fds\");\n            if (net_init_tap_one(tap, peer, \"tap\", name, ifname,\n                                 script, downscript,\n                                 tap->has_vhostfds ? vhost_fds[i] : NULL,\n                                 vnet_hdr, fd)) {\n    } else if (tap->has_helper) {\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n            tap->has_vnet_hdr || tap->has_queues || tap->has_fds) {\n            error_report(\"ifname=, script=, downscript=, and vnet_hdr= \"\n                         \"queues=, and fds= are invalid with helper=\");\n        fd = net_bridge_run_helper(tap->helper, DEFAULT_BRIDGE_INTERFACE);\n        if (fd == -1) {\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n        if (net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n                             script, downscript, vhostfdname,\n                             vnet_hdr, fd)) {\n    } else {\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n        downscript = tap->has_downscript ? tap->downscript :\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n        if (tap->has_ifname) {\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n        } else {\n            ifname[0] = '\\0';\n        for (i = 0; i < queues; i++) {\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n                              ifname, sizeof ifname, queues > 1);\n            if (fd == -1) {\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n                if (tap_fd_get_ifname(fd, ifname)) {\n                    error_report(\"Fail to get ifname\");\n            if (net_init_tap_one(tap, peer, \"tap\", name, ifname,\n                                 i >= 1 ? \"no\" : script,\n                                 i >= 1 ? \"no\" : downscript,\n                                 vhostfdname, vnet_hdr, fd)) {\n    return 0;","idx":12272,"target":1}
{"code":"process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        \/* either this, or the server is printing bad messages,\n           or the caller passed in garbage *\/\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto chpwfail;\n     }\n \n     ptr = req->data;\n\n    \/* verify length *\/\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     \/* verify version number *\/\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n        goto chpwfail;\n     }\n \n     \/* read, check ap-req length *\/\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     \/* verify ap_req *\/\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin\/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* construct the ap-rep *\/\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* decrypt the ChangePasswdData *\/\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    \/*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     *\/\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    \/* decode ChangePasswdData for setpw requests *\/\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* for cpw, verify that this is an AS_REQ ticket *\/\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* change the password *\/\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    \/* zap the password *\/\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    \/* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. *\/\n\n    if (cipher.length == 0) {\n        \/* clear out ap_rep now, so that it won't be inserted in the\n           reply *\/\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        \/* this is really icky.  but it's what all the other callers\n           to mk_error do. *\/\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    \/* construct the reply *\/\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    \/* length *\/\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    \/* version == 0x0001 big-endian *\/\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    \/* ap_rep length, big-endian *\/\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    \/* ap-rep data *\/\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    \/* krb-priv or krb-error *\/\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n","idx":179407,"target":1}
{"code":" static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n {\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n }\n","idx":180738,"target":1}
{"code":"static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)\n\n{\n\n    uint16_t data = addr;\n\n\n\n    memwrite(s->addr + OMAP_I2C_SA, &data, 2);\n\n    memread(s->addr + OMAP_I2C_SA, &data, 2);\n\n    g_assert_cmphex(data, ==, addr);\n\n}\n","idx":14943,"target":1}
{"code":"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n \tjas_image_cmpt_t *cmpt;\n \tsize_t size;\n \n \tcmpt = 0;\n \tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n \t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n \t  !jas_safe_intfast32_add(tly, height, 0)) {\n \t\tgoto error;\n \t}\n \n \tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n \t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) \/ 8;\n\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n \t\tgoto error;\n \t}\n \tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t\/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. *\/\n\t\/* Note: conversion of size - 1 to long can overflow *\/\n\tif (size > 0) {\n\t\tif (size - 1 > LONG_MAX) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n","idx":181865,"target":1}
{"code":"static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n {\n \tsize_t n;\n \tuint32_t types = up->types;\n\n\tp->types = types;\n \tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n \t\tuintptr_t a = up->vals[n * 2];\n \t\tsize_t b = up->vals[n * 2 + 1];\n \n \t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n \t\t\tp->u[n].mem.mobj = &mobj_virt;\n \t\t\tp->u[n].mem.offs = a;\n \t\t\tp->u[n].mem.size = b;\n \t\t\tbreak;\n \t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n \t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n \t\t\tbreak;\n \t\t}\n \t}\n }\n","idx":182643,"target":1}
{"code":" nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t\/* Addresses *\/\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t\/* Routes *\/\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t\/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t *\/\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t\/* MTU *\/\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }\n","idx":177987,"target":1}
{"code":"devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"\/dsk\") == 0) || (strcmp(ptr, \"\/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n \t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n \t}\n \n\tptr = strchr(ptr + 1, '\/') + 1;\n \trw_exit(&sdvp->sdev_contents);\n \tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n \trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}\n","idx":179957,"target":1}
{"code":"static TCGv gen_lea_indexed(CPUM68KState *env, DisasContext *s, TCGv base)\n{\n    uint32_t offset;\n    uint16_t ext;\n    TCGv add;\n    TCGv tmp;\n    uint32_t bd, od;\n    offset = s->pc;\n    ext = cpu_lduw_code(env, s->pc);\n    s->pc += 2;\n    if ((ext & 0x800) == 0 && !m68k_feature(s->env, M68K_FEATURE_WORD_INDEX))\n        return NULL_QREG;\n    if (ext & 0x100) {\n        \/* full extension word format *\/\n        if (!m68k_feature(s->env, M68K_FEATURE_EXT_FULL))\n            return NULL_QREG;\n        if ((ext & 0x30) > 0x10) {\n            \/* base displacement *\/\n            if ((ext & 0x30) == 0x20) {\n                bd = (int16_t)cpu_lduw_code(env, s->pc);\n                s->pc += 2;\n            } else {\n                bd = read_im32(env, s);\n        } else {\n            bd = 0;\n        tmp = tcg_temp_new();\n        if ((ext & 0x44) == 0) {\n            \/* pre-index *\/\n            add = gen_addr_index(ext, tmp);\n        } else {\n            add = NULL_QREG;\n        if ((ext & 0x80) == 0) {\n            \/* base not suppressed *\/\n            if (IS_NULL_QREG(base)) {\n                base = tcg_const_i32(offset + bd);\n                bd = 0;\n            if (!IS_NULL_QREG(add)) {\n                tcg_gen_add_i32(tmp, add, base);\n                add = tmp;\n            } else {\n                add = base;\n        if (!IS_NULL_QREG(add)) {\n            if (bd != 0) {\n                tcg_gen_addi_i32(tmp, add, bd);\n                add = tmp;\n        } else {\n            add = tcg_const_i32(bd);\n        if ((ext & 3) != 0) {\n            \/* memory indirect *\/\n            base = gen_load(s, OS_LONG, add, 0);\n            if ((ext & 0x44) == 4) {\n                add = gen_addr_index(ext, tmp);\n                tcg_gen_add_i32(tmp, add, base);\n                add = tmp;\n            } else {\n                add = base;\n            if ((ext & 3) > 1) {\n                \/* outer displacement *\/\n                if ((ext & 3) == 2) {\n                    od = (int16_t)cpu_lduw_code(env, s->pc);\n                    s->pc += 2;\n                } else {\n                    od = read_im32(env, s);\n            } else {\n                od = 0;\n            if (od != 0) {\n                tcg_gen_addi_i32(tmp, add, od);\n                add = tmp;\n    } else {\n        \/* brief extension word format *\/\n        tmp = tcg_temp_new();\n        add = gen_addr_index(ext, tmp);\n        if (!IS_NULL_QREG(base)) {\n            tcg_gen_add_i32(tmp, add, base);\n            if ((int8_t)ext)\n                tcg_gen_addi_i32(tmp, tmp, (int8_t)ext);\n        } else {\n            tcg_gen_addi_i32(tmp, add, offset + (int8_t)ext);\n        add = tmp;\n    return add;","idx":20451,"target":1}
{"code":"static gboolean register_signal_handlers(void)\n\n{\n\n    struct sigaction sigact, sigact_chld;\n\n    int ret;\n\n\n\n    memset(&sigact, 0, sizeof(struct sigaction));\n\n    sigact.sa_handler = quit_handler;\n\n\n\n    ret = sigaction(SIGINT, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n    ret = sigaction(SIGTERM, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n\n\n    memset(&sigact_chld, 0, sizeof(struct sigaction));\n\n    sigact_chld.sa_handler = child_handler;\n\n    sigact_chld.sa_flags = SA_NOCLDSTOP;\n\n    ret = sigaction(SIGCHLD, &sigact_chld, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n    }\n\n\n\n    return true;\n\n}\n","idx":4015,"target":1}
{"code":" static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n {\n        xml_parser *parser = (xml_parser *)rsrc->ptr;\n        if (parser->parser) {\n                XML_ParserFree(parser->parser);\n        }\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\n\tefree(parser);\n}\n","idx":178219,"target":1}
{"code":"static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n \t\t\t       const struct in6_addr *dst,\n \t\t\t       const struct in6_addr *src)\n {\n \tu32 hash, id;\n \n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n \n \t\/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n \t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t *\/\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}\n","idx":182889,"target":1}
{"code":"void Document::finishedParsing()\n{\n    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());\n    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);\n    setParsingState(InDOMContentLoaded);\n\n    if (!m_documentTiming.domContentLoadedEventStart())\n        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());\n    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));\n    if (!m_documentTiming.domContentLoadedEventEnd())\n        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());\n    setParsingState(FinishedParsing);\n\n    RefPtrWillBeRawPtr<Document> protect(this);\n\n    Microtask::performCheckpoint();\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();\n\n        if (mainResourceWasAlreadyRequested)\n            updateLayoutTreeIfNeeded();\n\n        frame->loader().finishedParsing();\n\n        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"MarkDOMContent\", TRACE_EVENT_SCOPE_THREAD, \"data\", InspectorMarkLoadEvent::data(frame.get()));\n        InspectorInstrumentation::domContentLoadedEventFired(frame.get());\n    }\n\n    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);\n\n    m_fetcher->clearPreloads();\n}\n","idx":185822,"target":1}
{"code":"static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\n\tspin_lock_irqsave(&m->lock, flags);\n\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n \n \tspin_unlock_irqrestore(&m->lock, flags);\n \n \treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n }\n","idx":178896,"target":1}
{"code":"htmlCheckEncodingDirect(htmlParserCtxtPtr ctxt, const xmlChar *encoding) {\n\n    if ((ctxt == NULL) || (encoding == NULL) ||\n        (ctxt->options & HTML_PARSE_IGNORE_ENC))\n\treturn;\n\n    \/* do not change encoding *\/\n    if (ctxt->input->encoding != NULL)\n        return;\n\n    if (encoding != NULL) {\n\txmlCharEncoding enc;\n\txmlCharEncodingHandlerPtr handler;\n\n\twhile ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n\n\tif (ctxt->input->encoding != NULL)\n\t    xmlFree((xmlChar *) ctxt->input->encoding);\n\tctxt->input->encoding = xmlStrdup(encoding);\n\n\tenc = xmlParseCharEncoding((const char *) encoding);\n\t\/*\n\t * registered set of known encodings\n\t *\/\n\tif (enc != XML_CHAR_ENCODING_ERROR) {\n\t    if (((enc == XML_CHAR_ENCODING_UTF16LE) ||\n\t         (enc == XML_CHAR_ENCODING_UTF16BE) ||\n\t\t (enc == XML_CHAR_ENCODING_UCS4LE) ||\n\t\t (enc == XML_CHAR_ENCODING_UCS4BE)) &&\n\t\t(ctxt->input->buf != NULL) &&\n\t\t(ctxt->input->buf->encoder == NULL)) {\n\t\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t             \"htmlCheckEncoding: wrong encoding meta\\n\",\n\t\t\t     NULL, NULL);\n\t    } else {\n\t\txmlSwitchEncoding(ctxt, enc);\n\t    }\n\t    ctxt->charset = XML_CHAR_ENCODING_UTF8;\n\t} else {\n\t    \/*\n\t     * fallback for unknown encodings\n\t     *\/\n\t    handler = xmlFindCharEncodingHandler((const char *) encoding);\n\t    if (handler != NULL) {\n\t\txmlSwitchToEncoding(ctxt, handler);\n\t\tctxt->charset = XML_CHAR_ENCODING_UTF8;\n\t    } else {\n\t\thtmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n\t\t             \"htmlCheckEncoding: unknown encoding %s\\n\",\n\t\t\t     encoding, NULL);\n\t    }\n\t}\n\n\tif ((ctxt->input->buf != NULL) &&\n\t    (ctxt->input->buf->encoder != NULL) &&\n\t    (ctxt->input->buf->raw != NULL) &&\n\t    (ctxt->input->buf->buffer != NULL)) {\n\t    int nbchars;\n\t    int processed;\n\n\t    \/*\n\t     * convert as much as possible to the parser reading buffer.\n\t     *\/\n \t    processed = ctxt->input->cur - ctxt->input->base;\n \t    xmlBufShrink(ctxt->input->buf->buffer, processed);\n \t    nbchars = xmlCharEncInput(ctxt->input->buf, 1);\n \t    if (nbchars < 0) {\n \t\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n \t\t             \"htmlCheckEncoding: encoder error\\n\",\n \t\t\t     NULL, NULL);\n \t    }\n            xmlBufResetInput(ctxt->input->buf->buffer, ctxt->input);\n \t}\n     }\n }\n","idx":186995,"target":1}
{"code":"void ppc40x_chip_reset (CPUState *env)\n\n{\n\n    target_ulong dbsr;\n\n\n\n    printf(\"Reset PowerPC chip\\n\");\n\n    cpu_ppc_reset(env);\n\n    \/* XXX: TODO reset all internal peripherals *\/\n\n    dbsr = env->spr[SPR_40x_DBSR];\n\n    dbsr &= ~0x00000300;\n\n    dbsr |= 0x00000200;\n\n    env->spr[SPR_40x_DBSR] = dbsr;\n\n    cpu_loop_exit();\n\n}\n","idx":12057,"target":1}
{"code":"static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n","idx":17554,"target":1}
{"code":"static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,\n\n                          IVITile *tile, AVCodecContext *avctx)\n\n{\n\n    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,\n\n                mv_scale, blks_per_mb;\n\n    IVIMbInfo   *mb, *ref_mb;\n\n    int         row_offset = band->mb_size * band->pitch;\n\n\n\n    mb     = tile->mbs;\n\n    ref_mb = tile->ref_mbs;\n\n    offs   = tile->ypos * band->pitch + tile->xpos;\n\n\n\n    \/* scale factor for motion vectors *\/\n\n    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);\n\n    mv_x = mv_y = 0;\n\n\n\n    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {\n\n        mb_offset = offs;\n\n\n\n        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {\n\n            mb->xpos     = x;\n\n            mb->ypos     = y;\n\n            mb->buf_offs = mb_offset;\n\n\n\n            if (get_bits1(&ctx->gb)) {\n\n                if (ctx->frame_type == FRAMETYPE_INTRA) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Empty macroblock in an INTRA picture!\\n\");\n\n                    return -1;\n\n                }\n\n                mb->type = 1; \/* empty macroblocks are always INTER *\/\n\n                mb->cbp  = 0; \/* all blocks are empty *\/\n\n\n\n                mb->q_delta = 0;\n\n                if (!band->plane && !band->band_num && (ctx->frame_flags & 8)) {\n\n                    mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                           IVI_VLC_BITS, 1);\n\n                    mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n\n                }\n\n\n\n                mb->mv_x = mb->mv_y = 0; \/* no motion vector coded *\/\n\n                if (band->inherit_mv){\n\n                    \/* motion vector inheritance *\/\n\n                    if (mv_scale) {\n\n                        mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n\n                        mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n\n                    } else {\n\n                        mb->mv_x = ref_mb->mv_x;\n\n                        mb->mv_y = ref_mb->mv_y;\n\n                    }\n\n                }\n\n            } else {\n\n                if (band->inherit_mv) {\n\n                    mb->type = ref_mb->type; \/* copy mb_type from corresponding reference mb *\/\n\n                } else if (ctx->frame_type == FRAMETYPE_INTRA) {\n\n                    mb->type = 0; \/* mb_type is always INTRA for intra-frames *\/\n\n                } else {\n\n                    mb->type = get_bits1(&ctx->gb);\n\n                }\n\n\n\n                blks_per_mb = band->mb_size != band->blk_size ? 4 : 1;\n\n                mb->cbp = get_bits(&ctx->gb, blks_per_mb);\n\n\n\n                mb->q_delta = 0;\n\n                if (band->qdelta_present) {\n\n                    if (band->inherit_qdelta) {\n\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n\n                                           (ctx->frame_flags & 8))) {\n\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                               IVI_VLC_BITS, 1);\n\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n\n                    }\n\n                }\n\n\n\n                if (!mb->type) {\n\n                    mb->mv_x = mb->mv_y = 0; \/* there is no motion vector in intra-macroblocks *\/\n\n                } else {\n\n                    if (band->inherit_mv){\n\n                        \/* motion vector inheritance *\/\n\n                        if (mv_scale) {\n\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n\n                        } else {\n\n                            mb->mv_x = ref_mb->mv_x;\n\n                            mb->mv_y = ref_mb->mv_y;\n\n                        }\n\n                    } else {\n\n                        \/* decode motion vector deltas *\/\n\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                            IVI_VLC_BITS, 1);\n\n                        mv_y += IVI_TOSIGNED(mv_delta);\n\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                            IVI_VLC_BITS, 1);\n\n                        mv_x += IVI_TOSIGNED(mv_delta);\n\n                        mb->mv_x = mv_x;\n\n                        mb->mv_y = mv_y;\n\n                    }\n\n                }\n\n            }\n\n\n\n            mb++;\n\n            if (ref_mb)\n\n                ref_mb++;\n\n            mb_offset += band->mb_size;\n\n        }\n\n\n\n        offs += row_offset;\n\n    }\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return 0;\n\n}\n","idx":8708,"target":1}
{"code":"static void init_excp_620 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;\n\n    \/* Hardware reset vector *\/\n\n    env->hreset_vector = 0x0000000000000100ULL; \/* ? *\/\n\n#endif\n\n}\n","idx":3547,"target":1}
{"code":"static int decode_header(EXRContext *s)\n\n{\n\n    int magic_number, version, i, flags, sar = 0;\n\n    int layer_match = 0;\n\n\n\n    s->current_channel_offset = 0;\n\n    s->xmin               = ~0;\n\n    s->xmax               = ~0;\n\n    s->ymin               = ~0;\n\n    s->ymax               = ~0;\n\n    s->xdelta             = ~0;\n\n    s->ydelta             = ~0;\n\n    s->channel_offsets[0] = -1;\n\n    s->channel_offsets[1] = -1;\n\n    s->channel_offsets[2] = -1;\n\n    s->channel_offsets[3] = -1;\n\n    s->pixel_type         = EXR_UNKNOWN;\n\n    s->compression        = EXR_UNKN;\n\n    s->nb_channels        = 0;\n\n    s->w                  = 0;\n\n    s->h                  = 0;\n\n    s->tile_attr.xSize    = -1;\n\n    s->tile_attr.ySize    = -1;\n\n    s->is_tile            = 0;\n\n    s->is_luma            = 0;\n\n\n\n    if (bytestream2_get_bytes_left(&s->gb) < 10) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_number = bytestream2_get_le32(&s->gb);\n\n    if (magic_number != 20000630) {\n\n        \/* As per documentation of OpenEXR, it is supposed to be\n\n         * int 20000630 little-endian *\/\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    version = bytestream2_get_byte(&s->gb);\n\n    if (version != 2) {\n\n        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    flags = bytestream2_get_le24(&s->gb);\n\n\n\n    if (flags == 0x00)\n\n        s->is_tile = 0;\n\n    else if (flags & 0x02)\n\n        s->is_tile = 1;\n\n    else{\n\n        avpriv_report_missing_feature(s->avctx, \"flags %d\", flags);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    \/\/ Parse the header\n\n    while (bytestream2_get_bytes_left(&s->gb) > 0 && *s->gb.buffer) {\n\n        int var_size;\n\n        if ((var_size = check_header_variable(s, \"channels\",\n\n                                              \"chlist\", 38)) >= 0) {\n\n            GetByteContext ch_gb;\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            bytestream2_init(&ch_gb, s->gb.buffer, var_size);\n\n\n\n            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {\n\n                EXRChannel *channel;\n\n                enum ExrPixelType current_pixel_type;\n\n                int channel_index = -1;\n\n                int xsub, ysub;\n\n\n\n                if (strcmp(s->layer, \"\") != 0) {\n\n                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {\n\n                        layer_match = 1;\n\n                        av_log(s->avctx, AV_LOG_INFO,\n\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer);\n\n                        ch_gb.buffer += strlen(s->layer);\n\n                        if (*ch_gb.buffer == '.')\n\n                            ch_gb.buffer++;         \/* skip dot if not given *\/\n\n                    } else {\n\n                        av_log(s->avctx, AV_LOG_INFO,\n\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer);\n\n                    }\n\n                } else {\n\n                    layer_match = 1;\n\n                }\n\n\n\n                if (layer_match) { \/* only search channel if the layer match is valid *\/\n\n                    if (!strcmp(ch_gb.buffer, \"R\") ||\n\n                        !strcmp(ch_gb.buffer, \"X\") ||\n\n                        !strcmp(ch_gb.buffer, \"U\")) {\n\n                        channel_index = 0;\n\n                        s->is_luma = 0;\n\n                    } else if (!strcmp(ch_gb.buffer, \"G\") ||\n\n                               !strcmp(ch_gb.buffer, \"V\")) {\n\n                        channel_index = 1;\n\n                        s->is_luma = 0;\n\n                    } else if (!strcmp(ch_gb.buffer, \"Y\")) {\n\n                        channel_index = 1;\n\n                        s->is_luma = 1;\n\n                    } else if (!strcmp(ch_gb.buffer, \"B\") ||\n\n                               !strcmp(ch_gb.buffer, \"Z\") ||\n\n                               !strcmp(ch_gb.buffer, \"W\")){\n\n                               channel_index = 2;\n\n                        s->is_luma = 0;\n\n                    } else if (!strcmp(ch_gb.buffer, \"A\")) {\n\n                        channel_index = 3;\n\n                    } else {\n\n                        av_log(s->avctx, AV_LOG_WARNING,\n\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer);\n\n                    }\n\n                }\n\n\n\n                \/* skip until you get a 0 *\/\n\n                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&\n\n                       bytestream2_get_byte(&ch_gb))\n\n                    continue;\n\n\n\n                if (bytestream2_get_bytes_left(&ch_gb) < 4) {\n\n                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                current_pixel_type = bytestream2_get_le32(&ch_gb);\n\n                if (current_pixel_type >= EXR_UNKNOWN) {\n\n                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n\n                                                  current_pixel_type);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n\n\n                bytestream2_skip(&ch_gb, 4);\n\n                xsub = bytestream2_get_le32(&ch_gb);\n\n                ysub = bytestream2_get_le32(&ch_gb);\n\n\n\n                if (xsub != 1 || ysub != 1) {\n\n                    avpriv_report_missing_feature(s->avctx,\n\n                                                  \"Subsampling %dx%d\",\n\n                                                  xsub, ysub);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n\n\n                if (s->channel_offsets[channel_index] == -1){\/* channel have not been previously assign *\/\n\n                    if (channel_index >= 0) {\n\n                        if (s->pixel_type != EXR_UNKNOWN &&\n\n                            s->pixel_type != current_pixel_type) {\n\n                            av_log(s->avctx, AV_LOG_ERROR,\n\n                                   \"RGB channels not of the same depth.\\n\");\n\n                            return AVERROR_INVALIDDATA;\n\n                        }\n\n                        s->pixel_type                     = current_pixel_type;\n\n                        s->channel_offsets[channel_index] = s->current_channel_offset;\n\n                    }\n\n                }\n\n\n\n                s->channels = av_realloc(s->channels,\n\n                                         ++s->nb_channels * sizeof(EXRChannel));\n\n                if (!s->channels)\n\n                    return AVERROR(ENOMEM);\n\n                channel             = &s->channels[s->nb_channels - 1];\n\n                channel->pixel_type = current_pixel_type;\n\n                channel->xsub       = xsub;\n\n                channel->ysub       = ysub;\n\n\n\n                s->current_channel_offset += 1 << current_pixel_type;\n\n            }\n\n\n\n            \/* Check if all channels are set with an offset or if the channels\n\n             * are causing an overflow  *\/\n\n            if (!s->is_luma){\/* if we expected to have at least 3 channels *\/\n\n                if (FFMIN3(s->channel_offsets[0],\n\n                           s->channel_offsets[1],\n\n                           s->channel_offsets[2]) < 0) {\n\n                    if (s->channel_offsets[0] < 0)\n\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");\n\n                    if (s->channel_offsets[1] < 0)\n\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");\n\n                    if (s->channel_offsets[2] < 0)\n\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n            }\n\n\n\n            \/\/ skip one last byte and update main gb\n\n            s->gb.buffer = ch_gb.buffer + 1;\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",\n\n                                                     31)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            s->xmin   = bytestream2_get_le32(&s->gb);\n\n            s->ymin   = bytestream2_get_le32(&s->gb);\n\n            s->xmax   = bytestream2_get_le32(&s->gb);\n\n            s->ymax   = bytestream2_get_le32(&s->gb);\n\n            s->xdelta = (s->xmax - s->xmin) + 1;\n\n            s->ydelta = (s->ymax - s->ymin) + 1;\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"displayWindow\",\n\n                                                     \"box2i\", 34)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            bytestream2_skip(&s->gb, 8);\n\n            s->w = bytestream2_get_le32(&s->gb) + 1;\n\n            s->h = bytestream2_get_le32(&s->gb) + 1;\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"lineOrder\",\n\n                                                     \"lineOrder\", 25)) >= 0) {\n\n            int line_order;\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            line_order = bytestream2_get_byte(&s->gb);\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);\n\n            if (line_order > 2) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",\n\n                                                     \"float\", 31)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            sar = bytestream2_get_le32(&s->gb);\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"compression\",\n\n                                                     \"compression\", 29)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (s->compression == EXR_UNKN)\n\n                s->compression = bytestream2_get_byte(&s->gb);\n\n            else\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Found more than one compression attribute.\\n\");\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"tiles\",\n\n                                                     \"tiledesc\", 22)) >= 0) {\n\n            char tileLevel;\n\n\n\n            if (!s->is_tile)\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");\n\n\n\n            s->tile_attr.xSize = bytestream2_get_le32(&s->gb);\n\n            s->tile_attr.ySize = bytestream2_get_le32(&s->gb);\n\n\n\n            tileLevel = bytestream2_get_byte(&s->gb);\n\n            s->tile_attr.level_mode = tileLevel & 0x0f;\n\n            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;\n\n\n\n            if (s->tile_attr.level_mode >= EXR_TILE_LEVEL_UNKNOWN){\n\n                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n\n                                              s->tile_attr.level_mode);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            if (s->tile_attr.level_round >= EXR_TILE_ROUND_UNKNOWN) {\n\n                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n\n                                              s->tile_attr.level_round);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            continue;\n\n        }\n\n\n\n        \/\/ Check if there are enough bytes for a header\n\n        if (bytestream2_get_bytes_left(&s->gb) <= 9) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        \/\/ Process unknown variables\n\n        for (i = 0; i < 2; i++) \/\/ value_name and value_type\n\n            while (bytestream2_get_byte(&s->gb) != 0);\n\n\n\n        \/\/ Skip variable length\n\n        bytestream2_skip(&s->gb, bytestream2_get_le32(&s->gb));\n\n    }\n\n\n\n    ff_set_sar(s->avctx, av_d2q(av_int2float(sar), 255));\n\n\n\n    if (s->compression == EXR_UNKN) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->is_tile) {\n\n        if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    if (bytestream2_get_bytes_left(&s->gb) <= 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    \/\/ aaand we are done\n\n    bytestream2_skip(&s->gb, 1);\n\n    return 0;\n\n}\n","idx":26750,"target":1}
{"code":"void ff_celp_lp_synthesis_filterf(float *out, const float *filter_coeffs,\n                                  const float* in, int buffer_length,\n                                  int filter_length)\n{\n    int i,n;\n\n#if 0 \/\/ Unoptimized code path for improved readability\n    for (n = 0; n < buffer_length; n++) {\n        out[n] = in[n];\n        for (i = 1; i <= filter_length; i++)\n            out[n] -= filter_coeffs[i-1] * out[n-i];\n    }\n#else\n    float out0, out1, out2, out3;\n    float old_out0, old_out1, old_out2, old_out3;\n    float a,b,c;\n\n    a = filter_coeffs[0];\n    b = filter_coeffs[1];\n    c = filter_coeffs[2];\n    b -= filter_coeffs[0] * filter_coeffs[0];\n    c -= filter_coeffs[1] * filter_coeffs[0];\n    c -= filter_coeffs[0] * b;\n\n    old_out0 = out[-4];\n    old_out1 = out[-3];\n    old_out2 = out[-2];\n    old_out3 = out[-1];\n    for (n = 0; n <= buffer_length - 4; n+=4) {\n        float tmp0,tmp1,tmp2;\n        float val;\n\n        out0 = in[0];\n        out1 = in[1];\n        out2 = in[2];\n        out3 = in[3];\n\n        out0 -= filter_coeffs[2] * old_out1;\n        out1 -= filter_coeffs[2] * old_out2;\n        out2 -= filter_coeffs[2] * old_out3;\n\n        out0 -= filter_coeffs[1] * old_out2;\n        out1 -= filter_coeffs[1] * old_out3;\n\n        out0 -= filter_coeffs[0] * old_out3;\n\n        val = filter_coeffs[3];\n\n        out0 -= val * old_out0;\n        out1 -= val * old_out1;\n        out2 -= val * old_out2;\n        out3 -= val * old_out3;\n\n        for (i = 5; i <= filter_length; i += 2) {\n            old_out3 = out[-i];\n            val = filter_coeffs[i-1];\n\n            out0 -= val * old_out3;\n            out1 -= val * old_out0;\n            out2 -= val * old_out1;\n            out3 -= val * old_out2;\n\n            old_out2 = out[-i-1];\n\n            val = filter_coeffs[i];\n\n            out0 -= val * old_out2;\n            out1 -= val * old_out3;\n            out2 -= val * old_out0;\n            out3 -= val * old_out1;\n\n            FFSWAP(float, old_out0, old_out2);\n            old_out1 = old_out3;\n        }\n\n        tmp0 = out0;\n        tmp1 = out1;\n        tmp2 = out2;\n\n        out3 -= a * tmp2;\n        out2 -= a * tmp1;\n        out1 -= a * tmp0;\n\n        out3 -= b * tmp1;\n        out2 -= b * tmp0;\n\n        out3 -= c * tmp0;\n\n\n        out[0] = out0;\n        out[1] = out1;\n        out[2] = out2;\n        out[3] = out3;\n\n        old_out0 = out0;\n        old_out1 = out1;\n        old_out2 = out2;\n        old_out3 = out3;\n\n        out += 4;\n        in  += 4;\n    }\n\n    out -= n;\n    in -= n;\n    for (; n < buffer_length; n++) {\n        out[n] = in[n];\n        for (i = 1; i <= filter_length; i++)\n            out[n] -= filter_coeffs[i-1] * out[n-i];\n    }\n#endif\n}","idx":1292303,"target":1}
{"code":"static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n    static const uint8_t header_prefixhr[] = { 0x00, 0x00, 0x02, 0x80, 0x03 };\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth;\n\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) && memcmp(buf, header_prefixhr, 5)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { \/* interlaced *\/\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: ctx->bit_depth = 8; break;\n    case 2: ctx->bit_depth = 10; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth;\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (ctx->bit_depth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n        ctx->pix_fmt = AV_PIX_FMT_YUV444P10;\n    } else if (ctx->bit_depth == 10) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    cid = AV_RB32(buf + 0x28);\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    \/\/ make sure profile size constraints are respected\n    \/\/ DNx100 allows 1920->1440 and 1280->960 subsampling\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %d).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = buf[0x16d];\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n    if (ctx->mb_height > 68 ||\n        (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"mb height too big: %d\\n\", ctx->mb_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%d < %d).\\n\",\n                   buf_size, ctx->mb_scan_index[i] + 0x280);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}","idx":1294649,"target":1}
{"code":"static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt,\n                      uint8_t block_type, AVFormatContext *s)\n{\n    uint8_t * vidbuf_start = NULL;\n    int vidbuf_nbytes = 0;\n    int code;\n    int bytes_copied = 0;\n    int position, duration, npixels;\n    unsigned int vidbuf_capacity;\n    int ret = 0;\n    AVStream *st;\n\n    if (vid->video_index < 0) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        vid->video_index = st->index;\n        if (vid->audio_index < 0) {\n            av_log_ask_for_sample(s, \"No audio packet before first video \"\n                                  \"packet. Using default video time base.\\n\");\n        }\n        avpriv_set_pts_info(st, 64, 185, vid->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id   = AV_CODEC_ID_BETHSOFTVID;\n        st->codec->width      = vid->width;\n        st->codec->height     = vid->height;\n    }\n    st      = s->streams[vid->video_index];\n    npixels = st->codec->width * st->codec->height;\n\n    vidbuf_start = av_malloc(vidbuf_capacity = BUFFER_PADDING_SIZE);\n    if(!vidbuf_start)\n        return AVERROR(ENOMEM);\n\n    \/\/ save the file position for the packet, include block type\n    position = avio_tell(pb) - 1;\n\n    vidbuf_start[vidbuf_nbytes++] = block_type;\n\n    \/\/ get the current packet duration\n    duration = vid->bethsoft_global_delay + avio_rl16(pb);\n\n    \/\/ set the y offset if it exists (decoder header data should be in data section)\n    if(block_type == VIDEO_YOFF_P_FRAME){\n        if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], 2) != 2) {\n            ret = AVERROR(EIO);\n            goto fail;\n        }\n        vidbuf_nbytes += 2;\n    }\n\n    do{\n        vidbuf_start = av_fast_realloc(vidbuf_start, &vidbuf_capacity, vidbuf_nbytes + BUFFER_PADDING_SIZE);\n        if(!vidbuf_start)\n            return AVERROR(ENOMEM);\n\n        code = avio_r8(pb);\n        vidbuf_start[vidbuf_nbytes++] = code;\n\n        if(code >= 0x80){ \/\/ rle sequence\n            if(block_type == VIDEO_I_FRAME)\n                vidbuf_start[vidbuf_nbytes++] = avio_r8(pb);\n        } else if(code){ \/\/ plain sequence\n            if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], code) != code) {\n                ret = AVERROR(EIO);\n                goto fail;\n            }\n            vidbuf_nbytes += code;\n        }\n        bytes_copied += code & 0x7F;\n        if(bytes_copied == npixels){ \/\/ sometimes no stop character is given, need to keep track of bytes copied\n            \/\/ may contain a 0 byte even if read all pixels\n            if(avio_r8(pb))\n                avio_seek(pb, -1, SEEK_CUR);\n            break;\n        }\n        if (bytes_copied > npixels) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    } while(code);\n\n    \/\/ copy data into packet\n    if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0)\n        goto fail;\n    memcpy(pkt->data, vidbuf_start, vidbuf_nbytes);\n    av_free(vidbuf_start);\n\n    pkt->pos = position;\n    pkt->stream_index = vid->video_index;\n    pkt->duration = duration;\n    if (block_type == VIDEO_I_FRAME)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    \/* if there is a new palette available, add it to packet side data *\/\n    if (vid->palette) {\n        uint8_t *pdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n                                                 BVID_PALETTE_SIZE);\n        memcpy(pdata, vid->palette, BVID_PALETTE_SIZE);\n        av_freep(&vid->palette);\n    }\n\n    vid->nframes--;  \/\/ used to check if all the frames were read\n    return 0;\nfail:\n    av_free(vidbuf_start);\n    return ret;\n}","idx":1292945,"target":1}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    FrameRateContext *s = ctx->priv;\n    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);\n    int plane;\n\n    for (plane = 0; plane < 4; plane++) {\n        s->line_size[plane] = av_image_get_linesize(inlink->format, inlink->w,\n                                                    plane);\n    }\n\n    s->bitdepth = pix_desc->comp[0].depth;\n    s->vsub = pix_desc->log2_chroma_h;\n    s->interp_start = s->interp_start_param << (s->bitdepth - 8);\n    s->interp_end = s->interp_end_param << (s->bitdepth - 8);\n\n    s->sad = av_pixelutils_get_sad_fn(3, 3, 2, s); \/\/ 8x8 both sources aligned\n    if (!s->sad)\n        return AVERROR(EINVAL);\n\n    s->srce_time_base = inlink->time_base;\n\n    s->max = 1 << (s->bitdepth);\n    if (s->bitdepth == 8)\n        s->blend = blend_frames_c;\n    else\n        s->blend = blend_frames16_c;\n\n    return 0;\n}","idx":1291695,"target":1}
{"code":"static void blend_frame(AVFilterContext *ctx,\n                        AVFrame *top_buf,\n                        AVFrame *bottom_buf,\n                        AVFrame *dst_buf)\n{\n    BlendContext *b = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    FilterParams *param;\n    int plane;\n\n    for (plane = 0; dst_buf->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;\n        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;\n        int outw = dst_buf->width  >> hsub;\n        int outh = dst_buf->height >> vsub;\n        uint8_t *dst    = dst_buf->data[plane];\n        uint8_t *top    = top_buf->data[plane];\n        uint8_t *bottom = bottom_buf->data[plane];\n\n        param = &b->params[plane];\n        param->values[VAR_N]  = inlink->frame_count;\n        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);\n        param->values[VAR_W]  = outw;\n        param->values[VAR_H]  = outh;\n        param->values[VAR_SW] = outw \/ dst_buf->width;\n        param->values[VAR_SH] = outh \/ dst_buf->height;\n        param->blend(top, top_buf->linesize[plane],\n                     bottom, bottom_buf->linesize[plane],\n                     dst, dst_buf->linesize[plane], outw, outh, param);\n    }\n}","idx":1292326,"target":1}
{"code":"static int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno \/ s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n\n    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; \/\/ global bandno\n\n        comp->coord_o[0][0] = tile->coord[0][0];\n        comp->coord_o[0][1] = tile->coord[0][1];\n        comp->coord_o[1][0] = tile->coord[1][0];\n        comp->coord_o[1][1] = tile->coord[1][1];\n        if (compno) {\n            comp->coord_o[0][0] \/= s->cdx[compno];\n            comp->coord_o[0][1] \/= s->cdx[compno];\n            comp->coord_o[1][0] \/= s->cdy[compno];\n            comp->coord_o[1][1] \/= s->cdy[compno];\n        }\n\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}","idx":1295382,"target":1}
{"code":"int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,\n                            uint8_t *data, size_t size)\n{\n    AVPacketSideData *sd, *tmp;\n    int i;\n\n    for (i = 0; i < st->nb_side_data; i++) {\n        sd = &st->side_data[i];\n\n        if (sd->type == type) {\n            av_freep(&sd->data);\n            sd->data = data;\n            sd->size = size;\n            return 0;\n        }\n    }\n\n    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp));\n    if (!tmp) {\n        return AVERROR(ENOMEM);\n    }\n\n    st->side_data = tmp;\n    st->nb_side_data++;\n\n    sd = &st->side_data[st->nb_side_data - 1];\n    sd->type = type;\n    sd->data = data;\n    sd->size = size;\n\n    return 0;\n}","idx":1291528,"target":1}
{"code":"static inline void refill_32(BitstreamContext *bc)\n{\n    if (bc->ptr >= bc->buffer_end)\n        return;\n\n#ifdef BITSTREAM_READER_LE\n    bc->bits       = (uint64_t)AV_RL32(bc->ptr) << bc->bits_left | bc->bits;\n#else\n    bc->bits       = bc->bits | (uint64_t)AV_RB32(bc->ptr) << (32 - bc->bits_left);\n#endif\n    bc->ptr       += 4;\n    bc->bits_left += 32;\n}","idx":1295451,"target":1}
{"code":"SwsContext *sws_getContext(int srcW, int srcH, enum PixelFormat srcFormat, int dstW, int dstH, enum PixelFormat dstFormat, int flags,\n                           SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)\n{\n\n    SwsContext *c;\n    int i;\n    int usesVFilter, usesHFilter;\n    int unscaled, needsDither;\n    int srcRange, dstRange;\n    SwsFilter dummyFilter= {NULL, NULL, NULL, NULL};\n#if ARCH_X86\n    if (flags & SWS_CPU_CAPS_MMX)\n        __asm__ volatile(\"emms\\n\\t\"::: \"memory\");\n#endif\n\n#if !CONFIG_RUNTIME_CPUDETECT \/\/ensure that the flags match the compiled variant if cpudetect is off\n    flags &= ~(SWS_CPU_CAPS_MMX|SWS_CPU_CAPS_MMX2|SWS_CPU_CAPS_3DNOW|SWS_CPU_CAPS_ALTIVEC|SWS_CPU_CAPS_BFIN);\n#if   COMPILE_TEMPLATE_MMX2\n    flags |= SWS_CPU_CAPS_MMX|SWS_CPU_CAPS_MMX2;\n#elif COMPILE_TEMPLATE_AMD3DNOW\n    flags |= SWS_CPU_CAPS_MMX|SWS_CPU_CAPS_3DNOW;\n#elif COMPILE_TEMPLATE_MMX\n    flags |= SWS_CPU_CAPS_MMX;\n#elif COMPILE_TEMPLATE_ALTIVEC\n    flags |= SWS_CPU_CAPS_ALTIVEC;\n#elif ARCH_BFIN\n    flags |= SWS_CPU_CAPS_BFIN;\n#endif\n#endif \/* CONFIG_RUNTIME_CPUDETECT *\/\n    if (clip_table[512] != 255) globalInit();\n    if (!rgb15to16) sws_rgb2rgb_init(flags);\n\n    unscaled = (srcW == dstW && srcH == dstH);\n    needsDither= (isBGR(dstFormat) || isRGB(dstFormat))\n        && (fmt_depth(dstFormat))<24\n        && ((fmt_depth(dstFormat))<(fmt_depth(srcFormat)) || (!(isRGB(srcFormat) || isBGR(srcFormat))));\n\n    srcRange = handle_jpeg(&srcFormat);\n    dstRange = handle_jpeg(&dstFormat);\n\n    if (!isSupportedIn(srcFormat)) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: %s is not supported as input pixel format\\n\", sws_format_name(srcFormat));\n        return NULL;\n    }\n    if (!isSupportedOut(dstFormat)) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: %s is not supported as output pixel format\\n\", sws_format_name(dstFormat));\n        return NULL;\n    }\n\n    i= flags & ( SWS_POINT\n                |SWS_AREA\n                |SWS_BILINEAR\n                |SWS_FAST_BILINEAR\n                |SWS_BICUBIC\n                |SWS_X\n                |SWS_GAUSS\n                |SWS_LANCZOS\n                |SWS_SINC\n                |SWS_SPLINE\n                |SWS_BICUBLIN);\n    if(!i || (i & (i-1))) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: Exactly one scaler algorithm must be chosen\\n\");\n        return NULL;\n    }\n\n    \/* sanity check *\/\n    if (srcW<4 || srcH<1 || dstW<8 || dstH<1) { \/\/FIXME check if these are enough and try to lowwer them after fixing the relevant parts of the code\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: %dx%d -> %dx%d is invalid scaling dimension\\n\",\n               srcW, srcH, dstW, dstH);\n        return NULL;\n    }\n    if(srcW > VOFW || dstW > VOFW) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: Compile-time maximum width is \"AV_STRINGIFY(VOFW)\" change VOF\/VOFW and recompile\\n\");\n        return NULL;\n    }\n\n    if (!dstFilter) dstFilter= &dummyFilter;\n    if (!srcFilter) srcFilter= &dummyFilter;\n\n    c= av_mallocz(sizeof(SwsContext));\n\n    c->av_class = &sws_context_class;\n    c->srcW= srcW;\n    c->srcH= srcH;\n    c->dstW= dstW;\n    c->dstH= dstH;\n    c->lumXInc= ((srcW<<16) + (dstW>>1))\/dstW;\n    c->lumYInc= ((srcH<<16) + (dstH>>1))\/dstH;\n    c->flags= flags;\n    c->dstFormat= dstFormat;\n    c->srcFormat= srcFormat;\n    c->vRounder= 4* 0x0001000100010001ULL;\n\n    usesHFilter= usesVFilter= 0;\n    if (dstFilter->lumV && dstFilter->lumV->length>1) usesVFilter=1;\n    if (dstFilter->lumH && dstFilter->lumH->length>1) usesHFilter=1;\n    if (dstFilter->chrV && dstFilter->chrV->length>1) usesVFilter=1;\n    if (dstFilter->chrH && dstFilter->chrH->length>1) usesHFilter=1;\n    if (srcFilter->lumV && srcFilter->lumV->length>1) usesVFilter=1;\n    if (srcFilter->lumH && srcFilter->lumH->length>1) usesHFilter=1;\n    if (srcFilter->chrV && srcFilter->chrV->length>1) usesVFilter=1;\n    if (srcFilter->chrH && srcFilter->chrH->length>1) usesHFilter=1;\n\n    getSubSampleFactors(&c->chrSrcHSubSample, &c->chrSrcVSubSample, srcFormat);\n    getSubSampleFactors(&c->chrDstHSubSample, &c->chrDstVSubSample, dstFormat);\n\n    \/\/ reuse chroma for 2 pixels RGB\/BGR unless user wants full chroma interpolation\n    if ((isBGR(dstFormat) || isRGB(dstFormat)) && !(flags&SWS_FULL_CHR_H_INT)) c->chrDstHSubSample=1;\n\n    \/\/ drop some chroma lines if the user wants it\n    c->vChrDrop= (flags&SWS_SRC_V_CHR_DROP_MASK)>>SWS_SRC_V_CHR_DROP_SHIFT;\n    c->chrSrcVSubSample+= c->vChrDrop;\n\n    \/\/ drop every other pixel for chroma calculation unless user wants full chroma\n    if ((isBGR(srcFormat) || isRGB(srcFormat)) && !(flags&SWS_FULL_CHR_H_INP)\n      && srcFormat!=PIX_FMT_RGB8      && srcFormat!=PIX_FMT_BGR8\n      && srcFormat!=PIX_FMT_RGB4      && srcFormat!=PIX_FMT_BGR4\n      && srcFormat!=PIX_FMT_RGB4_BYTE && srcFormat!=PIX_FMT_BGR4_BYTE\n      && ((dstW>>c->chrDstHSubSample) <= (srcW>>1) || (flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n        c->chrSrcHSubSample=1;\n\n    if (param) {\n        c->param[0] = param[0];\n        c->param[1] = param[1];\n    } else {\n        c->param[0] =\n        c->param[1] = SWS_PARAM_DEFAULT;\n    }\n\n    \/\/ Note the -((-x)>>y) is so that we always round toward +inf.\n    c->chrSrcW= -((-srcW) >> c->chrSrcHSubSample);\n    c->chrSrcH= -((-srcH) >> c->chrSrcVSubSample);\n    c->chrDstW= -((-dstW) >> c->chrDstHSubSample);\n    c->chrDstH= -((-dstH) >> c->chrDstVSubSample);\n\n    sws_setColorspaceDetails(c, ff_yuv2rgb_coeffs[SWS_CS_DEFAULT], srcRange, ff_yuv2rgb_coeffs[SWS_CS_DEFAULT] \/* FIXME*\/, dstRange, 0, 1<<16, 1<<16);\n\n    \/* unscaled special cases *\/\n    if (unscaled && !usesHFilter && !usesVFilter && (srcRange == dstRange || isBGR(dstFormat) || isRGB(dstFormat))) {\n        \/* yv12_to_nv12 *\/\n        if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) && (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {\n            c->swScale= PlanarToNV12Wrapper;\n        }\n        \/* yuv2bgr *\/\n        if ((srcFormat==PIX_FMT_YUV420P || srcFormat==PIX_FMT_YUV422P || srcFormat==PIX_FMT_YUVA420P) && (isBGR(dstFormat) || isRGB(dstFormat))\n            && !(flags & SWS_ACCURATE_RND) && !(dstH&1)) {\n            c->swScale= ff_yuv2rgb_get_func_ptr(c);\n        }\n\n        if (srcFormat==PIX_FMT_YUV410P && (dstFormat==PIX_FMT_YUV420P || dstFormat==PIX_FMT_YUVA420P) && !(flags & SWS_BITEXACT)) {\n            c->swScale= yvu9toyv12Wrapper;\n        }\n\n        \/* bgr24toYV12 *\/\n        if (srcFormat==PIX_FMT_BGR24 && (dstFormat==PIX_FMT_YUV420P || dstFormat==PIX_FMT_YUVA420P) && !(flags & SWS_ACCURATE_RND))\n            c->swScale= bgr24toyv12Wrapper;\n\n        \/* RGB\/BGR -> RGB\/BGR (no dither needed forms) *\/\n        if (  (isBGR(srcFormat) || isRGB(srcFormat))\n           && (isBGR(dstFormat) || isRGB(dstFormat))\n           && srcFormat != PIX_FMT_BGR8      && dstFormat != PIX_FMT_BGR8\n           && srcFormat != PIX_FMT_RGB8      && dstFormat != PIX_FMT_RGB8\n           && srcFormat != PIX_FMT_BGR4      && dstFormat != PIX_FMT_BGR4\n           && srcFormat != PIX_FMT_RGB4      && dstFormat != PIX_FMT_RGB4\n           && srcFormat != PIX_FMT_BGR4_BYTE && dstFormat != PIX_FMT_BGR4_BYTE\n           && srcFormat != PIX_FMT_RGB4_BYTE && dstFormat != PIX_FMT_RGB4_BYTE\n           && srcFormat != PIX_FMT_MONOBLACK && dstFormat != PIX_FMT_MONOBLACK\n           && srcFormat != PIX_FMT_MONOWHITE && dstFormat != PIX_FMT_MONOWHITE\n                                             && dstFormat != PIX_FMT_RGB32_1\n                                             && dstFormat != PIX_FMT_BGR32_1\n           && srcFormat != PIX_FMT_RGB48LE   && dstFormat != PIX_FMT_RGB48LE\n           && srcFormat != PIX_FMT_RGB48BE   && dstFormat != PIX_FMT_RGB48BE\n           && (!needsDither || (c->flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n             c->swScale= rgb2rgbWrapper;\n\n        if ((usePal(srcFormat) && (\n                 dstFormat == PIX_FMT_RGB32   ||\n                 dstFormat == PIX_FMT_RGB32_1 ||\n                 dstFormat == PIX_FMT_RGB24   ||\n                 dstFormat == PIX_FMT_BGR32   ||\n                 dstFormat == PIX_FMT_BGR32_1 ||\n                 dstFormat == PIX_FMT_BGR24)))\n             c->swScale= pal2rgbWrapper;\n\n        if (srcFormat == PIX_FMT_YUV422P) {\n            if (dstFormat == PIX_FMT_YUYV422)\n                c->swScale= YUV422PToYuy2Wrapper;\n            else if (dstFormat == PIX_FMT_UYVY422)\n                c->swScale= YUV422PToUyvyWrapper;\n        }\n\n        \/* LQ converters if -sws 0 or -sws 4*\/\n        if (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)) {\n            \/* yv12_to_yuy2 *\/\n            if (srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) {\n                if (dstFormat == PIX_FMT_YUYV422)\n                    c->swScale= PlanarToYuy2Wrapper;\n                else if (dstFormat == PIX_FMT_UYVY422)\n                    c->swScale= PlanarToUyvyWrapper;\n            }\n        }\n        if(srcFormat == PIX_FMT_YUYV422 && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n            c->swScale= YUYV2YUV420Wrapper;\n        if(srcFormat == PIX_FMT_UYVY422 && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n            c->swScale= UYVY2YUV420Wrapper;\n        if(srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P)\n            c->swScale= YUYV2YUV422Wrapper;\n        if(srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P)\n            c->swScale= UYVY2YUV422Wrapper;\n\n#ifdef COMPILE_ALTIVEC\n        if ((c->flags & SWS_CPU_CAPS_ALTIVEC) &&\n            !(c->flags & SWS_BITEXACT) &&\n            srcFormat == PIX_FMT_YUV420P) {\n          \/\/ unscaled YV12 -> packed YUV, we want speed\n          if (dstFormat == PIX_FMT_YUYV422)\n              c->swScale= yv12toyuy2_unscaled_altivec;\n          else if (dstFormat == PIX_FMT_UYVY422)\n              c->swScale= yv12touyvy_unscaled_altivec;\n        }\n#endif\n\n        \/* simple copy *\/\n        if (  srcFormat == dstFormat\n            || (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P)\n            || (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P)\n            || (isPlanarYUV(srcFormat) && isGray(dstFormat))\n            || (isPlanarYUV(dstFormat) && isGray(srcFormat))\n            || (isGray(dstFormat) && isGray(srcFormat))\n            || (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat)\n                && c->chrDstHSubSample == c->chrSrcHSubSample\n                && c->chrDstVSubSample == c->chrSrcVSubSample\n                && dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21\n                && srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21))\n        {\n            if (isPacked(c->srcFormat))\n                c->swScale= packedCopy;\n            else \/* Planar YUV or gray *\/\n                c->swScale= planarCopy;\n        }\n#if ARCH_BFIN\n        if (flags & SWS_CPU_CAPS_BFIN)\n            ff_bfin_get_unscaled_swscale (c);\n#endif\n\n        if (c->swScale) {\n            if (flags&SWS_PRINT_INFO)\n                av_log(c, AV_LOG_INFO, \"using unscaled %s -> %s special converter\\n\",\n                       sws_format_name(srcFormat), sws_format_name(dstFormat));\n            return c;\n        }\n    }\n\n    if (flags & SWS_CPU_CAPS_MMX2) {\n        c->canMMX2BeUsed= (dstW >=srcW && (dstW&31)==0 && (srcW&15)==0) ? 1 : 0;\n        if (!c->canMMX2BeUsed && dstW >=srcW && (srcW&15)==0 && (flags&SWS_FAST_BILINEAR)) {\n            if (flags&SWS_PRINT_INFO)\n                av_log(c, AV_LOG_INFO, \"output width is not a multiple of 32 -> no MMX2 scaler\\n\");\n        }\n        if (usesHFilter) c->canMMX2BeUsed=0;\n    }\n    else\n        c->canMMX2BeUsed=0;\n\n    c->chrXInc= ((c->chrSrcW<<16) + (c->chrDstW>>1))\/c->chrDstW;\n    c->chrYInc= ((c->chrSrcH<<16) + (c->chrDstH>>1))\/c->chrDstH;\n\n    \/\/ match pixel 0 of the src to pixel 0 of dst and match pixel n-2 of src to pixel n-2 of dst\n    \/\/ but only for the FAST_BILINEAR mode otherwise do correct scaling\n    \/\/ n-2 is the last chrominance sample available\n    \/\/ this is not perfect, but no one should notice the difference, the more correct variant\n    \/\/ would be like the vertical one, but that would require some special code for the\n    \/\/ first and last pixel\n    if (flags&SWS_FAST_BILINEAR) {\n        if (c->canMMX2BeUsed) {\n            c->lumXInc+= 20;\n            c->chrXInc+= 20;\n        }\n        \/\/we don't use the x86 asm scaler if MMX is available\n        else if (flags & SWS_CPU_CAPS_MMX) {\n            c->lumXInc = ((srcW-2)<<16)\/(dstW-2) - 20;\n            c->chrXInc = ((c->chrSrcW-2)<<16)\/(c->chrDstW-2) - 20;\n        }\n    }\n\n    \/* precalculate horizontal scaler filter coefficients *\/\n    {\n        const int filterAlign=\n            (flags & SWS_CPU_CAPS_MMX) ? 4 :\n            (flags & SWS_CPU_CAPS_ALTIVEC) ? 8 :\n            1;\n\n        initFilter(&c->hLumFilter, &c->hLumFilterPos, &c->hLumFilterSize, c->lumXInc,\n                   srcW      ,       dstW, filterAlign, 1<<14,\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BICUBIC)  : flags,\n                   srcFilter->lumH, dstFilter->lumH, c->param);\n        initFilter(&c->hChrFilter, &c->hChrFilterPos, &c->hChrFilterSize, c->chrXInc,\n                   c->chrSrcW, c->chrDstW, filterAlign, 1<<14,\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BILINEAR) : flags,\n                   srcFilter->chrH, dstFilter->chrH, c->param);\n\n#if defined(COMPILE_MMX2)\n\/\/ can't downscale !!!\n        if (c->canMMX2BeUsed && (flags & SWS_FAST_BILINEAR)) {\n            c->lumMmx2FilterCodeSize = initMMX2HScaler(      dstW, c->lumXInc, NULL, NULL, NULL, 8);\n            c->chrMmx2FilterCodeSize = initMMX2HScaler(c->chrDstW, c->chrXInc, NULL, NULL, NULL, 4);\n\n#ifdef MAP_ANONYMOUS\n            c->lumMmx2FilterCode = mmap(NULL, c->lumMmx2FilterCodeSize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n            c->chrMmx2FilterCode = mmap(NULL, c->chrMmx2FilterCodeSize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n#elif HAVE_VIRTUALALLOC\n            c->lumMmx2FilterCode = VirtualAlloc(NULL, c->lumMmx2FilterCodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n            c->chrMmx2FilterCode = VirtualAlloc(NULL, c->chrMmx2FilterCodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n#else\n            c->lumMmx2FilterCode = av_malloc(c->lumMmx2FilterCodeSize);\n            c->chrMmx2FilterCode = av_malloc(c->chrMmx2FilterCodeSize);\n#endif\n\n            c->lumMmx2Filter   = av_malloc((dstW        \/8+8)*sizeof(int16_t));\n            c->chrMmx2Filter   = av_malloc((c->chrDstW  \/4+8)*sizeof(int16_t));\n            c->lumMmx2FilterPos= av_malloc((dstW      \/2\/8+8)*sizeof(int32_t));\n            c->chrMmx2FilterPos= av_malloc((c->chrDstW\/2\/4+8)*sizeof(int32_t));\n\n            initMMX2HScaler(      dstW, c->lumXInc, c->lumMmx2FilterCode, c->lumMmx2Filter, c->lumMmx2FilterPos, 8);\n            initMMX2HScaler(c->chrDstW, c->chrXInc, c->chrMmx2FilterCode, c->chrMmx2Filter, c->chrMmx2FilterPos, 4);\n\n#ifdef MAP_ANONYMOUS\n            mprotect(c->lumMmx2FilterCode, c->lumMmx2FilterCodeSize, PROT_EXEC | PROT_READ);\n            mprotect(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize, PROT_EXEC | PROT_READ);\n#endif\n        }\n#endif \/* defined(COMPILE_MMX2) *\/\n    } \/\/ initialize horizontal stuff\n\n\n\n    \/* precalculate vertical scaler filter coefficients *\/\n    {\n        const int filterAlign=\n            (flags & SWS_CPU_CAPS_MMX) && (flags & SWS_ACCURATE_RND) ? 2 :\n            (flags & SWS_CPU_CAPS_ALTIVEC) ? 8 :\n            1;\n\n        initFilter(&c->vLumFilter, &c->vLumFilterPos, &c->vLumFilterSize, c->lumYInc,\n                   srcH      ,        dstH, filterAlign, (1<<12),\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BICUBIC)  : flags,\n                   srcFilter->lumV, dstFilter->lumV, c->param);\n        initFilter(&c->vChrFilter, &c->vChrFilterPos, &c->vChrFilterSize, c->chrYInc,\n                   c->chrSrcH, c->chrDstH, filterAlign, (1<<12),\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BILINEAR) : flags,\n                   srcFilter->chrV, dstFilter->chrV, c->param);\n\n#ifdef COMPILE_ALTIVEC\n        c->vYCoeffsBank = av_malloc(sizeof (vector signed short)*c->vLumFilterSize*c->dstH);\n        c->vCCoeffsBank = av_malloc(sizeof (vector signed short)*c->vChrFilterSize*c->chrDstH);\n\n        for (i=0;i<c->vLumFilterSize*c->dstH;i++) {\n            int j;\n            short *p = (short *)&c->vYCoeffsBank[i];\n            for (j=0;j<8;j++)\n                p[j] = c->vLumFilter[i];\n        }\n\n        for (i=0;i<c->vChrFilterSize*c->chrDstH;i++) {\n            int j;\n            short *p = (short *)&c->vCCoeffsBank[i];\n            for (j=0;j<8;j++)\n                p[j] = c->vChrFilter[i];\n        }\n#endif\n    }\n\n    \/\/ calculate buffer sizes so that they won't run out while handling these damn slices\n    c->vLumBufSize= c->vLumFilterSize;\n    c->vChrBufSize= c->vChrFilterSize;\n    for (i=0; i<dstH; i++) {\n        int chrI= i*c->chrDstH \/ dstH;\n        int nextSlice= FFMAX(c->vLumFilterPos[i   ] + c->vLumFilterSize - 1,\n                           ((c->vChrFilterPos[chrI] + c->vChrFilterSize - 1)<<c->chrSrcVSubSample));\n\n        nextSlice>>= c->chrSrcVSubSample;\n        nextSlice<<= c->chrSrcVSubSample;\n        if (c->vLumFilterPos[i   ] + c->vLumBufSize < nextSlice)\n            c->vLumBufSize= nextSlice - c->vLumFilterPos[i];\n        if (c->vChrFilterPos[chrI] + c->vChrBufSize < (nextSlice>>c->chrSrcVSubSample))\n            c->vChrBufSize= (nextSlice>>c->chrSrcVSubSample) - c->vChrFilterPos[chrI];\n    }\n\n    \/\/ allocate pixbufs (we use dynamic allocation because otherwise we would need to\n    \/\/ allocate several megabytes to handle all possible cases)\n    c->lumPixBuf= av_malloc(c->vLumBufSize*2*sizeof(int16_t*));\n    c->chrPixBuf= av_malloc(c->vChrBufSize*2*sizeof(int16_t*));\n    if (CONFIG_SWSCALE_ALPHA && isALPHA(c->srcFormat) && isALPHA(c->dstFormat))\n        c->alpPixBuf= av_malloc(c->vLumBufSize*2*sizeof(int16_t*));\n    \/\/Note we need at least one pixel more at the end because of the MMX code (just in case someone wanna replace the 4000\/8000)\n    \/* align at 16 bytes for AltiVec *\/\n    for (i=0; i<c->vLumBufSize; i++)\n        c->lumPixBuf[i]= c->lumPixBuf[i+c->vLumBufSize]= av_mallocz(VOF+1);\n    for (i=0; i<c->vChrBufSize; i++)\n        c->chrPixBuf[i]= c->chrPixBuf[i+c->vChrBufSize]= av_malloc((VOF+1)*2);\n    if (CONFIG_SWSCALE_ALPHA && c->alpPixBuf)\n        for (i=0; i<c->vLumBufSize; i++)\n            c->alpPixBuf[i]= c->alpPixBuf[i+c->vLumBufSize]= av_mallocz(VOF+1);\n\n    \/\/try to avoid drawing green stuff between the right end and the stride end\n    for (i=0; i<c->vChrBufSize; i++) memset(c->chrPixBuf[i], 64, (VOF+1)*2);\n\n    assert(2*VOFW == VOF);\n\n    assert(c->chrDstH <= dstH);\n\n    if (flags&SWS_PRINT_INFO) {\n#ifdef DITHER1XBPP\n        const char *dither= \" dithered\";\n#else\n        const char *dither= \"\";\n#endif\n        if (flags&SWS_FAST_BILINEAR)\n            av_log(c, AV_LOG_INFO, \"FAST_BILINEAR scaler, \");\n        else if (flags&SWS_BILINEAR)\n            av_log(c, AV_LOG_INFO, \"BILINEAR scaler, \");\n        else if (flags&SWS_BICUBIC)\n            av_log(c, AV_LOG_INFO, \"BICUBIC scaler, \");\n        else if (flags&SWS_X)\n            av_log(c, AV_LOG_INFO, \"Experimental scaler, \");\n        else if (flags&SWS_POINT)\n            av_log(c, AV_LOG_INFO, \"Nearest Neighbor \/ POINT scaler, \");\n        else if (flags&SWS_AREA)\n            av_log(c, AV_LOG_INFO, \"Area Averageing scaler, \");\n        else if (flags&SWS_BICUBLIN)\n            av_log(c, AV_LOG_INFO, \"luma BICUBIC \/ chroma BILINEAR scaler, \");\n        else if (flags&SWS_GAUSS)\n            av_log(c, AV_LOG_INFO, \"Gaussian scaler, \");\n        else if (flags&SWS_SINC)\n            av_log(c, AV_LOG_INFO, \"Sinc scaler, \");\n        else if (flags&SWS_LANCZOS)\n            av_log(c, AV_LOG_INFO, \"Lanczos scaler, \");\n        else if (flags&SWS_SPLINE)\n            av_log(c, AV_LOG_INFO, \"Bicubic spline scaler, \");\n        else\n            av_log(c, AV_LOG_INFO, \"ehh flags invalid?! \");\n\n        if (dstFormat==PIX_FMT_BGR555 || dstFormat==PIX_FMT_BGR565)\n            av_log(c, AV_LOG_INFO, \"from %s to%s %s \",\n                   sws_format_name(srcFormat), dither, sws_format_name(dstFormat));\n        else\n            av_log(c, AV_LOG_INFO, \"from %s to %s \",\n                   sws_format_name(srcFormat), sws_format_name(dstFormat));\n\n        if (flags & SWS_CPU_CAPS_MMX2)\n            av_log(c, AV_LOG_INFO, \"using MMX2\\n\");\n        else if (flags & SWS_CPU_CAPS_3DNOW)\n            av_log(c, AV_LOG_INFO, \"using 3DNOW\\n\");\n        else if (flags & SWS_CPU_CAPS_MMX)\n            av_log(c, AV_LOG_INFO, \"using MMX\\n\");\n        else if (flags & SWS_CPU_CAPS_ALTIVEC)\n            av_log(c, AV_LOG_INFO, \"using AltiVec\\n\");\n        else\n            av_log(c, AV_LOG_INFO, \"using C\\n\");\n    }\n\n    if (flags & SWS_PRINT_INFO) {\n        if (flags & SWS_CPU_CAPS_MMX) {\n            if (c->canMMX2BeUsed && (flags&SWS_FAST_BILINEAR))\n                av_log(c, AV_LOG_VERBOSE, \"using FAST_BILINEAR MMX2 scaler for horizontal scaling\\n\");\n            else {\n                if (c->hLumFilterSize==4)\n                    av_log(c, AV_LOG_VERBOSE, \"using 4-tap MMX scaler for horizontal luminance scaling\\n\");\n                else if (c->hLumFilterSize==8)\n                    av_log(c, AV_LOG_VERBOSE, \"using 8-tap MMX scaler for horizontal luminance scaling\\n\");\n                else\n                    av_log(c, AV_LOG_VERBOSE, \"using n-tap MMX scaler for horizontal luminance scaling\\n\");\n\n                if (c->hChrFilterSize==4)\n                    av_log(c, AV_LOG_VERBOSE, \"using 4-tap MMX scaler for horizontal chrominance scaling\\n\");\n                else if (c->hChrFilterSize==8)\n                    av_log(c, AV_LOG_VERBOSE, \"using 8-tap MMX scaler for horizontal chrominance scaling\\n\");\n                else\n                    av_log(c, AV_LOG_VERBOSE, \"using n-tap MMX scaler for horizontal chrominance scaling\\n\");\n            }\n        } else {\n#if ARCH_X86\n            av_log(c, AV_LOG_VERBOSE, \"using x86 asm scaler for horizontal scaling\\n\");\n#else\n            if (flags & SWS_FAST_BILINEAR)\n                av_log(c, AV_LOG_VERBOSE, \"using FAST_BILINEAR C scaler for horizontal scaling\\n\");\n            else\n                av_log(c, AV_LOG_VERBOSE, \"using C scaler for horizontal scaling\\n\");\n#endif\n        }\n        if (isPlanarYUV(dstFormat)) {\n            if (c->vLumFilterSize==1)\n                av_log(c, AV_LOG_VERBOSE, \"using 1-tap %s \\\"scaler\\\" for vertical scaling (YV12 like)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n            else\n                av_log(c, AV_LOG_VERBOSE, \"using n-tap %s scaler for vertical scaling (YV12 like)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        } else {\n            if (c->vLumFilterSize==1 && c->vChrFilterSize==2)\n                av_log(c, AV_LOG_VERBOSE, \"using 1-tap %s \\\"scaler\\\" for vertical luminance scaling (BGR)\\n\"\n                       \"      2-tap scaler for vertical chrominance scaling (BGR)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n            else if (c->vLumFilterSize==2 && c->vChrFilterSize==2)\n                av_log(c, AV_LOG_VERBOSE, \"using 2-tap linear %s scaler for vertical scaling (BGR)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n            else\n                av_log(c, AV_LOG_VERBOSE, \"using n-tap %s scaler for vertical scaling (BGR)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        }\n\n        if (dstFormat==PIX_FMT_BGR24)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR24 converter\\n\",\n                   (flags & SWS_CPU_CAPS_MMX2) ? \"MMX2\" : ((flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\"));\n        else if (dstFormat==PIX_FMT_RGB32)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR32 converter\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        else if (dstFormat==PIX_FMT_BGR565)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR16 converter\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        else if (dstFormat==PIX_FMT_BGR555)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR15 converter\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n\n        av_log(c, AV_LOG_VERBOSE, \"%dx%d -> %dx%d\\n\", srcW, srcH, dstW, dstH);\n    }\n    if (flags & SWS_PRINT_INFO) {\n        av_log(c, AV_LOG_DEBUG, \"lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\\n\",\n               c->srcW, c->srcH, c->dstW, c->dstH, c->lumXInc, c->lumYInc);\n        av_log(c, AV_LOG_DEBUG, \"chr srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\\n\",\n               c->chrSrcW, c->chrSrcH, c->chrDstW, c->chrDstH, c->chrXInc, c->chrYInc);\n    }\n\n    c->swScale= getSwsFunc(c);\n    return c;\n}","idx":1290891,"target":1}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}","idx":1291672,"target":1}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (INT_MAX - 16))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    return (char *)realloc((char *)ptr - diff, size + diff) + diff;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size, 32);\n#else\n    return realloc(ptr, size);\n#endif\n}","idx":635446,"target":1}
{"code":"static int biquad_init_coeffs(void *avc, struct FFIIRFilterCoeffs *c,\n                              enum IIRFilterMode filt_mode, int order,\n                              float cutoff_ratio, float stopband)\n{\n    double cos_w0, sin_w0;\n    double a0, x0, x1;\n\n    if (filt_mode != FF_FILTER_MODE_HIGHPASS &&\n        filt_mode != FF_FILTER_MODE_LOWPASS) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter currently only supports \"\n               \"high-pass and low-pass filter modes\\n\");\n        return -1;\n    }\n    if (order != 2) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter must have order of 2\\n\");\n        return -1;\n    }\n\n    cos_w0 = cos(M_PI * cutoff_ratio);\n    sin_w0 = sin(M_PI * cutoff_ratio);\n\n    a0 = 1.0 + (sin_w0 \/ 2.0);\n\n    if (filt_mode == FF_FILTER_MODE_HIGHPASS) {\n        c->gain  =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x1       = (-(1.0 + cos_w0))        \/ a0;\n    } else { \/\/ FF_FILTER_MODE_LOWPASS\n        c->gain  =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x1       =   (1.0 - cos_w0)         \/ a0;\n    }\n    c->cy[0] = (-1.0 + (sin_w0 \/ 2.0)) \/ a0;\n    c->cy[1] =  (2.0 *  cos_w0)        \/ a0;\n\n    \/\/ divide by gain to make the x coeffs integers.\n    \/\/ during filtering, the delay state will include the gain multiplication\n    c->cx[0] = lrintf(x0 \/ c->gain);\n    c->cx[1] = lrintf(x1 \/ c->gain);\n\n    return 0;\n}","idx":634857,"target":1}
{"code":"static inline void init_get_bits(GetBitContext *s, const uint8_t *buffer,\n                                 int bit_size)\n{\n    int buffer_size = (bit_size+7)>>3;\n    if (buffer_size < 0 || bit_size < 0) {\n        buffer_size = bit_size = 0;\n        buffer = NULL;\n    }\n\n    s->buffer       = buffer;\n    s->size_in_bits = bit_size;\n#if !UNCHECKED_BITSTREAM_READER\n    s->size_in_bits_plus8 = bit_size + 8;\n#endif\n    s->buffer_end   = buffer + buffer_size;\n    s->index        = 0;\n}","idx":633355,"target":1}
{"code":"tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t\/* tsize_t tilesize=0; *\/\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t\/* Fail if prior error (in particular, can't trust tiff_datasize) *\/\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count > 4) {\n                                        int retTIFFReadRawTile;\n                    \/* Ignore EOI marker of JpegTables *\/\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    \/* Store last 2 bytes of the JpegTables *\/\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    \/* Overwrite SOI marker of image scan with previously *\/\n                    \/* saved end of JpegTables *\/\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t\/* tilesize=septilesize*t2p->tiff_samplesperpixel; *\/\n\t\t\ttilecount=septilecount\/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer,\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tif ((uint64)t2p->tiff_datasize < (uint64)TIFFTileRowSize(input) * (uint64)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength) {\n\t\t\t\/* we don't know how to handle PLANARCONFIG_CONTIG, PHOTOMETRIC_YCBCR with 3 samples per pixel *\/\n\t\t\tTIFFWarning(\n\t\t\t\tTIFF2PDF_MODULE,\n\t\t\t\t\"Don't know how to collapse tile to the left\");\n\t\t} else {\n\t\t\tt2p_tile_collapse_left(\n\t\t\t\tbuffer,\n\t\t\t\tTIFFTileRowSize(input),\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth,\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); \/* JPEGTABLESMODE_NONE *\/\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality\/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality \/ 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}","idx":43603,"target":1}
{"code":"static\nECDSA_SIG *SM2_sig_gen(const EC_KEY *key, const BIGNUM *e)\n{\n    const BIGNUM *dA = EC_KEY_get0_private_key(key);\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n\n    ECDSA_SIG *sig = NULL;\n    EC_POINT *kG = NULL;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *rk = NULL;\n    BIGNUM *r = NULL;\n    BIGNUM *s = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *tmp = NULL;\n\n    kG = EC_POINT_new(group);\n    if (kG == NULL)\n        goto done;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto done;\n\n    BN_CTX_start(ctx);\n\n    k = BN_CTX_get(ctx);\n    rk = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n\n    if (tmp == NULL)\n        goto done;\n\n    \/* These values are returned and so should not be allocated out of the context *\/\n    r = BN_new();\n    s = BN_new();\n\n    if (r == NULL || s == NULL)\n        goto done;\n\n    for (;;) {\n        BN_priv_rand_range(k, order);\n\n        if (EC_POINT_mul(group, kG, k, NULL, NULL, ctx) == 0)\n            goto done;\n\n        if (EC_POINT_get_affine_coordinates_GFp(group, kG, x1, NULL, ctx) == 0)\n            goto done;\n\n        if (BN_mod_add(r, e, x1, order, ctx) == 0)\n            goto done;\n\n        \/* try again if r == 0 or r+k == n *\/\n        if (BN_is_zero(r))\n            continue;\n\n        BN_add(rk, r, k);\n\n        if (BN_cmp(rk, order) == 0)\n            continue;\n\n        BN_add(s, dA, BN_value_one());\n        BN_mod_inverse(s, s, order, ctx);\n\n        BN_mod_mul(tmp, dA, r, order, ctx);\n        BN_sub(tmp, k, tmp);\n\n        BN_mod_mul(s, s, tmp, order, ctx);\n\n        sig = ECDSA_SIG_new();\n\n        if (sig == NULL)\n            goto done;\n\n         \/* takes ownership of r and s *\/\n        ECDSA_SIG_set0(sig, r, s);\n        break;\n    }\n\n done:\n\n    if (sig == NULL) {\n        BN_free(r);\n        BN_free(s);\n    }\n\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    return sig;\n\n}","idx":394008,"target":1}
{"code":"int BN_num_bits_word(BN_ULONG l)\n{\n    static const unsigned char bits[256] = {\n        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    };\n\n#if defined(SIXTY_FOUR_BIT_LONG)\n    if (l & 0xffffffff00000000L) {\n        if (l & 0xffff000000000000L) {\n            if (l & 0xff00000000000000L) {\n                return (bits[(int)(l >> 56)] + 56);\n            } else\n                return (bits[(int)(l >> 48)] + 48);\n        } else {\n            if (l & 0x0000ff0000000000L) {\n                return (bits[(int)(l >> 40)] + 40);\n            } else\n                return (bits[(int)(l >> 32)] + 32);\n        }\n    } else\n#else\n# ifdef SIXTY_FOUR_BIT\n    if (l & 0xffffffff00000000LL) {\n        if (l & 0xffff000000000000LL) {\n            if (l & 0xff00000000000000LL) {\n                return (bits[(int)(l >> 56)] + 56);\n            } else\n                return (bits[(int)(l >> 48)] + 48);\n        } else {\n            if (l & 0x0000ff0000000000LL) {\n                return (bits[(int)(l >> 40)] + 40);\n            } else\n                return (bits[(int)(l >> 32)] + 32);\n        }\n    } else\n# endif\n#endif\n    {\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\n        if (l & 0xffff0000L) {\n            if (l & 0xff000000L)\n                return (bits[(int)(l >> 24L)] + 24);\n            else\n                return (bits[(int)(l >> 16L)] + 16);\n        } else\n#endif\n        {\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\n            if (l & 0xff00L)\n                return (bits[(int)(l >> 8)] + 8);\n            else\n#endif\n                return (bits[(int)(l)]);\n        }\n    }\n}","idx":392213,"target":1}
{"code":"void CRYPTO_destroy_dynlockid(int i)\n\t{\n\tCRYPTO_dynlock *pointer = NULL;\n\tif (i)\n\t\ti = -i-1;\n\tif (dynlock_destroy_callback == NULL)\n\t\treturn;\n\n\tCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))\n\t\treturn;\n\tpointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\n\tif (pointer != NULL)\n\t\t{\n\t\t--pointer->references;\n#ifdef REF_CHECK\n\t\tif (pointer->references < 0)\n\t\t\t{\n\t\t\tfprintf(stderr,\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\n\t\t\tabort();\n\t\t\t}\n\t\telse\n#endif\n\t\t\tif (pointer->references <= 0)\n\t\t\t\t{\n\t\t\t\tsk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpointer = NULL;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (pointer)\n\t\t{\n\t\tdynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\n\t\tOPENSSL_free(pointer);\n\t\t}\n\t}","idx":391838,"target":1}
{"code":"void PEM_dek_info(char *buf, const char *type, int len, char *str)\n\t{\n\tstatic const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;\n\tint j;\n\n\tstrcat(buf,\"DEK-Info: \");\n\tstrcat(buf,type);\n\tstrcat(buf,\",\");\n\tj=strlen(buf);\n\tfor (i=0; i<len; i++)\n\t\t{\n\t\tbuf[j+i*2]  =map[(str[i]>>4)&0x0f];\n\t\tbuf[j+i*2+1]=map[(str[i]   )&0x0f];\n\t\t}\n\tbuf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';\n\t}","idx":387288,"target":1}
{"code":"BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n        {\n\tBN_ULONG t1,t2;\n\tint c=0;\n\n\tassert(n >= 0);\n\tif (n <= 0) return((BN_ULONG)0);\n\n\tfor (;;)\n\t\t{\n\t\tt1=a[0]; t2=b[0];\n\t\tr[0]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[1]; t2=b[1];\n\t\tr[1]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[2]; t2=b[2];\n\t\tr[2]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[3]; t2=b[3];\n\t\tr[3]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\ta+=4;\n\t\tb+=4;\n\t\tr+=4;\n\t\t}\n\treturn(c);\n\t}","idx":392600,"target":1}
{"code":"static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           int max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned int i;\n\n    if (max-- < 1)\n        return (0);\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (max < (int)i)\n                return 0;\n            \/* Skip leading zeroes *\/\n            while (i && *p == 0) {\n                p++;\n                i--;\n            }\n            if (i > sizeof(long))\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return (1);\n}","idx":392777,"target":1}
