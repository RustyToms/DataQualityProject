ID,Vulnerable,Function
0008afc59c240271827d8a0fc747179da905050f,1,"DVMuxContext* dv_init_mux(AVFormatContext* s)

{

    DVMuxContext *c;

    AVStream *vst = NULL;

    int i;



    /* we support at most 1 video and 2 audio streams */

    if (s->nb_streams > 3)

        return NULL;



    c = av_mallocz(sizeof(DVMuxContext));

    if (!c)

        return NULL;



    c->n_ast = 0;

    c->ast[0] = c->ast[1] = NULL;



    /* We have to sort out where audio and where video stream is */

    for (i=0; i<s->nb_streams; i++) {

         switch (s->streams[i]->codec->codec_type) {

         case CODEC_TYPE_VIDEO:

               vst = s->streams[i];

               break;

         case CODEC_TYPE_AUDIO:

             c->ast[c->n_ast++] = s->streams[i];

             break;

         default:

               goto bail_out;

         }

    }



    /* Some checks -- DV format is very picky about its incoming streams */

    if (!vst || vst->codec->codec_id != CODEC_ID_DVVIDEO)

        goto bail_out;

    for (i=0; i<c->n_ast; i++) {

        if (c->ast[i] && (c->ast[i]->codec->codec_id != CODEC_ID_PCM_S16LE ||

                          c->ast[i]->codec->sample_rate != 48000 ||

                          c->ast[i]->codec->channels != 2))

            goto bail_out;

    }

    c->sys = dv_codec_profile(vst->codec);

    if (!c->sys)

        goto bail_out;



    if((c->n_ast > 1) && (c->sys->n_difchan < 2)) {

        /* only 1 stereo pair is allowed in 25Mbps mode */

        goto bail_out;

    }



    /* Ok, everything seems to be in working order */

    c->frames = 0;

    c->has_audio = 0;

    c->has_video = 0;

    c->start_time = (time_t)s->timestamp;



    for (i=0; i<c->n_ast; i++) {

        if (c->ast[i] && av_fifo_init(&c->audio_data[i], 100*AVCODEC_MAX_AUDIO_FRAME_SIZE) < 0) {

            while (i>0) {

                i--;

                av_fifo_free(&c->audio_data[i]);

            }

            goto bail_out;

        }

    }



    return c;



bail_out:

    av_free(c);

    return NULL;

}
"
08b277ac46da8b02e50cec455eca7cb2d12ffcf0,0,"static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size, VMStateField *field) {
    uint64_t *v = pv;
    *v = (uint64_t)qemu_get_be32(f) & 0xFFFFFFFF;
    return 0;
}"
0b8b8753e4d94901627b3e86431230f2319215c4,1,"static void perf_lifecycle(void)

{

    Coroutine *coroutine;

    unsigned int i, max;

    double duration;



    max = 1000000;



    g_test_timer_start();

    for (i = 0; i < max; i++) {

        coroutine = qemu_coroutine_create(empty_coroutine);

        qemu_coroutine_enter(coroutine, NULL);

    }

    duration = g_test_timer_elapsed();



    g_test_message(""Lifecycle %u iterations: %f s\n"", max, duration);

}
"
0e9b9edae7bebfd31fdbead4ccbbce03876a7edd,0,"static void virt_acpi_build_update(void* build_opaque) {
    AcpiBuildState* build_state = build_opaque;
    AcpiBuildTables tables;
    /*No state to update or already patched? Nothing to do.*/
    if (!build_state || build_state->patched) {
        return;
    }
    build_state->patched = true;
    acpi_build_tables_init(&tables);
    virt_acpi_build(build_state->guest_info, &tables);
    if (tables.table_data) {
        acpi_ram_update(build_state->table_mr, tables.table_data);
    }
    if (tables.rsdp) {
        acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
    }
    if (tables.linker) {
        acpi_ram_update(build_state->linker_mr, tables.linker);
    }
    acpi_build_tables_cleanup(&tables, true);
}"
0ecca7a49f8e254c12a3a1de048d738bfbb614c6,1,"static void encode_gray_bitstream(HYuvContext *s, int count){

    int i;

    

    count/=2;

    if(s->flags&CODEC_FLAG_PASS1){

        for(i=0; i<count; i++){

            s->stats[0][ s->temp[0][2*i  ] ]++;

            s->stats[0][ s->temp[0][2*i+1] ]++;

        }

    }else if(s->context){

        for(i=0; i<count; i++){

            s->stats[0][ s->temp[0][2*i  ] ]++;

            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);

            s->stats[0][ s->temp[0][2*i+1] ]++;

            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);

        }

    }else{

        for(i=0; i<count; i++){

            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);

            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);

        }

    }

}
"
116d0963cadfbf55ef2ec3d13781987c4d80517a,1,"void PrintPreviewDataService::RemoveEntry(
    const std::string& preview_ui_addr_str) {
  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);
  if (it != data_store_map_.end())
    data_store_map_.erase(it);
 }
"
14a10fc39923b3af07c8c46d22cb20843bee3a72,1,"static void m68k_cpu_realizefn(DeviceState *dev, Error **errp)

{

    M68kCPU *cpu = M68K_CPU(dev);

    M68kCPUClass *mcc = M68K_CPU_GET_CLASS(dev);



    m68k_cpu_init_gdb(cpu);



    cpu_reset(CPU(cpu));



    mcc->parent_realize(dev, errp);

}
"
18995b9808dc48897bda6ed93ce3e978191f7251,1,"static int announce_self_create(uint8_t *buf, 

				uint8_t *mac_addr)

{

    uint32_t magic = EXPERIMENTAL_MAGIC;

    uint16_t proto = htons(ETH_P_EXPERIMENTAL);



    /* FIXME: should we send a different packet (arp/rarp/ping)? */



    memset(buf, 0, 64);

    memset(buf, 0xff, 6);         /* h_dst */

    memcpy(buf + 6, mac_addr, 6); /* h_src */

    memcpy(buf + 12, &proto, 2);  /* h_proto */

    memcpy(buf + 14, &magic, 4);  /* magic */



    return 64; /* len */

}
"
1c02a9732aa2e5ec0eaf83e65044704af05e8400,1,"static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){

    MpegEncContext * const s= &w->s;



    switch(w->abt_type_table[n]){

    case 0:

        if (s->block_last_index[n] >= 0) {

            s->dsp.idct_add (dst, stride, block1);

        }

        break;

    case 1:

        simple_idct84_add(dst           , stride, block1);

        simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);

        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));

        break;

    case 2:

        simple_idct48_add(dst           , stride, block1);

        simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);

        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));

        break;

    default:

        av_log(s->avctx, AV_LOG_ERROR, ""internal error in WMV2 abt\n"");

    }

}
"
1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3,0,"long do_sigreturn(CPUM68KState*env){struct target_sigframe*frame;abi_ulong frame_addr=env->aregs[7]-4;target_sigset_t target_set;sigset_t set;int d0, i;if(!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))goto badframe;if (!frame) goto badframe;/*set blocked signals*/if(__get_user(target_set.sig[0], &frame->sc.sc_mask))goto badframe;for(i=1;i<TARGET_NSIG_WORDS;i++){if(__get_user(target_set.sig[i], &frame->extramask[i-1]))goto badframe;}target_to_host_sigset_internal(&set, &target_set);sigprocmask(SIG_SETMASK, &set, NULL);/*restore registers*/if(restore_sigcontext(env, &frame->sc, &d0))goto badframe;unlock_user_struct(frame, frame_addr, 0);return d0;badframe:
    unlock_user_struct(frame, frame_addr, 0);force_sig(TARGET_SIGSEGV);return 0;}"
233aa5c2d1cf4655ffe335025a68cf5454f87dad,1,"static void tcp_wait_for_connect(void *opaque)

{

    MigrationState *s = opaque;

    int val, ret;

    socklen_t valsize = sizeof(val);



    DPRINTF(""connect completed\n"");

    do {

        ret = getsockopt(s->fd, SOL_SOCKET, SO_ERROR, (void *) &val, &valsize);

    } while (ret == -1 && (socket_error()) == EINTR);



    if (ret < 0) {

        migrate_fd_error(s);

        return;

    }



    qemu_set_fd_handler2(s->fd, NULL, NULL, NULL, NULL);



    if (val == 0)

        migrate_fd_connect(s);

    else {

        DPRINTF(""error connecting %d\n"", val);

        migrate_fd_error(s);

    }

}
"
269fc8e04906ffd965aa19425ca90980b23c6508,0,"static int write_trailer(AVFormatContext *s) {
    if (!s || !s->priv_data || !s->pb) return -1;
    WVMuxContext *wc = s->priv_data;
    AVIOContext *pb = s->pb;
    ff_ape_write(s);
    if (pb->seekable) {
        avio_seek(pb, 12, SEEK_SET);
        avio_wl32(pb, wc->duration);
        avio_flush(pb);
    }
    return 0;
}"
295c883fe3105b19bcd0f9e07d54c6b589fc5bff,1,"OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(
        OMX_INDEXTYPE index, OMX_PTR params) {
    ALOGV(""SoftFlacEncoder::internalGetParameter(index=0x%x)"", index);

 switch (index) {
 case OMX_IndexParamAudioPcm:
 {

             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
 
             if (pcmParams->nPortIndex > 1) {
                 return OMX_ErrorUndefined;
             }

            pcmParams->eNumData = OMX_NumericalDataSigned;
            pcmParams->eEndian = OMX_EndianBig;
            pcmParams->bInterleaved = OMX_TRUE;
            pcmParams->nBitPerSample = 16;
            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;

            pcmParams->nChannels = mNumChannels;
            pcmParams->nSamplingRate = mSampleRate;

 return OMX_ErrorNone;
 }


         case OMX_IndexParamAudioFlac:
         {
             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;
             flacParams->nCompressionLevel = mCompressionLevel;
             flacParams->nChannels = mNumChannels;
             flacParams->nSampleRate = mSampleRate;
 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::internalGetParameter(index, params);
 }
}
"
2df0c32ea12ddfa72ba88309812bfb13b674130f,0,"av_cold void ff_af_queue_init(AVCodecContext* avctx, AudioFrameQueue* afq) {
    if (!avctx || !afq) return;
    afq->avctx = avctx;
    afq->next_pts = AV_NOPTS_VALUE;
    afq->remaining_delay = avctx->delay;
    afq->remaining_samples = avctx->delay;
    afq->frame_queue = NULL;
}"
3098dba01c7daab60762b6f6624ea88c0d6cb65a,0,"void gdb_do_syscall(gdb_syscall_complete_cb cb, const char*fmt, ...){
    va_list va;
    char buf[256];
    char*p;
    target_ulong addr;
    uint64_t i64;
    GDBState*s;
    s=gdbserver_state;
    if(!s)return;
    gdb_current_syscall_cb=cb;
    s->state=RS_SYSCALL;
    #ifndef CONFIG_USER_ONLY    
    vm_stop(EXCP_DEBUG);
    #endif    
    s->state=RS_IDLE;
    va_start(va, fmt);
    p=buf;
    *(p++)='F';
    while(*fmt){
        if(*fmt == '%'){
            fmt++;
            switch(*fmt++){
                case 'x':
                    addr=va_arg(va, target_ulong);
                    p+=snprintf(p, sizeof(buf) - (p - buf), TARGET_FMT_lx, addr);
                    break;
                case 'l':
                    if(*(fmt++) != 'x')
                        goto bad_format;
                    i64=va_arg(va, uint64_t);
                    p+=snprintf(p, sizeof(buf) - (p - buf), ""%"" PRIx64, i64);
                    break;
                case 's':
                    addr=va_arg(va, target_ulong);
                    p+=snprintf(p, sizeof(buf) - (p - buf), TARGET_FMT_lx ""/%x"", addr, va_arg(va, int));
                    break;
                default:
                    bad_format:
                    fprintf(stderr, ""gdbstub: Bad syscall format string '%s'\n"", fmt-1);
                    break;
            }
        } else {
            *(p++)=*(fmt++);
        }
    }
    *p=0;
    va_end(va);
    put_packet(s, buf);
    #ifdef CONFIG_USER_ONLY    
    gdb_handlesig(s->c_cpu, 0);
    #else    
    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);
    #endif    
}"
32baeafeee4f8446c2c3720b9223ad2166ca9d30,1,"static void xvid_idct_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)

{

    ff_xvid_idct(block);

    ff_put_pixels_clamped(block, dest, line_size);

}
"
38931fa8cfb074a08ce65fd1982bd4a5bef9d6fb,0,"static void usb_hid_changed(HIDState *hs) {
    if (!hs) return;
    USBHIDState *us = container_of(hs, USBHIDState, hid);
    if (!us) return;
    us->changed = 1;
    if (us->datain) {
        us->datain(us->datain_opaque);
    }
    usb_wakeup(&us->dev);
}"
39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4,1,"static void destroy_buffers(SANMVideoContext *ctx)

{

    av_freep(&ctx->frm0);

    av_freep(&ctx->frm1);

    av_freep(&ctx->frm2);

    av_freep(&ctx->stored_frame);

    av_freep(&ctx->rle_buf);

    ctx->frm0_size =

    ctx->frm1_size =

    ctx->frm2_size = 0;


}"
3b199d29cd597a3518136d78860e172060b9e83d,0,"static av_cold int rpza_decode_init(AVCodecContext *avctx) {
    if (!avctx || !avctx->priv_data)
        return AVERROR(EINVAL);
    RpzaContext *s = avctx->priv_data;
    s->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_RGB555;
    s->frame.data[0] = NULL;
    return 0;
}"
3ba35a346cd2ee86fff83a0d0534e8a2265984fd,1,"static int config_input(AVFilterLink *inlink)
{
    HQDN3DContext *s = inlink->dst->priv;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
    int i;
    s->hsub  = desc->log2_chroma_w;
    s->vsub  = desc->log2_chroma_h;
    s->depth = desc->comp[0].depth_minus1+1;
    s->line = av_malloc(inlink->w * sizeof(*s->line));
    if (!s->line)
        return AVERROR(ENOMEM);
    for (i = 0; i < 4; i++) {
        s->coefs[i] = precalc_coefs(s->strength[i], s->depth);
        if (!s->coefs[i])
            return AVERROR(ENOMEM);
    }
    if (ARCH_X86)
        ff_hqdn3d_init_x86(s);
    return 0;
}"
3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8,1,"int kvm_arch_init(KVMState *s)

{

    uint64_t identity_base = 0xfffbc000;

    int ret;

    struct utsname utsname;



    ret = kvm_get_supported_msrs(s);

    if (ret < 0) {

        return ret;

    }



    uname(&utsname);

    lm_capable_kernel = strcmp(utsname.machine, ""x86_64"") == 0;



    /*

     * On older Intel CPUs, KVM uses vm86 mode to emulate 16-bit code directly.

     * In order to use vm86 mode, an EPT identity map and a TSS  are needed.

     * Since these must be part of guest physical memory, we need to allocate

     * them, both by setting their start addresses in the kernel and by

     * creating a corresponding e820 entry. We need 4 pages before the BIOS.

     *

     * Older KVM versions may not support setting the identity map base. In

     * that case we need to stick with the default, i.e. a 256K maximum BIOS

     * size.

     */

#ifdef KVM_CAP_SET_IDENTITY_MAP_ADDR

    if (kvm_check_extension(s, KVM_CAP_SET_IDENTITY_MAP_ADDR)) {

        /* Allows up to 16M BIOSes. */

        identity_base = 0xfeffc000;



        ret = kvm_vm_ioctl(s, KVM_SET_IDENTITY_MAP_ADDR, &identity_base);

        if (ret < 0) {

            return ret;

        }

    }

#endif

    /* Set TSS base one page after EPT identity map. */

    ret = kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, identity_base + 0x1000);

    if (ret < 0) {

        return ret;

    }



    /* Tell fw_cfg to notify the BIOS to reserve the range. */

    ret = e820_add_entry(identity_base, 0x4000, E820_RESERVED);

    if (ret < 0) {

        fprintf(stderr, ""e820_add_entry() table is full\n"");

        return ret;

    }




    return 0;

}"
3e9fab690d59ac15956c3733fe0794ce1ae4c4af,1,"void hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict)

{

    Error *err = NULL;



    qmp_block_set_io_throttle(qdict_get_str(qdict, ""device""),

                              qdict_get_int(qdict, ""bps""),

                              qdict_get_int(qdict, ""bps_rd""),

                              qdict_get_int(qdict, ""bps_wr""),

                              qdict_get_int(qdict, ""iops""),

                              qdict_get_int(qdict, ""iops_rd""),

                              qdict_get_int(qdict, ""iops_wr""), &err);

    hmp_handle_error(mon, &err);

}
"
40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4,1,"MigrationState *tcp_start_outgoing_migration(Monitor *mon,

                                             const char *host_port,

                                             int64_t bandwidth_limit,

                                             int detach,

					     int blk,

					     int inc)

{

    struct sockaddr_in addr;

    FdMigrationState *s;

    int ret;



    if (parse_host_port(&addr, host_port) < 0)

        return NULL;



    s = qemu_mallocz(sizeof(*s));



    s->get_error = socket_errno;

    s->write = socket_write;

    s->close = tcp_close;

    s->mig_state.cancel = migrate_fd_cancel;

    s->mig_state.get_status = migrate_fd_get_status;

    s->mig_state.release = migrate_fd_release;



    s->mig_state.blk = blk;

    s->mig_state.shared = inc;



    s->state = MIG_STATE_ACTIVE;

    s->mon = NULL;

    s->bandwidth_limit = bandwidth_limit;

    s->fd = socket(PF_INET, SOCK_STREAM, 0);

    if (s->fd == -1) {

        qemu_free(s);

        return NULL;

    }



    socket_set_nonblock(s->fd);



    if (!detach) {

        migrate_fd_monitor_suspend(s, mon);

    }



    do {

        ret = connect(s->fd, (struct sockaddr *)&addr, sizeof(addr));

        if (ret == -1)

            ret = -(s->get_error(s));



        if (ret == -EINPROGRESS || ret == -EWOULDBLOCK)

            qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);

    } while (ret == -EINTR);



    if (ret < 0 && ret != -EINPROGRESS && ret != -EWOULDBLOCK) {

        dprintf(""connect failed\n"");

        close(s->fd);

        qemu_free(s);

        return NULL;

    } else if (ret >= 0)

        migrate_fd_connect(s);



    return &s->mig_state;

}
"
42d87b0bec018634ec81a72d3b265f3138d75e1d,1,"PP_Flash_Menu* ReadMenu(int depth,
                        const IPC::Message* m,
                        PickleIterator* iter) {
  if (depth > kMaxMenuDepth)
    return NULL;
  ++depth;

  PP_Flash_Menu* menu = new PP_Flash_Menu;
  menu->items = NULL;

  if (!m->ReadUInt32(iter, &menu->count)) {
    FreeMenu(menu);
    return NULL;
  }

   if (menu->count == 0)
     return menu;
 
   menu->items = new PP_Flash_MenuItem[menu->count];
   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);
   for (uint32_t i = 0; i < menu->count; ++i) {
    if (!ReadMenuItem(depth, m, iter, menu->items + i)) {
      FreeMenu(menu);
      return NULL;
    }
  }
  return menu;
}
"
4527ec2216109867498edc3ac8a17fd879b5d017,1,"static int decode_blocks(SnowContext *s){

    int x, y;

    int w= s->b_width;

    int h= s->b_height;

    int res;



    for(y=0; y<h; y++){

        for(x=0; x<w; x++){



            if ((res = decode_q_branch(s, 0, x, y)) < 0)

                return res;

        }

    }

    return 0;

}"
45bbbb466cf4a6280076ea5a51f67ef5bedee345,1,"void helper_divl_EAX_T0(void)

{

    unsigned int den, q, r;

    uint64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = div32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
"
46f70ff148ae01e2dc96e64c393e295a0092555d,0,"static inline bool vhost_needs_vring_endian(VirtIODevice *vdev) {
    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {
        return false;
    }
#ifdef TARGET_IS_BIENDIAN 
    #ifdef HOST_WORDS_BIGENDIAN 
        return !virtio_is_big_endian(vdev);
    #else 
        return virtio_is_big_endian(vdev);
    #endif 
#else 
    return false;
#endif 
}"
4774718e5c194026ba5ee7a28d9be49be3080e42,0,"void v9fs_device_unrealize_common(V9fsState *s, Error **errp) {
    if (s) {
        g_free(s->ctx.fs_root);
        g_free(s->tag);
    }
}"
4a23b12a031860253b58d503f296377ca076427b,1,"BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)
	{
	/* k = SHA1(PAD(A) || PAD(B) ) -- tls-srp draft 8 */

	BIGNUM *u;	
	unsigned char cu[SHA_DIGEST_LENGTH];
	unsigned char *cAB;
	EVP_MD_CTX ctxt;
	int longN;  
	if ((A == NULL) ||(B == NULL) || (N == NULL))
		return NULL;

        if ((A == NULL) ||(B == NULL) || (N == NULL))
                return NULL;
 
        longN= BN_num_bytes(N);
 
        if ((cAB = OPENSSL_malloc(2*longN)) == NULL) 
	EVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);
	EVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);
	OPENSSL_free(cAB);
	EVP_DigestFinal_ex(&ctxt, cu, NULL);
	EVP_MD_CTX_cleanup(&ctxt);

	if (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))
		return NULL;
	if (!BN_is_zero(u))
		return u;
	BN_free(u);
	return NULL;
}
"
4be746345f13e99e468c60acbd3a355e8183e3ce,0,"static void ide_set_signature(IDEState *s) {
    if (s == NULL) return;
    s->select &= 0xf0; /* clear head */
    /* put signature */
    s->nsector = 1;
    s->sector = 1;
    if (s->drive_kind == IDE_CD) {
        s->lcyl = 0x14;
        s->hcyl = 0xeb;
    } else if (s->bs) {
        s->lcyl = 0;
        s->hcyl = 0;
    } else {
        s->lcyl = 0xff;
        s->hcyl = 0xff;
    }
}"
4be746345f13e99e468c60acbd3a355e8183e3ce,0,"void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req) {
    SCSIRequest *sreq;
    if (!req) return;
    sreq = req->sreq;
    if (!sreq) return;
    if (!scsi_req_enqueue(sreq)) return;
    scsi_req_continue(sreq);
    if (sreq->dev && sreq->dev->conf.bs) {
        bdrv_io_unplug(sreq->dev->conf.bs);
    }
    scsi_req_unref(sreq);
}"
54648cf1ec2d7f4b6a71767799c45676a138ca24,1,"int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
 	return -ENOMEM;
 }
"
57d77b3963ce1023eaf5ada8cba58b9379405cc8,0,"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t* src_buf, size_t buf_size) {
    if (buf_size > (SIZE_MAX / sizeof(uint8_t))) return AVERROR(EINVAL);
    cl_int status;
    void* mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf, CL_TRUE, CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size, 0, NULL, NULL, &status);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer:%s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    memcpy(mapped, src_buf, buf_size);
    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer:%s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    return 0;
}"
5858dd1801883309bdd208d72ddb81c4e9fee30c,0,"static int cirrus_bitblt_common_patterncopy(CirrusVGAState *s, const uint8_t *src) {
    uint8_t *dst;
    int src_size = s->cirrus_blt_width * s->cirrus_blt_height;
    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);
    if (blit_is_unsafe(s, false) || src_size > s->cirrus_blt_srcpitch * s->cirrus_blt_height) return 0;
    (*s->cirrus_rop)(s, dst, src, s->cirrus_blt_dstpitch, 0, s->cirrus_blt_width, s->cirrus_blt_height);
    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, s->cirrus_blt_dstpitch, s->cirrus_blt_width, s->cirrus_blt_height);
    return 1;
}"
595cf1a1aa09f6214eed57bd9eb6493456918efe,0,"static int truespeech_decode_frame(AVCodecContext*avctx, void*data, int*data_size, AVPacket*avpkt){
    const uint8_t*buf=avpkt->data;
    int buf_size=avpkt->size;
    TSContext*c=avctx->priv_data;
    int i, j;
    short*samples=data;
    int consumed=0;
    int16_t out_buf[240];
    int iterations;
    if(!buf_size)return 0;
    if(buf_size<32){
        av_log(avctx, AV_LOG_ERROR, ""Too small input buffer(%d bytes), need at least 32 bytes\n"", buf_size);
        return-1;
    }
    if (*data_size < 480) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer too small\n"");
        return -1;
    }
    iterations=FFMIN(buf_size/32, *data_size/480);
    for(j=0;j<iterations;j++){
        truespeech_read_frame(c, buf+consumed);
        consumed+=32;
        truespeech_correlate_filter(c);
        truespeech_filters_merge(c);
        memset(out_buf, 0, 240*2);
        for(i=0;i<4;i++){
            truespeech_apply_twopoint_filter(c, i);
            truespeech_place_pulses(c, out_buf+i*60, i);
            truespeech_update_filters(c, out_buf+i*60, i);
            truespeech_synth(c, out_buf+i*60, i);
        }
        truespeech_save_prevvec(c);
        /*finally output decoded frame*/
        for(i=0;i<240;i++)*samples++=out_buf[i];
    }
    *data_size=consumed*15;
    return consumed;
}"
5a15b72a270b514cd442872221a788a303bdaa88,1,"  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }
"
5d5de3eba4c7890c2e8077f5b4ae569671d11cf8,0,"static void v4l2_free_buffer(void*opaque, uint8_t*unused){
    V4L2Buffer*avbuf=opaque;
    V4L2m2mContext*s=buf_to_m2mctx(avbuf);
    if(atomic_fetch_sub(&avbuf->context_refcount, 1) == 1){
        av_buffer_unref(&avbuf->context_ref);
        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);
        if(s->reinit){
            if(!atomic_load(&s->refcount))
                sem_post(&s->refsync);
        }else if(avbuf->context->streamon)
            ff_v4l2_buffer_enqueue(avbuf);
    }
}"
5dc1860d8267b1e0cb78c9ffa2a40bea2fdb3ddc,1," pim_print(netdissect_options *ndo,
           register const u_char *bp, register u_int len, const u_char *bp2)
 {
	register const u_char *ep;
 	register const struct pim *pim = (const struct pim *)bp;
 
	ep = (const u_char *)ndo->ndo_snapend;
	if (bp >= ep)
		return;
 #ifdef notyet			/* currently we see only version and type */
 	ND_TCHECK(pim->pim_rsv);
 #endif
 
 	switch (PIM_VER(pim->pim_typever)) {
 	case 2:
 		if (!ndo->ndo_vflag) {
			ND_PRINT((ndo, ""PIMv%u, %s, length %u"",
			          PIM_VER(pim->pim_typever),
			          tok2str(pimv2_type_values,""Unknown Type"",PIM_TYPE(pim->pim_typever)),
			          len));
			return;
		} else {
			ND_PRINT((ndo, ""PIMv%u, length %u\n\t%s"",
			          PIM_VER(pim->pim_typever),
			          len,
			          tok2str(pimv2_type_values,""Unknown Type"",PIM_TYPE(pim->pim_typever))));
			pimv2_print(ndo, bp, len, bp2);
		}
		break;
	default:
		ND_PRINT((ndo, ""PIMv%u, length %u"",
		          PIM_VER(pim->pim_typever),
		          len));
 		break;
 	}
 	return;
 }
"
5fb88938e3210391f8c948f127fd96d9c2979119,1,"void ExtensionServiceBackend::OnExtensionInstalled(
     const scoped_refptr<const Extension>& extension) {
   CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
   if (frontend_.get())
    frontend_->OnExtensionInstalled(extension);
 }
"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"acl_get_file_mode(const char* path_p) {
    if (path_p == NULL) return NULL;
    struct stat st;
    if (lstat(path_p, &st) != 0) return NULL;
    return acl_from_mode(st.st_mode);
}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"int max_name_length(struct name_list* names) {
    int max_len = 0;
    while (names != NULL) {
        struct name_list* next = names->next;
        if (names->name != NULL) {
            int len = strlen(names->name);
            if (len > max_len)
                max_len = len;
        }
        names = next;
    }
    return max_len;
}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"int show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,
              acl_entry_t *acl_ent, const char *acl_mask,
              struct name_list **dacl_names, acl_t dacl,
	      acl_entry_t *dacl_ent, const char *dacl_mask)
{
	acl_tag_t tag_type;
	const char *tag, *name;
	char acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];

	if (acl) {
		acl_get_tag_type(*acl_ent, &tag_type);
		name = (*acl_names)->name;
	} else {
		acl_get_tag_type(*dacl_ent, &tag_type);
		name = (*dacl_names)->name;
	}

	switch(tag_type) {
		case ACL_USER_OBJ:
			tag = ""USER"";
			break;
		case ACL_USER:
			tag = ""user"";
			break;
		case ACL_GROUP_OBJ:
			tag = ""GROUP"";
			break;
		case ACL_GROUP:
			tag = ""group"";
			break;
		case ACL_MASK:
			tag = ""mask"";
			break;
		case ACL_OTHER:
			tag = ""other"";
			break;
		default:
			return -1;
	}

	memset(acl_perm, ' ', ACL_PERMS);
	acl_perm[ACL_PERMS] = '\0';
	if (acl_ent) {
		acl_perm_str(*acl_ent, acl_perm);
		if (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&
		    tag_type != ACL_MASK)
			apply_mask(acl_perm, acl_mask);
	}
	memset(dacl_perm, ' ', ACL_PERMS);
	dacl_perm[ACL_PERMS] = '\0';
	if (dacl_ent) {
		acl_perm_str(*dacl_ent, dacl_perm);
		if (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&
		    tag_type != ACL_MASK)
			apply_mask(dacl_perm, dacl_mask);
	}

	fprintf(stream, ""%-5s  %*s  %*s  %*s\n"",
	        tag, -names_width, name,
	        -(int)ACL_PERMS, acl_perm,
		-(int)ACL_PERMS, dacl_perm);

	if (acl_names) {
		acl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);
		(*acl_names) = (*acl_names)->next;
	}
	if (dacl_names) {
		acl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);
		(*dacl_names) = (*dacl_names)->next;
	}
	return 0;
}
"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"static const char*xquote(const char*str, const char*quote_chars){if(str == NULL || quote_chars == NULL) {fprintf(stderr, ""%s: Invalid input\n"", progname);exit(1);}const char*q=quote(str, quote_chars);if(q == NULL){fprintf(stderr, ""%s:%s\n"", progname, strerror(errno));exit(1);}return q;}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"struct name_list* get_list(const struct stat* st, acl_t acl) {
    struct name_list* first = NULL, * last = NULL;
    acl_entry_t ent;
    int ret = 0;
    if (acl != NULL)
        ret = acl_get_entry(acl, ACL_FIRST_ENTRY, &ent);
    if (ret != 1)
        return NULL;
    while (ret > 0) {
        acl_tag_t e_type;
        const id_t* id_p;
        const char* name = """";
        int len;
        acl_get_tag_type(ent, &e_type);
        switch (e_type) {
        case ACL_USER_OBJ:
            name = user_name(st->st_uid, opt_numeric);
            break;
        case ACL_USER:
            id_p = acl_get_qualifier(ent);
            if (id_p != NULL) {
                name = user_name(*id_p, opt_numeric);
                acl_free((void*)id_p);
            }
            break;
        case ACL_GROUP_OBJ:
            name = group_name(st->st_gid, opt_numeric);
            break;
        case ACL_GROUP:
            id_p = acl_get_qualifier(ent);
            if (id_p != NULL) {
                name = group_name(*id_p, opt_numeric);
                acl_free((void*)id_p);
            }
            break;
        }
        name = xquote(name, ""\t\n\r"");
        len = strlen(name);
        if (last == NULL) {
            first = last = (struct name_list*)malloc(sizeof(struct name_list) + len + 1);
        } else {
            last->next = (struct name_list*)malloc(sizeof(struct name_list) + len + 1);
            last = last->next;
        }
        if (last == NULL) {
            free_list(first);
            return NULL;
        }
        last->next = NULL;
        strncpy(last->name, name, len + 1);
        ret = acl_get_entry(acl, ACL_NEXT_ENTRY, &ent);
    }
    return first;
}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"void acl_mask_perm_str(acl_t acl, char* str, size_t size) {
    acl_entry_t entry;
    str[0] = '\0';
    if (acl_get_entry(acl, ACL_FIRST_ENTRY, &entry) != 1) return;
    for (;;) {
        acl_tag_t tag;
        acl_get_tag_type(entry, &tag);
        if (tag == ACL_MASK) {
            char temp[1024];
            acl_perm_str(entry, temp);
            if (strlen(temp) < size) {
                strcpy(str, temp);
            }
            return;
        }
        if (acl_get_entry(acl, ACL_NEXT_ENTRY, &entry) != 1) return;
    }
}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"void acl_perm_str(acl_entry_t entry, char *str, size_t size) {
    acl_permset_t permset;
    int n;
    acl_get_permset(entry, &permset);
    for (n = 0; n < (int)ACL_PERMS && n < size - 1; n++) {
        str[n] = (acl_get_perm(permset, acl_perm_defs[n].tag) ?
                  acl_perm_defs[n].c : '-');
    }
    str[n] = '\0';
}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"void apply_mask(char* perm, const char* mask) {
    const char* start = mask;
    while (*perm) {
        if (*mask == '-' && *perm >= 'a' && *perm <= 'z')
            *perm = *perm - 'a' + 'A';
        perm++;
        if (*mask)
            mask++;
        if (!*mask)
            mask = start;
    }
}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"void free_list(struct name_list* names) {
    struct name_list* next;
    while (names) {
        next = names->next;
        free(names);
        names = next;
    }
}"
63451a06b7484d220750ed8574d3ee84e156daf5,0,"void help(void){printf(""%s%s--get file access control lists\n"", progname, VERSION);printf(""Usage:%s [-%s] file ...\n"", progname, cmd_line_options);#if!POSIXLY_CORRECT
    if(posixly_correct){#endif
        printf(""-d, --default           display the default access control list\n"");#if!POSIXLY_CORRECT}else{printf(""-a, --access           display the file access control list only\n""
""-d, --default           display the default access control list only\n""
""-c, --omit-header       do not display the comment header\n""
""-e, --all-effective     print all effective rights\n""
""-E, --no-effective      print no effective rights\n""
""-s, --skip-base         skip files that only have the base entries\n""
""-R, --recursive         recurse into subdirectories\n""
""-L, --logical           logical walk, follow symbolic links\n""
""-P, --physical          physical walk, do not follow symbolic links\n""
""-t, --tabular           use tabular output format\n""
""-n, --numeric           print numeric user/group identifiers\n""
""-p, --absolute-names    don't strip leading '/' in pathnames\n"");}#endif
    printf(""-v, --version           print version and exit\n""
""-h, --help              this help text\n"");}"
641bb63cd6b003ab0ca2e312a014449037d71647,0,"static int calculate_refcounts(BlockDriverState*bs, BdrvCheckResult*res, BdrvCheckMode fix, uint16_t**refcount_table, int64_t*nb_clusters){
    BDRVQcowState*s=bs->opaque;
    int64_t i;
    QCowSnapshot*sn;
    int ret;
    size_t size;
    *refcount_table=g_try_new0(uint16_t, *nb_clusters);
    if(*nb_clusters && *refcount_table == NULL){
        res->check_errors++;
        return-ENOMEM;
    }
    /*header*/
    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, 0, s->cluster_size);
    if(ret<0){
        return ret;
    }
    /*current L1 table*/
    ret=check_refcounts_l1(bs, res, *refcount_table, *nb_clusters, s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);
    if(ret<0){
        return ret;
    }
    /*snapshots*/
    for(i=0;i<s->nb_snapshots;i++){
        sn=s->snapshots+i;
        ret=check_refcounts_l1(bs, res, *refcount_table, *nb_clusters, sn->l1_table_offset, sn->l1_size, 0);
        if(ret<0){
            return ret;
        }
    }
    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, s->snapshots_offset, s->snapshots_size);
    if(ret<0){
        return ret;
    }
    /*refcount data*/
    if (__builtin_mul_overflow(s->refcount_table_size, sizeof(uint64_t), &size)) {
        return -EINVAL;
    }
    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, s->refcount_table_offset, size);
    if(ret<0){
        return ret;
    }
    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);
}"
6817ae225cd650fb1c3295d769298c38b1eba818,1,"static void command_port_read_callback(struct urb *urb)
{
	struct usb_serial_port *command_port = urb->context;
	struct whiteheat_command_private *command_info;
	int status = urb->status;
	unsigned char *data = urb->transfer_buffer;
	int result;

	command_info = usb_get_serial_port_data(command_port);
	if (!command_info) {
 		dev_dbg(&urb->dev->dev, ""%s - command_info is NULL, exiting.\n"", __func__);
 		return;
 	}
 	if (status) {
 		dev_dbg(&urb->dev->dev, ""%s - nonzero urb status: %d\n"", __func__, status);
 		if (status != -ENOENT)
			command_info->command_finished = WHITEHEAT_CMD_FAILURE;
		wake_up(&command_info->wait_command);
		return;
	}

	usb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);

	if (data[0] == WHITEHEAT_CMD_COMPLETE) {
		command_info->command_finished = WHITEHEAT_CMD_COMPLETE;
		wake_up(&command_info->wait_command);
	} else if (data[0] == WHITEHEAT_CMD_FAILURE) {
		command_info->command_finished = WHITEHEAT_CMD_FAILURE;
		wake_up(&command_info->wait_command);
	} else if (data[0] == WHITEHEAT_EVENT) {
 		/* These are unsolicited reports from the firmware, hence no
 		   waiting command to wakeup */
 		dev_dbg(&urb->dev->dev, ""%s - event received\n"", __func__);
	} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {
 		memcpy(command_info->result_buffer, &data[1],
 						urb->actual_length - 1);
 		command_info->command_finished = WHITEHEAT_CMD_COMPLETE;
		wake_up(&command_info->wait_command);
	} else
		dev_dbg(&urb->dev->dev, ""%s - bad reply from firmware\n"", __func__);

	/* Continue trying to always read */
	result = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);
	if (result)
		dev_dbg(&urb->dev->dev, ""%s - failed resubmitting read urb, error %d\n"",
			__func__, result);
}
"
68f593b48433842f3407586679fe07f3e5199ab9,0,"static int mp_decode_frame(MPADecodeContext *s, short *samples) {
    int i, nb_frames, ch;
    short *samples_ptr;
    if ((s->inbuf_ptr - s->inbuf - HEADER_SIZE) < 0) return -1;
    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, s->inbuf_ptr - s->inbuf - HEADER_SIZE);
    if (s->error_protection) get_bits(&s->gb, 16);
    dprintf(""frame%d:\n"", s->frame_count);
    switch (s->layer) {
        case 1:
            nb_frames = mp_decode_layer1(s);
            break;
        case 2:
            nb_frames = mp_decode_layer2(s);
            break;
        case 3:
        default:
            nb_frames = mp_decode_layer3(s);
            break;
    }
#if defined(DEBUG)
    for (i = 0; i < nb_frames; i++) {
        for (ch = 0; ch < s->nb_channels; ch++) {
            int j;
            printf(""%d-%d:"", i, ch);
            for (j = 0; j < SBLIMIT; j++)
                printf(""%0.6f"", (double) s->sb_samples[ch][i][j] / FRAC_ONE);
            printf(""\n"");
        }
    }
#endif    
    for (ch = 0; ch < s->nb_channels; ch++) {
        samples_ptr = samples + ch;
        for (i = 0; i < nb_frames; i++) {
            if (samples_ptr + 32 * s->nb_channels > samples + MAX_SAMPLES) return -1;
            synth_filter(s, ch, samples_ptr, s->nb_channels, s->sb_samples[ch][i]);
            samples_ptr += 32 * s->nb_channels;
        }
    }
#ifdef DEBUG    
    s->frame_count++;
#endif    
    return nb_frames * 32 * sizeof(short) * s->nb_channels;
}"
68f67ef6cf1f41e77337be3bc4bff91f3a3c6324,1,"void ASessionDescription::getFormatType(
 size_t index, unsigned long *PT,
 AString *desc, AString *params) const {
 AString format;
    getFormat(index, &format);

 const char *lastSpacePos = strrchr(format.c_str(), ' ');
    CHECK(lastSpacePos != NULL);

 char *end;
 unsigned long x = strtoul(lastSpacePos + 1, &end, 10);
    CHECK_GT(end, lastSpacePos + 1);
    CHECK_EQ(*end, '\0');

 
     *PT = x;
 
    char key[20];
    sprintf(key, ""a=rtpmap:%lu"", x);
 
     CHECK(findAttribute(index, key, desc));
 
    sprintf(key, ""a=fmtp:%lu"", x);
     if (!findAttribute(index, key, params)) {
         params->clear();
     }
}
"
6c2d1c32d084320081b0cd047f8cacd6e722d03a,1,"static void ehci_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    EHCIPCIInfo *i = data;



    k->init = usb_ehci_pci_initfn;

    k->vendor_id = i->vendor_id;

    k->device_id = i->device_id;

    k->revision = i->revision;

    k->class_id = PCI_CLASS_SERIAL_USB;

    k->config_write = usb_ehci_pci_write_config;


    dc->vmsd = &vmstate_ehci_pci;

    dc->props = ehci_pci_properties;

}"
7149fce2cac0474a5fbc5b47add1158cd8bb283e,1,"static void render_line(int x0, int y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base = dy / adx;

        int x    = x0;

        int y    = y0;

        int err  = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
"
7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1,1,"static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */
{
	spl_filesystem_object *intern = (spl_filesystem_object*)object;

 	if (intern->oth_handler && intern->oth_handler->dtor) {
 		intern->oth_handler->dtor(intern TSRMLS_CC);
 	}
 	zend_object_std_dtor(&intern->std TSRMLS_CC);
 	if (intern->_path) {
 		efree(intern->_path);
 	}
	if (intern->file_name) {
		efree(intern->file_name);
	}
	switch(intern->type) {
	case SPL_FS_INFO:
		break;
	case SPL_FS_DIR:
		if (intern->u.dir.dirp) {
			php_stream_close(intern->u.dir.dirp);
			intern->u.dir.dirp = NULL;
 		}
 		if (intern->u.dir.sub_path) {
 			efree(intern->u.dir.sub_path);
		}		
 		break;
 	case SPL_FS_FILE:
 		if (intern->u.file.stream) {
			if (intern->u.file.zcontext) {
/*				zend_list_delref(Z_RESVAL_P(intern->zcontext));*/
			}
			if (!intern->u.file.stream->is_persistent) {
				php_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);
			} else {
				php_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);
			}
			if (intern->u.file.open_mode) {
				efree(intern->u.file.open_mode);
			}
			if (intern->orig_path) {
				efree(intern->orig_path);
			}
		}
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		break;
	}

	{
		zend_object_iterator *iterator;
		iterator = (zend_object_iterator*)
				spl_filesystem_object_to_iterator(intern);
		if (iterator->data != NULL) {
			iterator->data = NULL;
			iterator->funcs->dtor(iterator TSRMLS_CC);
		}
	}
	efree(object);
 } /* }}} */
"
725353525e73bbe5b6b4d01528252675f2417a02,1,"static av_cold int ulti_decode_init(AVCodecContext *avctx)

{

    UltimotionDecodeContext *s = avctx->priv_data;



    s->avctx = avctx;

    s->width = avctx->width;

    s->height = avctx->height;

    s->blocks = (s->width / 8) * (s->height / 8);



    avctx->pix_fmt = AV_PIX_FMT_YUV410P;

    s->ulti_codebook = ulti_codebook;



    s->frame = av_frame_alloc();

    if (!s->frame)

        return AVERROR(ENOMEM);



    return 0;

}"
744c2a2d90c3c9a33c818e1ea4b7ccb5010663a0,1,"RenderProcessImpl::RenderProcessImpl()
     : ALLOW_THIS_IN_INITIALIZER_LIST(shared_mem_cache_cleaner_(
           FROM_HERE, base::TimeDelta::FromSeconds(5),
           this, &RenderProcessImpl::ClearTransportDIBCache)),
      transport_dib_next_sequence_number_(0) {
   in_process_plugins_ = InProcessPlugins();
   for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i)
     shared_mem_cache_[i] = NULL;

#if defined(OS_WIN)
  if (GetModuleHandle(L""LPK.DLL"") == NULL) {
    typedef BOOL (__stdcall *GdiInitializeLanguagePack)(int LoadedShapingDLLs);
    GdiInitializeLanguagePack gdi_init_lpk =
        reinterpret_cast<GdiInitializeLanguagePack>(GetProcAddress(
            GetModuleHandle(L""GDI32.DLL""),
            ""GdiInitializeLanguagePack""));
    DCHECK(gdi_init_lpk);
    if (gdi_init_lpk) {
      gdi_init_lpk(0);
    }
  }
#endif

  webkit_glue::SetJavaScriptFlags(
      ""--debugger-auto-break""
      "" --prof --prof-lazy"");

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  if (command_line.HasSwitch(switches::kJavaScriptFlags)) {
    webkit_glue::SetJavaScriptFlags(
        command_line.GetSwitchValueASCII(switches::kJavaScriptFlags));
  }
}
"
76d8c77430e9e0110623705bfb54d922cc2ac3ea,1,"static int decode_interrupt_cb(void *ctx)

{

    return received_nb_signals > transcode_init_done;

}
"
7df953bd456da45f761064974820ab5c3fd7b2aa,0,"static AddressSpace*q35_host_dma_iommu(PCIBus*bus, void*opaque, int devfn){
    IntelIOMMUState*s=opaque;
    VTDAddressSpace**pvtd_as;
    int bus_num=pci_bus_num(bus);
    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);
    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);
    pvtd_as=s->address_spaces[bus_num];
    if(!pvtd_as){
        pvtd_as=g_malloc0(sizeof(VTDAddressSpace*)*(VTD_PCI_DEVFN_MAX + 1));
        s->address_spaces[bus_num]=pvtd_as;
    }
    if(!pvtd_as[devfn]){
        pvtd_as[devfn]=g_malloc0(sizeof(VTDAddressSpace));
        pvtd_as[devfn]->bus_num=(uint8_t)bus_num;
        pvtd_as[devfn]->devfn=(uint8_t)devfn;
        pvtd_as[devfn]->iommu_state=s;
        pvtd_as[devfn]->context_cache_entry.context_cache_gen=0;
        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s), &s->iommu_ops, ""intel_iommu"", UINT64_MAX);
        address_space_init(&pvtd_as[devfn]->as, &pvtd_as[devfn]->iommu, ""intel_iommu"");
    }
    return &pvtd_as[devfn]->as;
}"
83ed75feba32e46f736fcce0d96a0445f29b96c2,1,"modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    prime_arg = arg->rec.policy;

    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                       rqst2name(rqstp),
                                                       ACL_MODIFY, NULL, NULL)) {
        log_unauth(""kadm5_modify_policy"", prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_MODIFY;
    } else {
        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,
                                       arg->mask);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done(""kadm5_modify_policy"",
                 ((prime_arg == NULL) ? ""(null)"" : prime_arg), errmsg,
                 &client_name, &service_name, rqstp);

         if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
     }
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
exit_func:
     free_server_handle(handle);
     return &ret;
 }
"
856d72454f03aea26fd61c728762ef9cd1d71512,0,"static void listener_add_address_space(MemoryListener*listener, AddressSpace*as){
    FlatView*view;
    FlatRange*fr;
    if (!listener || !as || !as->current_map) return;
    if(listener->address_space_filter && listener->address_space_filter != as){
        return;
    }
    if(global_dirty_log){
        if(listener->log_global_start){
            listener->log_global_start(listener);
        }
    }
    view=as->current_map;
    FOR_EACH_FLAT_RANGE(fr, view){
        MemoryRegionSection section={.mr=fr->mr, .address_space=as, .offset_within_region=fr->offset_in_region, .size=fr->addr.size, .offset_within_address_space=int128_get64(fr->addr.start), .readonly=fr->readonly, };
        if(listener->region_add){
            listener->region_add(listener, &section);
        }
    }
}"
8607f5c3072caeebbe0217df28651fffd3a79fd9,0,"static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc, hwaddr desc_pa, int i) {
    if (i < 0 || (desc_pa + i * sizeof(VRingDesc)) > MAX_MEMORY_ADDRESS) {
        return;
    }
    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc), MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));
    virtio_tswap64s(vdev, &desc->addr);
    virtio_tswap32s(vdev, &desc->len);
    virtio_tswap16s(vdev, &desc->flags);
    virtio_tswap16s(vdev, &desc->next);
}"
877b66b398518d9501513e0860c9f3a8acc70892,1," beep_print(netdissect_options *ndo, const u_char *bp, u_int length)
 {
 
	if (l_strnstart(""MSG"", 4, (const char *)bp, length)) /* A REQuest */
 		ND_PRINT((ndo, "" BEEP MSG""));
	else if (l_strnstart(""RPY "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP RPY""));
	else if (l_strnstart(""ERR "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ERR""));
	else if (l_strnstart(""ANS "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ANS""));
	else if (l_strnstart(""NUL "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP NUL""));
	else if (l_strnstart(""SEQ "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP SEQ""));
	else if (l_strnstart(""END"", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP END""));
 	else
 		ND_PRINT((ndo, "" BEEP (payload or undecoded)""));
}
"
8b34a9dbc3f2c0afe3450cb20b94cc30f450e77b,0,"static int nbd_errno_to_system_errno(int err){
    switch(err){
    case NBD_SUCCESS:
        return 0;
    case NBD_EPERM:
        return EPERM;
    case NBD_EIO:
        return EIO;
    case NBD_ENOMEM:
        return ENOMEM;
    case NBD_ENOSPC:
        return ENOSPC;
    default:
        TRACE(""Squashing unexpected error %d to EINVAL"", err);
        /*fallthrough*/
    case NBD_EINVAL:
        return EINVAL;
    }
}"
8caf02127e92939fff39b63a7ff1a5834d320191,1,"static int openfile(char *name, int flags, QDict *opts)

{

    Error *local_err = NULL;




    if (qemuio_blk) {

        fprintf(stderr, ""file open already, try 'help close'\n"");

        QDECREF(opts);

        return 1;

    }



    qemuio_blk = blk_new_open(""hda"", name, NULL, opts, flags, &local_err);

    if (!qemuio_blk) {

        fprintf(stderr, ""%s: can't open%s%s: %s\n"", progname,

                name ? "" device "" : """", name ?: """",

                error_get_pretty(local_err));

        error_free(local_err);

        return 1;

    }



    bs = blk_bs(qemuio_blk);

    if (bdrv_is_encrypted(bs)) {

        char password[256];

        printf(""Disk image '%s' is encrypted.\n"", name);

        if (qemu_read_password(password, sizeof(password)) < 0) {

            error_report(""No password given"");

            goto error;

        }

        if (bdrv_set_key(bs, password) < 0) {

            error_report(""invalid password"");

            goto error;

        }

    }





    return 0;



 error:

    blk_unref(qemuio_blk);

    qemuio_blk = NULL;

    return 1;

}"
8d04fb55dec381bc5105cb47f29d918e579e8cbd,1,"void gicv3_cpuif_update(GICv3CPUState *cs)
{
    /* Tell the CPU about its highest priority pending interrupt */
    int irqlevel = 0;
    int fiqlevel = 0;
    ARMCPU *cpu = ARM_CPU(cs->cpu);
    CPUARMState *env = &cpu->env;
    trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq,
                             cs->hppi.grp, cs->hppi.prio);
    if (cs->hppi.grp == GICV3_G1 && !arm_feature(env, ARM_FEATURE_EL3)) {
        /* If a Security-enabled GIC sends a G1S interrupt to a
         * Security-disabled CPU, we must treat it as if it were G0.
         */
        cs->hppi.grp = GICV3_G0;
    }
    if (icc_hppi_can_preempt(cs)) {
        /* We have an interrupt: should we signal it as IRQ or FIQ?
         * This is described in the GICv3 spec section 4.6.2.
         */
        bool isfiq;
        switch (cs->hppi.grp) {
        case GICV3_G0:
            isfiq = true;
            break;
        case GICV3_G1:
            isfiq = (!arm_is_secure(env) ||
                     (arm_current_el(env) == 3 && arm_el_is_aa64(env, 3)));
            break;
        case GICV3_G1NS:
            isfiq = arm_is_secure(env);
            break;
        default:
            g_assert_not_reached();
        }
        if (isfiq) {
            fiqlevel = 1;
        } else {
            irqlevel = 1;
        }
    }
    trace_gicv3_cpuif_set_irqs(gicv3_redist_affid(cs), fiqlevel, irqlevel);
    qemu_set_irq(cs->parent_fiq, fiqlevel);
    qemu_set_irq(cs->parent_irq, irqlevel);
}"
90e496386fe7fd32c189561f846b7913f95b8cf4,0,"static void read_vec_element_i32(DisasContext*s, TCGv_i32 tcg_dest, int srcidx, int element, TCGMemOp memop){
    if (srcidx < 0 || srcidx >= MAX_SRCIDX || element < 0 || element >= MAX_ELEMENT) {
        g_assert_not_reached();
    }
    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);
    switch (memop) {
    case MO_8:
        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);
        break;
    case MO_16:
        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);
        break;
    case MO_8|MO_SIGN:
        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);
        break;
    case MO_16|MO_SIGN:
        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);
        break;
    case MO_32:
    case MO_32|MO_SIGN:
        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);
        break;
    default:
        g_assert_not_reached();
    }
}"
9121d02cb33c96b444a3973579f5edc119597e81,0,"static void uart_rx_reset(UartState *s) {
    if (s == NULL) return;
    s->rx_wpos = 0;
    s->rx_count = 0;
    qemu_chr_accept_input(s->chr);
    s->r[R_SR] |= UART_SR_INTR_REMPTY;
    s->r[R_SR] &= ~UART_SR_INTR_RFUL;
}"
91bfcdb01d4869aa8f4cb67007827de63b8c2217,0,"int qcrypto_init(Error**errp){
    int ret;
    ret=gnutls_global_init();
    if(ret<0){
        error_setg(errp, ""Unable to initialize GNUTLS library:%s"", gnutls_strerror(ret));
        return-1;
    }
#ifdef DEBUG_GNUTLS
    gnutls_global_set_log_level(10);
    gnutls_global_set_log_function(qcrypto_gnutls_log);
#endif 
#ifdef CONFIG_GNUTLS_GCRYPT 
    if(!gcry_check_version(GCRYPT_VERSION)){
        error_setg(errp, ""Unable to initialize gcrypt"");
        return-1;
    }
#ifdef QCRYPTO_INIT_GCRYPT_THREADS 
    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);
#endif 
    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
#endif 
    return 0;
}"
95129d6fc9ead97155627a4ca0cfd37282883658,0,"void virtio_queue_set_align(VirtIODevice *vdev, int n, int align) {
    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
    /* virtio-1 compliant devices cannot change the alignment */
    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {
        error_report(""tried to modify queue alignment for virtio-1 device"");
        return;
    }
    /* Check that the transport told us it was going to do this */
    /* (so a buggy transport will immediately assert rather than */
    /* silently failing to migrate this state) */
    assert(k->has_variable_vring_alignment);
    if (n < 0 || n >= vdev->num_vqs) {
        error_report(""queue index out of range"");
        return;
    }
    vdev->vq[n].vring.align = align;
    virtio_queue_update_rings(vdev, n);
}"
962b289ef35087fcd8764e4e29808d8ac90157f7,1,"print_syscall_ret(int num, abi_long ret)

{

    int i;



    for(i=0;i<nsyscalls;i++)

        if( scnames[i].nr == num ) {

            if( scnames[i].result != NULL ) {

                scnames[i].result(&scnames[i],ret);

            } else {

                if( ret < 0 ) {

                    gemu_log("" = -1 errno="" TARGET_ABI_FMT_ld "" (%s)\n"", -ret, target_strerror(-ret));

                } else {

                    gemu_log("" = "" TARGET_ABI_FMT_ld ""\n"", ret);

                }

            }

            break;

        }

}
"
9be385980d37e8f4fd33f605f5fb1c3d144170a8,0,"static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent* extent, int64_t offset) {
    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;
    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;
    if (__builtin_mul_overflow(extent->end_sector, BDRV_SECTOR_SIZE, &extent_begin_offset))
        return 0;
    if (__builtin_sub_overflow(offset, extent_begin_offset, &extent_relative_offset))
        return 0;
    offset_in_cluster = extent_relative_offset % cluster_size;
    return offset_in_cluster;
}"
9d4853418ab2f754c2b63e091c29c5529b8b86ca,1,"deinterlace_row(png_bytep buffer, png_const_bytep row,
   unsigned int pixel_size, png_uint_32 w, int pass)
{
   /* The inverse of the above, 'row' is part of row 'y' of the output image,
    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute
    * the pixels of row into buffer and return the number written (to allow
    * this to be checked).
    */
   png_uint_32 xin, xout, xstep;
   xout = PNG_PASS_START_COL(pass);
   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
   for (xin=0; xout<w; xout+=xstep)
   {
      pixel_copy(buffer, xout, row, xin, pixel_size);
      ++xin;
   }
}
"
9d8256ebc0ef88fb1f35d0405893962d20cc10ad,1,"void gd_egl_scanout(DisplayChangeListener *dcl,

                    uint32_t backing_id, bool backing_y_0_top,


                    uint32_t x, uint32_t y,

                    uint32_t w, uint32_t h)

{

    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);



    vc->gfx.x = x;

    vc->gfx.y = y;

    vc->gfx.w = w;

    vc->gfx.h = h;

    vc->gfx.tex_id = backing_id;

    vc->gfx.y0_top = backing_y_0_top;



    eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,

                   vc->gfx.esurface, vc->gfx.ectx);



    if (vc->gfx.tex_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {

        gtk_egl_set_scanout_mode(vc, false);

        return;

    }



    gtk_egl_set_scanout_mode(vc, true);

    if (!vc->gfx.fbo_id) {

        glGenFramebuffers(1, &vc->gfx.fbo_id);

    }



    glBindFramebuffer(GL_FRAMEBUFFER_EXT, vc->gfx.fbo_id);

    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,

                              GL_TEXTURE_2D, vc->gfx.tex_id, 0);

}"
9f61abc8111c7c43f49ca012e957a108b9cc7610,0,"static int copy_moof(AVFormatContext *s, const char *infile, const char *outfile, int64_t size) {
    AVIOContext *in, *out;
    int ret = 0;
    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)
        return ret;
    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {
        avio_close(in);
        return ret;
    }
    while (size > 0) {
        uint8_t buf[8192];
        int n = FFMIN(size, sizeof(buf));
        n = avio_read(in, buf, n);
        if (n <= 0) {
            ret = AVERROR(EIO);
            break;
        }
        avio_write(out, buf, n);
        if (n < 0) {
            ret = AVERROR(EIO);
            break;
        }
        size -= n;
    }
    avio_flush(out);
    avio_close(out);
    avio_close(in);
    return ret;
}"
a8170e5e97ad17ca169c64ba87ae2f53850dab4c,0,"static uint64_t timer_read(void*opaque, target_phys_addr_t addr, unsigned size){
    LM32TimerState*s=opaque;
    uint32_t r=0;
    if (addr >= TIMER_NUM_REGS) {
        error_report(""lm32_timer: read access to invalid register 0x%lx"", addr);
        return 0;
    }
    switch(addr){
    case R_SR:
    case R_CR:
    case R_PERIOD:
        r=s->regs[addr];break;
    case R_SNAPSHOT:
        r=(uint32_t)ptimer_get_count(s->ptimer);break;
    default:
        error_report(""lm32_timer: read access to unknown register 0x""
                TARGET_FMT_plx, addr<<2);break;
    }
    trace_lm32_timer_memory_read(addr<<2, r);
    return r;
}"
a8170e5e97ad17ca169c64ba87ae2f53850dab4c,0,"void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size) {
    MemoryRegion *mr = g_malloc(sizeof(*mr));
    if (mr == NULL) {
        return;
    }
    isa_mmio_setup(mr, size);
    memory_region_add_subregion(get_system_memory(), base, mr);
}"
a89f364ae8740dfc31b321eed9ee454e996dc3c1,0,"int qxl_render_cursor(PCIQXLDevice*qxl, QXLCommandExt*ext){
    QXLCursorCmd*cmd=qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);
    QXLCursor*cursor;
    QEMUCursor*c;
    if(!cmd){return 1;}
    if(!dpy_cursor_define_supported(qxl->vga.con)){return 0;}
    if(qxl->debug>1 && cmd->type != QXL_CURSOR_MOVE){
        fprintf(stderr, ""%s"", __FUNCTION__);
        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);
        fprintf(stderr, ""\n"");
    }
    switch(cmd->type){
    case QXL_CURSOR_SET:
        cursor=qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);
        if(!cursor){return 1;}
        c=qxl_cursor(qxl, cursor, ext->group_id);
        if(c == NULL){c=cursor_builtin_left_ptr();}
        qemu_mutex_lock(&qxl->ssd.lock);
        if(qxl->ssd.cursor){cursor_put(qxl->ssd.cursor);}
        qxl->ssd.cursor=c;
        qxl->ssd.mouse_x=cmd->u.set.position.x;
        qxl->ssd.mouse_y=cmd->u.set.position.y;
        qemu_mutex_unlock(&qxl->ssd.lock);
        qemu_bh_schedule(qxl->ssd.cursor_bh);
        break;
    case QXL_CURSOR_MOVE:
        qemu_mutex_lock(&qxl->ssd.lock);
        qxl->ssd.mouse_x=cmd->u.position.x;
        qxl->ssd.mouse_y=cmd->u.position.y;
        qemu_mutex_unlock(&qxl->ssd.lock);
        qemu_bh_schedule(qxl->ssd.cursor_bh);
        break;
    }
    return 0;
}"
a8b0ca17b80e92faab46ee7179ba9e99ccb61233,1,"static void ptrace_hbptriggered(struct perf_event *bp, int unused,
 				     struct perf_sample_data *data,
 				     struct pt_regs *regs)
 {
	struct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);
	long num;
	int i;
	siginfo_t info;

	for (i = 0; i < ARM_MAX_HBP_SLOTS; ++i)
		if (current->thread.debug.hbp[i] == bp)
			break;

	num = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i);

	info.si_signo	= SIGTRAP;
	info.si_errno	= (int)num;
	info.si_code	= TRAP_HWBKPT;
	info.si_addr	= (void __user *)(bkpt->trigger);

	force_sig_info(SIGTRAP, &info, current);
}
"
a9f9b7f5c70e80245983e67b8ed23212d9637645,1,"static int mov_text_decode_close(AVCodecContext *avctx)

{

    MovTextContext *m = avctx->priv_data;

    mov_text_cleanup_ftab(m);


    return 0;

}"
avian-v1.2.0-0,0,"void arrayCopy(Thread* t, 
               object src, 
               int32_t srcOffset, 
               object dst, 
               int32_t dstOffset, 
               int32_t length)
{
  if(LIKELY(src and dst)){
    if(LIKELY(compatibleArrayTypes(
            t, objectClass(t, src), objectClass(t, dst)))){
      unsigned elementSize=objectClass(t, src)->arrayElementSize();
      if(LIKELY(elementSize)){
        intptr_t sl=fieldAtOffset<uintptr_t>(src, BytesPerWord);
        intptr_t dl=fieldAtOffset<uintptr_t>(dst, BytesPerWord);
        if(LIKELY(length>0)){
          if(LIKELY(srcOffset >= 0 and (int64_t)srcOffset + (int64_t)length <= sl 
                     and dstOffset >= 0 and (int64_t)dstOffset + (int64_t)length <= dl)){
            uint8_t* sbody = &fieldAtOffset<uint8_t>(src, ArrayBody);
            uint8_t* dbody = &fieldAtOffset<uint8_t>(dst, ArrayBody);
            if(src == dst){
              memmove(dbody + (dstOffset * elementSize), 
                      sbody + (srcOffset * elementSize), 
                      length * elementSize);
            } else {
              memcpy(dbody + (dstOffset * elementSize), 
                     sbody + (srcOffset * elementSize), 
                     length * elementSize);
            }
            if(objectClass(t, dst)->objectMask()){
              mark(t, dst, ArrayBody + (dstOffset * BytesPerWord), length);
            }
            return;
          } else {
            throwNew(t, GcIndexOutOfBoundsException::Type);
          }
        } else {
          return;
        }
      }
    }
  } else {
    throwNew(t, GcNullPointerException::Type);
    return;
  }
  throwNew(t, GcArrayStoreException::Type);
}"
avian-v1.2.0-0,1,"void arrayCopy(Thread* t,
               object src,
               int32_t srcOffset,
               object dst,
               int32_t dstOffset,
               int32_t length)
{
  if (LIKELY(src and dst)) {
    if (LIKELY(compatibleArrayTypes(
            t, objectClass(t, src), objectClass(t, dst)))) {
      unsigned elementSize = objectClass(t, src)->arrayElementSize();

      if (LIKELY(elementSize)) {
        intptr_t sl = fieldAtOffset<uintptr_t>(src, BytesPerWord);
        intptr_t dl = fieldAtOffset<uintptr_t>(dst, BytesPerWord);
        if (LIKELY(length > 0)) {
          if (LIKELY(srcOffset >= 0 and srcOffset + length <= sl
                     and dstOffset >= 0 and dstOffset + length <= dl)) {
            uint8_t* sbody = &fieldAtOffset<uint8_t>(src, ArrayBody);
            uint8_t* dbody = &fieldAtOffset<uint8_t>(dst, ArrayBody);
            if (src == dst) {
              memmove(dbody + (dstOffset * elementSize),
                      sbody + (srcOffset * elementSize),
                      length * elementSize);
            } else {
              memcpy(dbody + (dstOffset * elementSize),
                     sbody + (srcOffset * elementSize),
                     length * elementSize);
            }

            if (objectClass(t, dst)->objectMask()) {
              mark(t, dst, ArrayBody + (dstOffset * BytesPerWord), length);
            }

            return;
          } else {
            throwNew(t, GcIndexOutOfBoundsException::Type);
          }
        } else {
          return;
        }
      }
    }
  } else {
    throwNew(t, GcNullPointerException::Type);
    return;
  }

  throwNew(t, GcArrayStoreException::Type);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static bool check_rodc_critical_attribute(struct ldb_message *msg) {
    if (msg == NULL) {
        return false;
    }
    uint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;
    schemaFlagsEx = ldb_msg_find_attr_as_uint(msg, ""schemaFlagsEx"", 0);
    searchFlags = ldb_msg_find_attr_as_uint(msg, ""searchFlags"", 0);
    rodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE | SEARCH_FLAG_CONFIDENTIAL);
    if ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) && ((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {
        return true;
    } else {
        return false;
    }
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static bool samldb_krbtgtnumber_available(struct samldb_ctx *ac, uint32_t krbtgt_number) {
    TALLOC_CTX *tmp_ctx = talloc_new(ac);
    struct ldb_result *res;
    const char *const no_attrs[] = {NULL};
    int ret;
    char query[256];
    snprintf(query, sizeof(query), ""(msDC-SecondaryKrbTgtNumber=%u)"", krbtgt_number);
    ret = dsdb_module_search(ac->module, tmp_ctx, &res, ldb_get_default_basedn(ldb_module_get_ctx(ac->module)), LDB_SCOPE_SUBTREE, no_attrs, DSDB_FLAG_NEXT_MODULE, ac->req, query);
    if (ret == LDB_SUCCESS && res->count == 0) {
        talloc_free(tmp_ctx);
        return true;
    }
    talloc_free(tmp_ctx);
    return false;
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static bool samldb_msg_add_sid(struct ldb_message *msg, const char *name, const struct dom_sid *sid) {
    if (!msg || !name || !sid) return false;
    struct ldb_val v;
    enum ndr_err_code ndr_err;
    ndr_err = ndr_push_struct_blob(&v, msg, sid, (ndr_push_flags_fn_t)ndr_push_dom_sid);
    if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
        return false;
    }
    return (ldb_msg_add_value(msg, name, &v, NULL) == 0);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_add_entry(struct samldb_ctx*ac){if(!ac || !ac->module || !ac->req) return LDB_ERR_OPERATIONS_ERROR;struct ldb_context*ldb;struct ldb_request*req;int ret;ldb=ldb_module_get_ctx(ac->module);ret=ldb_build_add_req(&req, ldb, ac, ac->msg, ac->req->controls, ac, samldb_add_entry_callback, ac->req);LDB_REQ_SET_LOCATION(req);if(ret != LDB_SUCCESS){return ret;}return ldb_next_request(ac->module, req);}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_add_entry_callback(struct ldb_request *req, struct ldb_reply *ares) {
    struct ldb_context *ldb;
    struct samldb_ctx *ac;
    int ret;
    if (!req || !ares) return LDB_ERR_OPERATIONS_ERROR;
    ac = talloc_get_type(req->context, struct samldb_ctx);
    if (!ac) return LDB_ERR_OPERATIONS_ERROR;
    ldb = ldb_module_get_ctx(ac->module);
    if (!ldb) return LDB_ERR_OPERATIONS_ERROR;
    if (ares->type == LDB_REPLY_REFERRAL) {
        return ldb_module_send_referral(ac->req, ares->referral);
    }
    if (ares->error != LDB_SUCCESS) {
        return ldb_module_done(ac->req, ares->controls, ares->response, ares->error);
    }
    if (ares->type != LDB_REPLY_DONE) {
        ldb_asprintf_errstring(ldb, ""Invalid LDB reply type%d"", ares->type);
        return ldb_module_done(ac->req, NULL, NULL, LDB_ERR_OPERATIONS_ERROR);
    }
    /* The caller may wish to get controls back from the add */
    ac->ares = talloc_steal(ac, ares);
    ret = samldb_next_step(ac);
    if (ret != LDB_SUCCESS) {
        return ldb_module_done(ac->req, NULL, NULL, ret);
    }
    return ret;
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn) {
    struct samldb_step *step, *stepper;
    if (ac == NULL || ac->module == NULL) return LDB_ERR_OPERATIONS_ERROR;
    step = talloc_zero(ac, struct samldb_step);
    if (step == NULL) {
        return ldb_oom(ldb_module_get_ctx(ac->module));
    }
    step->fn = fn;
    if (ac->steps == NULL) {
        ac->steps = step;
        ac->curstep = step;
    } else {
        if (ac->curstep == NULL) return ldb_operr(ldb_module_get_ctx(ac->module));
        for (stepper = ac->curstep; stepper->next != NULL; stepper = stepper->next);
        stepper->next = step;
    }
    return LDB_SUCCESS;
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_allocate_sid(struct samldb_ctx*ac){
    uint32_t rid;
    struct dom_sid*sid;
    struct ldb_context*ldb;
    int ret;
    if (!ac || !ac->module || !ac->req) return LDB_ERR_OPERATIONS_ERROR;
    ldb = ldb_module_get_ctx(ac->module);
    if (!ldb) return LDB_ERR_OPERATIONS_ERROR;
    ret = ridalloc_allocate_rid(ac->module, &rid, ac->req);
    if(ret != LDB_SUCCESS){
        return ret;
    }
    sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);
    if(sid == NULL){
        return ldb_module_oom(ac->module);
    }
    if(!samldb_msg_add_sid(ac->msg, ""objectSid"", sid)){
        return ldb_operr(ldb);
    }
    return samldb_next_step(ac);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_check_sAMAccountName(struct samldb_ctx*ac){
    struct ldb_context*ldb=ldb_module_get_ctx(ac->module);
    const char*name;
    int ret;
    struct ldb_result*res;
    const char*const noattrs[]={NULL};
    if(ldb_msg_find_element(ac->msg, ""sAMAccountName"") == NULL){
        ret=samldb_generate_sAMAccountName(ldb, ac->msg);
        if(ret != LDB_SUCCESS){
            return ret;
        }
    }
    name=ldb_msg_find_attr_as_string(ac->msg, ""sAMAccountName"", NULL);
    if(name == NULL){
        /*The ""sAMAccountName"" cannot be nothing*/
        ldb_set_errstring(ldb, ""samldb: Empty account names aren't allowed!"");
        return LDB_ERR_CONSTRAINT_VIOLATION;
    }
    ret=dsdb_module_search(ac->module, ac, &res, ldb_get_default_basedn(ldb), LDB_SCOPE_SUBTREE, noattrs, DSDB_FLAG_NEXT_MODULE, ac->req, ""(sAMAccountName=%s)"", ldb_binary_encode_string(ac, name));
    if(ret != LDB_SUCCESS){
        return ret;
    }
    if(res->count != 0){
        ldb_asprintf_errstring(ldb, ""samldb: Account name(sAMAccountName)'%s' already in use!"", name);
        talloc_free(res);
        return LDB_ERR_ENTRY_ALREADY_EXISTS;
    }
    talloc_free(res);
    return samldb_next_step(ac);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx*ac){
    struct ldb_context*ldb;
    const struct ldb_val*rdn_value;
    struct dom_sid*sid;
    int ret;
    if (!ac || !ac->module || !ac->msg || !ac->msg->dn) return LDB_ERR_OPERATIONS_ERROR;
    ldb=ldb_module_get_ctx(ac->module);
    sid=samdb_result_dom_sid(ac->msg, ac->msg, ""objectSid"");
    if(sid == NULL){
        rdn_value=ldb_dn_get_rdn_val(ac->msg->dn);
        if(rdn_value == NULL){
            return ldb_operr(ldb);
        }
        sid=dom_sid_parse_talloc(ac->msg, (const char*)rdn_value->data);
        if(sid == NULL){
            ldb_set_errstring(ldb, ""samldb: No valid SID found in ForeignSecurityPrincipal CN!"");
            return LDB_ERR_CONSTRAINT_VIOLATION;
        }
        if(!samldb_msg_add_sid(ac->msg, ""objectSid"", sid)){
            return ldb_operr(ldb);
        }
    }
    /*finally proceed with adding the entry*/
    ret=samldb_add_step(ac, samldb_add_entry);
    if(ret != LDB_SUCCESS)
        return ret;
    return samldb_first_step(ac);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_find_for_defaultObjectCategory(struct samldb_ctx*ac){
    struct ldb_context*ldb=ldb_module_get_ctx(ac->module);
    struct ldb_result*res;
    const char*const no_attrs[]={NULL};
    int ret;
    ac->res_dn=NULL;
    ret=dsdb_module_search(ac->module, ac, &res, ac->dn, LDB_SCOPE_BASE, no_attrs, DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT|DSDB_FLAG_NEXT_MODULE, ac->req, ""(objectClass=classSchema)"");
    if(ret == LDB_ERR_NO_SUCH_OBJECT){
        if(ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL){
            ldb_set_errstring(ldb, ""samldb_find_defaultObjectCategory: Invalid DN for 'defaultObjectCategory'!"");
            return LDB_ERR_CONSTRAINT_VIOLATION;
        }
    }
    if((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)){
        return ret;
    }
    if(ret == LDB_SUCCESS){
        if(res == NULL || res->msgs == NULL || res->msgs[0] == NULL){
            return LDB_ERR_OPERATIONS_ERROR;
        }
        struct ldb_message*m;
        m=ldb_msg_new(ac->msg);
        if(m == NULL){
            return ldb_oom(ldb);
        }
        m->dn=ac->msg->dn;
        char* category = ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1);
        if(category == NULL){
            return ldb_oom(ldb);
        }
        if(ldb_msg_add_string(m, ""defaultObjectCategory"", category) != LDB_SUCCESS){
            return ldb_oom(ldb);
        }
        m->elements[0].flags=LDB_FLAG_MOD_REPLACE;
        ret=dsdb_module_modify(ac->module, m, DSDB_FLAG_NEXT_MODULE, ac->req);
        if(ret != LDB_SUCCESS){
            return ret;
        }
    }
    ac->res_dn=ac->dn;
    return samldb_next_step(ac);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_first_step(struct samldb_ctx *ac) {
    if (ac == NULL || ac->module == NULL) {
        return LDB_ERR_OPERATIONS_ERROR;
    }
    if (ac->steps == NULL) {
        return ldb_operr(ldb_module_get_ctx(ac->module));
    }
    ac->curstep = ac->steps;
    return ac->curstep->fn(ac);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_generate_sAMAccountName(struct ldb_context *ldb, struct ldb_message *msg) {
    char *name; /* Format: $000000-000000000000 */
    name = talloc_asprintf(msg, ""$%.6X-%.12X"", (unsigned int)generate_random(), (unsigned int)generate_random());
    if (name == NULL) {
        return ldb_oom(ldb);
    }
    return ldb_msg_add_steal_string(msg, ""sAMAccountName"", name);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_next_step(struct samldb_ctx*ac){if(ac==NULL)return LDB_ERR_OPERATIONS_ERROR;if(ac->curstep==NULL)return LDB_ERR_OPERATIONS_ERROR;if(ac->curstep->next){ac->curstep=ac->curstep->next;return ac->curstep->fn(ac);}if(ac->ares){return ldb_module_done(ac->req, ac->ares->controls, ac->ares->response, LDB_SUCCESS);}else{return ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);}}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_prim_group_set(struct samldb_ctx*ac){if(!ac || !ac->module || !ac->req){return LDB_ERR_OPERATIONS_ERROR;}struct ldb_context*ldb=ldb_module_get_ctx(ac->module);uint32_t rid;rid=ldb_msg_find_attr_as_uint(ac->msg, ""primaryGroupID"", (uint32_t)-1);if(rid == (uint32_t)-1){/*we aren't affected of any primary group set*/return LDB_SUCCESS;}else if(!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)){ldb_set_errstring(ldb, ""The primary group isn't settable on add operations!"");return LDB_ERR_UNWILLING_TO_PERFORM;}return samldb_prim_group_tester(ac, rid);}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)
{
	struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
	struct dom_sid *sid;
	struct ldb_result *res;
	int ret;
	const char * const noattrs[] = { NULL };

	sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);
	if (sid == NULL) {
		return ldb_operr(ldb);
	}

	ret = dsdb_module_search(ac->module, ac, &res,
				 ldb_get_default_basedn(ldb),
				 LDB_SCOPE_SUBTREE,
				 noattrs, DSDB_FLAG_NEXT_MODULE,
				 ac->req,
				 ""(objectSid=%s)"",
				 ldap_encode_ndr_dom_sid(ac, sid));
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (res->count != 1) {
		talloc_free(res);
		ldb_asprintf_errstring(ldb,
				       ""Failed to find primary group with RID %u!"",
				       rid);
		return LDB_ERR_UNWILLING_TO_PERFORM;
	}
	talloc_free(res);

	return LDB_SUCCESS;
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_prim_group_trigger(struct samldb_ctx*ac){
    int ret;
    if (ac == NULL || ac->req == NULL) return -1;
    if(ac->req->operation == LDB_ADD){
        ret=samldb_prim_group_set(ac);
    } else {
        ret=samldb_prim_group_change(ac);
    }
    return ret;
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_rodc_add(struct samldb_ctx*ac){
    struct ldb_context*ldb=ldb_module_get_ctx(ac->module);
    uint32_t krbtgt_number, i_start, i;
    int ret;
    char*newpass;
    struct ldb_val newpass_utf16;
    /*find a unused msDC-SecondaryKrbTgtNumber*/
    i_start=generate_secure_random()&0xFFFF;
    if(i_start == 0){i_start=1;}
    for(i=i_start;i <= 0xFFFF;i++){
        if(samldb_krbtgtnumber_available(ac, i)){
            krbtgt_number=i;
            goto found;
        }
    }
    for(i=1;i<i_start;i++){
        if(samldb_krbtgtnumber_available(ac, i)){
            krbtgt_number=i;
            goto found;
        }
    }
    ldb_asprintf_errstring(ldb, ""%08X: Unable to find available msDS-SecondaryKrbTgtNumber"", W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));
    return LDB_ERR_OTHER;
found:
    ret=ldb_msg_add_empty(ac->msg, ""msDS-SecondaryKrbTgtNumber"", LDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);
    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}
    ret=samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""msDS-SecondaryKrbTgtNumber"", krbtgt_number);
    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}
    ret=ldb_msg_add_fmt(ac->msg, ""sAMAccountName"", ""krbtgt_%u"", krbtgt_number);
    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}
    newpass=generate_secure_random_password(ac->msg, 128, 255);
    if(newpass == NULL){return ldb_operr(ldb);}
    if(!convert_string_talloc(ac, CH_UNIX, CH_UTF16, newpass, strlen(newpass), (void*)&newpass_utf16.data, &newpass_utf16.length)){
        ldb_asprintf_errstring(ldb, ""samldb_rodc_add: ""
                               ""failed to generate UTF16 password from random password"");
        return LDB_ERR_OPERATIONS_ERROR;
    }
    ret=ldb_msg_add_steal_value(ac->msg, ""clearTextPassword"", &newpass_utf16);
    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}
    return samldb_next_step(ac);
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static int samldb_schema_info_update(struct samldb_ctx*ac){
    if (!ac) return LDB_ERR_OPERATIONS_ERROR;
    int ret;
    struct ldb_context*ldb;
    struct dsdb_schema*schema;
    /*replicated update should always go through*/
    if(ldb_request_get_control(ac->req, DSDB_CONTROL_REPLICATED_UPDATE_OID)){
        return LDB_SUCCESS;
    }
    /*do not update schemaInfo during provisioning*/
    if(ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)){
        return LDB_SUCCESS;
    }
    ldb=ldb_module_get_ctx(ac->module);
    schema=dsdb_get_schema(ldb, NULL);
    if(!schema){
        ldb_debug_set(ldb, LDB_DEBUG_FATAL, ""samldb_schema_info_update: no dsdb_schema loaded"");
        DEBUG(0, (__location__ "":%s\n"", ldb_errstring(ldb)));
        return ldb_operr(ldb);
    }
    ret=dsdb_module_schema_info_update(ac->module, schema, DSDB_FLAG_NEXT_MODULE|DSDB_FLAG_AS_SYSTEM, ac->req);
    if(ret != LDB_SUCCESS){
        ldb_asprintf_errstring(ldb, ""samldb_schema_info_update: dsdb_module_schema_info_update failed with%s"", ldb_errstring(ldb));
        return ret;
    }
    return LDB_SUCCESS;
}"
b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,0,"static struct samldb_ctx* samldb_ctx_init(struct ldb_module* module, struct ldb_request* req) {
    struct ldb_context* ldb;
    struct samldb_ctx* ac;
    ldb = ldb_module_get_ctx(module);
    ac = talloc_zero(req, struct samldb_ctx);
    if (ac == NULL) {
        ldb_oom(ldb);
        return NULL;
    }
    ac->module = module;
    ac->req = req;
    return ac;
}"
b097cc52fc9126bd1a71dae8302b8536d28104dd,0,"void acpi_memory_plug_cb(HotplugHandler* hotplug_dev, MemHotplugState* mem_st, DeviceState* dev, Error** errp) {
    if (!hotplug_dev || !mem_st || !dev || !errp) {
        return;
    }
    DeviceClass* dc = DEVICE_GET_CLASS(dev);
    if (!dc || !dc->hotpluggable) {
        return;
    }
    MemStatus* mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    mdev->dimm = dev;
    mdev->is_enabled = true;
    if (dev->hotplugged) {
        mdev->is_inserting = true;
        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);
    }
}"
b2c98d9d392c87c9b9e975d30f79924719d9cbbe,0,"static int tcg_match_cmpi(TCGType type, tcg_target_long val){
    extern unsigned int facilities;
    if(facilities & FACILITY_EXT_IMM){
        if(type == TCG_TYPE_I32){
            return 1;
        } else {
            return val >= 0 && val <= 0x7fffffff;
        }
    } else {
        return val == 0;
    }
}"
b3db211f3c80bb996a704d665fe275619f728bd4,0,"static void test_validate_struct_nested(TestInputVisitorData* data, const void* unused) {
    UserDefTwo* udp = NULL;
    Visitor* v;
    v = validate_test_init(data, ""{ 'string0': 'string0', ""
                           ""'dict1':{'string1': 'string1', ""
                           ""'dict2':{'userdef':{'integer': 42, ""
                           ""'string': 'string' }, 'string': 'string2'}}}"");
    if (!v) {
        return;
    }
    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);
    if (!udp) {
        return;
    }
    qapi_free_UserDefTwo(udp);
}"
b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea,0,"static int mov_write_minf_tag(AVIOContext*pb, MOVMuxContext*mov, MOVTrack*track) {
    if (!pb || !mov || !track) return AVERROR(EINVAL);
    int64_t pos = avio_tell(pb);
    int ret;
    avio_wb32(pb, 0); /*size*/
    ffio_wfourcc(pb, ""minf"");
    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)
        mov_write_vmhd_tag(pb);
    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)
        mov_write_smhd_tag(pb);
    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {
        if (track->tag == MKTAG('t', 'e', 'x', 't') || is_clcp_track(track)) {
            mov_write_gmhd_tag(pb, track);
        } else {
            mov_write_nmhd_tag(pb);
        }
    } else if (track->tag == MKTAG('r', 't', 'p', ' ')) {
        mov_write_hmhd_tag(pb);
    } else if (track->tag == MKTAG('t', 'm', 'c', 'd')) {
        mov_write_gmhd_tag(pb, track);
    }
    if (track->mode == MODE_MOV) /*FIXME: Why do it for MODE_MOV only ?*/
        mov_write_hdlr_tag(pb, NULL);
    mov_write_dinf_tag(pb);
    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)
        return ret;
    return update_size(pb, pos);
}"
b854bc196f5c4b4e3299c0b0ee63cf828ece9e77,0,"static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s, omap_clk clk) {
    int iomemtype;
    if (base & 0x7FF) {
        return; // Ensure base is properly aligned to 0x800 boundary.
    }
    s->pwl.base = base;
    omap_pwl_reset(s);
    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn, omap_pwl_writefn, s);
    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);
    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);
}"
b9f92093a10217b14d923220aaa186f41a0cf555,1,"static void decode_plane(FFV1Context *s, uint8_t *src,

                         int w, int h, int stride, int plane_index,

                         int pixel_stride)

{

    int x, y;

    int16_t *sample[2];

    sample[0] = s->sample_buffer + 3;

    sample[1] = s->sample_buffer + w + 6 + 3;



    s->run_index = 0;



    memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));



    for (y = 0; y < h; y++) {

        int16_t *temp = sample[0]; // FIXME: try a normal buffer



        sample[0] = sample[1];

        sample[1] = temp;



        sample[1][-1] = sample[0][0];

        sample[0][w]  = sample[0][w - 1];



// { START_TIMER

        if (s->avctx->bits_per_raw_sample <= 8) {

            decode_line(s, w, sample, plane_index, 8);

            for (x = 0; x < w; x++)

                src[x*pixel_stride + stride * y] = sample[1][x];

        } else {

            decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);

            if (s->packed_at_lsb) {

                for (x = 0; x < w; x++) {

                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x];

                }

            } else {

                for (x = 0; x < w; x++) {

                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample) | ((uint16_t **)sample)[1][x] >> (2 * s->avctx->bits_per_raw_sample - 16);

                }

            }

        }

// STOP_TIMER(""decode-line"") }

    }

}
"
c2b38b277a7882a592f4f2ec955084b2b756daaa,0,void aio_context_setup(AioContext* ctx) {}
c2ccf4197f697c4ff143b8a786acdd875e70a89d,1,"setup_server_realm(krb5_principal sprinc)
{
    krb5_error_code     kret;
     kdc_realm_t         *newrealm;
 
     kret = 0;
     if (kdc_numrealms > 1) {
         if (!(newrealm = find_realm_data(sprinc->realm.data,
                                          (krb5_ui_4) sprinc->realm.length)))
            kret = ENOENT;
        else
            kdc_active_realm = newrealm;
    }
    else
        kdc_active_realm = kdc_realmlist[0];
    return(kret);
}
"
c351b47ce85a3a147cfa801fa9f0149ab4160834,0,"static PHP_FUNCTION(preg_match){
    php_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}"
c39ce112b60ffafbaf700853e32bea74cbb2c148,0,"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid) {
    int32_t datalen;
    int lun;
    DPRINTF(""do_busid_cmd: busid 0x%x\n"", busid);
    if (!s->current_dev) return;
    lun = busid & 7;
    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);
    if (!s->current_req) return;
    datalen = scsi_req_enqueue(s->current_req, buf);
    s->ti_size = datalen;
    if (datalen != 0) {
        s->rregs[ESP_RSTAT] = STAT_TC;
        s->dma_left = 0;
        s->dma_counter = 0;
        if (datalen > 0) {
            s->rregs[ESP_RSTAT] |= STAT_DI;
        } else {
            s->rregs[ESP_RSTAT] |= STAT_DO;
        }
        scsi_req_continue(s->current_req);
    }
    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    esp_raise_irq(s);
}"
c8b835954ae4aef797112afda3b52f8dfe3c7b74,1,"static int xan_huffman_decode(unsigned char *dest, int dest_len,

                              const unsigned char *src, int src_len)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    const unsigned char * ptr = src + byte*2;

    int ptr_len = src_len - 1 - byte*2;

    unsigned char val = ival;

    unsigned char *dest_end = dest + dest_len;

    GetBitContext gb;



    if (ptr_len < 0)

        return AVERROR_INVALIDDATA;



    init_get_bits(&gb, ptr, ptr_len * 8);



    while ( val != 0x16 ) {

        val = src[val - 0x17 + get_bits1(&gb) * byte];



        if ( val < 0x16 ) {

            if (dest >= dest_end)

                return 0;

            *dest++ = val;

            val = ival;

        }

    }



    return 0;

}
"
cb77dad72414940837bdb01dad5e747175d6a01f,1,"static int ea_read_header(AVFormatContext *s,
                          AVFormatParameters *ap)
{
    EaDemuxContext *ea = s->priv_data;
    AVStream *st;
    if (!process_ea_header(s))
        return AVERROR(EIO);
    if (ea->video_codec) {
        /* initialize the video decoder stream */
        st = av_new_stream(s, 0);
        if (!st)
            return AVERROR(ENOMEM);
        ea->video_stream_index = st->index;
        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
        st->codec->codec_id = ea->video_codec;
        st->codec->codec_tag = 0;  /* no fourcc */
        st->codec->time_base = ea->time_base;
        st->codec->width = ea->width;
        st->codec->height = ea->height;
    if (ea->num_channels <= 0) {
        av_log(s, AV_LOG_WARNING, ""Unsupported number of channels: %d\n"", ea->num_channels);
    if (ea->audio_codec) {
        /* initialize the audio decoder stream */
        st = av_new_stream(s, 0);
        if (!st)
            return AVERROR(ENOMEM);
        av_set_pts_info(st, 33, 1, ea->sample_rate);
        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;
        st->codec->codec_id = ea->audio_codec;
        st->codec->codec_tag = 0;  /* no tag */
        st->codec->channels = ea->num_channels;
        st->codec->sample_rate = ea->sample_rate;
        st->codec->bits_per_coded_sample = ea->bytes * 8;
        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *
            st->codec->bits_per_coded_sample / 4;
        st->codec->block_align = st->codec->channels*st->codec->bits_per_coded_sample;
        ea->audio_stream_index = st->index;
        ea->audio_frame_counter = 0;
    return 1;"
cdd85eb2804018ab46a742ebf64dc5366b9fae73,1,"static void s390_msi_ctrl_write(void *opaque, hwaddr addr, uint64_t data,

                                unsigned int size)

{

    S390PCIBusDevice *pbdev;

    uint32_t io_int_word;

    uint32_t fid = data >> ZPCI_MSI_VEC_BITS;

    uint32_t vec = data & ZPCI_MSI_VEC_MASK;

    uint64_t ind_bit;

    uint32_t sum_bit;

    uint32_t e = 0;



    DPRINTF(""write_msix data 0x%"" PRIx64 "" fid %d vec 0x%x\n"", data, fid, vec);



    pbdev = s390_pci_find_dev_by_fid(fid);

    if (!pbdev) {

        e |= (vec << ERR_EVENT_MVN_OFFSET);

        s390_pci_generate_error_event(ERR_EVENT_NOMSI, 0, fid, addr, e);

        return;

    }



    if (pbdev->state != ZPCI_FS_ENABLED) {

        return;

    }



    ind_bit = pbdev->routes.adapter.ind_offset;

    sum_bit = pbdev->routes.adapter.summary_offset;



    set_ind_atomic(pbdev->routes.adapter.ind_addr + (ind_bit + vec) / 8,

                   0x80 >> ((ind_bit + vec) % 8));

    if (!set_ind_atomic(pbdev->routes.adapter.summary_addr + sum_bit / 8,

                                       0x80 >> (sum_bit % 8))) {

        io_int_word = (pbdev->isc << 27) | IO_INT_WORD_AI;

        s390_io_interrupt(0, 0, 0, io_int_word);

    }

}
"
cf872776fc84128bb779ce2b83a37c884c3203ae,1," static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
 {
	long tmp = *old;
	*old = atomic_long_cmpxchg(&sem->count, *old, new);
	return *old == tmp;
 }
"
cjson-v.1.7.2-0,0,"static unsigned char* print(const cJSON* const item, cJSON_bool format, const internal_hooks* const hooks) {
    static const size_t default_buffer_size = 256;
    printbuffer buffer[1];
    unsigned char* printed = NULL;
    memset(buffer, 0, sizeof(buffer));
    /*create buffer*/
    buffer->buffer = (unsigned char*)hooks->allocate(default_buffer_size);
    buffer->length = default_buffer_size;
    buffer->format = format;
    buffer->hooks = *hooks;
    if (buffer->buffer == NULL) {
        goto fail;
    }
    /*print the value*/
    if (!print_value(item, buffer)) {
        goto fail;
    }
    update_offset(buffer);
    /*check if reallocate is available*/
    if (hooks->reallocate != NULL) {
        printed = (unsigned char*)hooks->reallocate(buffer->buffer, buffer->offset + 1);
        buffer->buffer = NULL;
        if (printed == NULL) {
            goto fail;
        }
    } else /*otherwise copy the JSON over to a new buffer*/ {
        printed = (unsigned char*)hooks->allocate(buffer->offset + 1);
        if (printed == NULL) {
            goto fail;
        }
        if (buffer->offset < buffer->length) {
            memcpy(printed, buffer->buffer, buffer->offset);
            printed[buffer->offset] = '\0'; /*just to be sure*/
        }
        /*free the buffer*/
        if (buffer->buffer != NULL) {
            hooks->deallocate(buffer->buffer);
            buffer->buffer = NULL;
        }
    }
    return printed;
fail:
    if (buffer->buffer != NULL) {
        hooks->deallocate(buffer->buffer);
        buffer->buffer = NULL;
    }
    if (printed != NULL) {
        hooks->deallocate(printed);
    }
    return NULL;
}"
cjson-v.1.7.2-0,1,"static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
{
    static const size_t default_buffer_size = 256;
    printbuffer buffer[1];
    unsigned char *printed = NULL;

    memset(buffer, 0, sizeof(buffer));

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
    buffer->length = default_buffer_size;
    buffer->format = format;
    buffer->hooks = *hooks;
    if (buffer->buffer == NULL)
    {
        goto fail;
    }

    /* print the value */
    if (!print_value(item, buffer))
    {
        goto fail;
    }
    update_offset(buffer);

    /* check if reallocate is available */
    if (hooks->reallocate != NULL)
    {
        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
        buffer->buffer = NULL;
        if (printed == NULL) {
            goto fail;
        }
    }
    else /* otherwise copy the JSON over to a new buffer */
    {
        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
        if (printed == NULL)
        {
            goto fail;
        }
        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
        printed[buffer->offset] = '\0'; /* just to be sure */

        /* free the buffer */
        hooks->deallocate(buffer->buffer);
    }

    return printed;

fail:
    if (buffer->buffer != NULL)
    {
        hooks->deallocate(buffer->buffer);
    }

    if (printed != NULL)
    {
        hooks->deallocate(printed);
    }

    return NULL;
}"
cjson-v.1.7.3-0,0,"static cJSON_bool add_item_to_object(cJSON*const object, const char*const string, cJSON*const item, const internal_hooks*const hooks, const cJSON_bool constant_key){
    if((object == NULL) || (string == NULL) || (item == NULL)){
        return false;
    }
    if(!(item->type & cJSON_StringIsConst) && (item->string != NULL)){
        hooks->deallocate(item->string);
        item->string = NULL;
    }
    if(constant_key){
        item->string = (char*)string;
        item->type |= cJSON_StringIsConst;
    } else {
        char* key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
        if(key == NULL){
            return false;
        }
        item->string = key;
        item->type &= ~cJSON_StringIsConst;
    }
    return add_item_to_array(object, item);
}"
cjson-v.1.7.3-0,1,"static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
{
    if ((object == NULL) || (string == NULL) || (item == NULL))
    {
        return false;
    }

    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
    {
        hooks->deallocate(item->string);
    }

    if (constant_key)
    {
        item->string = (char*)cast_away_const(string);
        item->type |= cJSON_StringIsConst;
    }
    else
    {
        char *key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
        if (key == NULL)
        {
            return false;
        }

        item->string = key;
        item->type &= ~cJSON_StringIsConst;
    }

    return add_item_to_array(object, item);
}"
curl-curl-7_56_1-0,0,"CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char*user, size_t userlen, const char*domain, size_t domlen, unsigned char*ntlmhash, unsigned char*ntlmv2hash) {
    if(userlen > (SIZE_MAX / 2) || domlen > (SIZE_MAX / 2) || (userlen + domlen) > (SIZE_MAX / 2))
        return CURLE_OUT_OF_MEMORY;
    size_t identity_len = (userlen + domlen) * 2;
    unsigned char* identity = malloc(identity_len);
    CURLcode result = CURLE_OK;
    if(!identity)
        return CURLE_OUT_OF_MEMORY;
    ascii_uppercase_to_unicode_le(identity, user, userlen);
    ascii_to_unicode_le(identity + (userlen * 2), domain, domlen);
    result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len), ntlmv2hash);
    free(identity);
    return result;
}"
curl-curl-7_56_1-0,1,"CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char *user, size_t userlen,
                                       const char *domain, size_t domlen,
                                       unsigned char *ntlmhash,
                                       unsigned char *ntlmv2hash)
{
  /* Unicode representation */
  size_t identity_len = (userlen + domlen) * 2;
  unsigned char *identity = malloc(identity_len);
  CURLcode result = CURLE_OK;

  if(!identity)
    return CURLE_OUT_OF_MEMORY;

  ascii_uppercase_to_unicode_le(identity, user, userlen);
  ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);

  result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len),
                         ntlmv2hash);

  free(identity);

  return result;
}"
curl-curl-7_61_1-0,0,"static CURLcode tftp_connect(struct connectdata *conn, bool *done) {
    tftp_state_data_t *state;
    int blksize;
    blksize = TFTP_BLKSIZE_DEFAULT;
    state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));
    if (!state) return CURLE_OUT_OF_MEMORY;
    if (conn->data->set.tftp_blksize) {
        blksize = (int)conn->data->set.tftp_blksize;
        if (blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN) return CURLE_TFTP_ILLEGAL;
    }
    if (!state->rpacket.data) {
        state->rpacket.data = calloc(1, blksize + 2 + 2);
        if (!state->rpacket.data) {
            free(state);
            return CURLE_OUT_OF_MEMORY;
        }
    }
    if (!state->spacket.data) {
        state->spacket.data = calloc(1, blksize + 2 + 2);
        if (!state->spacket.data) {
            free(state->rpacket.data);
            free(state);
            return CURLE_OUT_OF_MEMORY;
        }
    }
}"
curl-curl-7_61_1-0,1,"static CURLcode tftp_connect(struct connectdata *conn, bool *done)
{
  tftp_state_data_t *state;
  int blksize;

  blksize = TFTP_BLKSIZE_DEFAULT;

  state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));
  if(!state)
    return CURLE_OUT_OF_MEMORY;

  /* alloc pkt buffers based on specified blksize */
  if(conn->data->set.tftp_blksize) {
    blksize = (int)conn->data->set.tftp_blksize;
    if(blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN)
      return CURLE_TFTP_ILLEGAL;
  }

  if(!state->rpacket.data) {
    state->rpacket.data = calloc(1, blksize + 2 + 2);

    if(!state->rpacket.data)
      return CURLE_OUT_OF_MEMORY;
  }

  if(!state->spacket.data) {
    state->spacket.data = calloc(1, blksize + 2 + 2);

    if(!state->spacket.data)
      return CURLE_OUT_OF_MEMORY;
  }"
d0bce760e04b1658a3b4ac95be2839ae20fd86db,1,"static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)

{

    uint16_t data = addr;



    memwrite(s->addr + OMAP_I2C_SA, &data, 2);

    memread(s->addr + OMAP_I2C_SA, &data, 2);

    g_assert_cmphex(data, ==, addr);

}
"
d150a147dac67faeaf6b1f25a523ae330168ee1e,0,"static int parse_picture_segment(AVCodecContext*avctx, const uint8_t*buf, int buf_size){
    PGSSubContext*ctx=avctx->priv_data;
    uint8_t sequence_desc;
    unsigned int rle_bitmap_len, width, height;
    if(buf_size <= 4)
        return-1;
    buf_size-=4;
    buf+=3;
    sequence_desc=bytestream_get_byte(&buf);
    if(!(sequence_desc&0x80)){
        if(buf_size>ctx->picture.rle_remaining_len)
            return-1;
        memcpy(ctx->picture.rle+ctx->picture.rle_data_len, buf, buf_size);
        ctx->picture.rle_data_len+=buf_size;
        ctx->picture.rle_remaining_len-=buf_size;
        return 0;
    }
    if(buf_size <= 7)
        return-1;
    buf_size-=7;
    rle_bitmap_len=bytestream_get_be24(&buf)-2*2;
    if(rle_bitmap_len > buf_size)
        return-1;
    width=bytestream_get_be16(&buf);
    height=bytestream_get_be16(&buf);
    if(avctx->width<width || avctx->height<height){
        av_log(avctx, AV_LOG_ERROR, ""Bitmap dimensions larger than video.\n"");
        return-1;
    }
    ctx->picture.w=width;
    ctx->picture.h=height;
    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);
    if(!ctx->picture.rle)
        return-1;
    if(rle_bitmap_len < buf_size)
        return-1;
    memcpy(ctx->picture.rle, buf, buf_size);
    ctx->picture.rle_data_len=buf_size;
    ctx->picture.rle_remaining_len=rle_bitmap_len-buf_size;
    return 0;
}"
d42b2388f7f8e0332c846675133acea151fc557a,1,"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,
  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,
  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,
  uint_fast32_t inmem)
{
 	jas_image_cmpt_t *cmpt;
 	size_t size;
 
 	cmpt = 0;
 	if (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {
 		goto error;
	}
	if (!jas_safe_intfast32_add(tlx, width, 0) ||
 	  !jas_safe_intfast32_add(tly, height, 0)) {
 		goto error;
 	}
 
 	if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
 		goto error;
	}

	cmpt->type_ = JAS_IMAGE_CT_UNKNOWN;
	cmpt->tlx_ = tlx;
	cmpt->tly_ = tly;
	cmpt->hstep_ = hstep;
	cmpt->vstep_ = vstep;
	cmpt->width_ = width;
	cmpt->height_ = height;
	cmpt->prec_ = depth;
	cmpt->sgnd_ = sgnd;
	cmpt->stream_ = 0;
	cmpt->cps_ = (depth + 7) / 8;

	if (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||
	  !jas_safe_size_mul(size, cmpt->cps_, &size)) {
 		goto error;
 	}
 	cmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :
	  jas_stream_tmpfile();
	if (!cmpt->stream_) {
		goto error;
	}

	/* Zero the component data.  This isn't necessary, but it is
	convenient for debugging purposes. */
	/* Note: conversion of size - 1 to long can overflow */
	if (size > 0) {
		if (size - 1 > LONG_MAX) {
			goto error;
		}
		if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||
		  jas_stream_putc(cmpt->stream_, 0) == EOF ||
		  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {
			goto error;
		}
	}

	return cmpt;

error:
	if (cmpt) {
		jas_image_cmpt_destroy(cmpt);
	}
	return 0;
}
"
d5c5b0b77b2b589666024d219a8007b3f5b6faeb,1,"static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)
 {
 	size_t n;
 	uint32_t types = up->types;

	p->types = types;
 	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 		uintptr_t a = up->vals[n * 2];
 		size_t b = up->vals[n * 2 + 1];
 
 		switch (TEE_PARAM_TYPE_GET(types, n)) {
		case TEE_PARAM_TYPE_MEMREF_INPUT:
 		case TEE_PARAM_TYPE_MEMREF_OUTPUT:
 		case TEE_PARAM_TYPE_MEMREF_INOUT:
 			p->u[n].mem.mobj = &mobj_virt;
 			p->u[n].mem.offs = a;
 			p->u[n].mem.size = b;
 			break;
 		case TEE_PARAM_TYPE_VALUE_INPUT:
 		case TEE_PARAM_TYPE_VALUE_INOUT:
			p->u[n].val.a = a;
			p->u[n].val.b = b;
			break;
		default:
			memset(&p->u[n], 0, sizeof(p->u[n]));
 			break;
 		}
 	}
 }
"
d5fc88e573fa58b93034b04d35a2454f5d28cad9,1," nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)
 {
 	NMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);
	guint32 mtu = nm_ip4_config_get_mtu (config);
 	int i;
 
 	g_return_val_if_fail (ifindex > 0, FALSE);
	g_return_val_if_fail (ifindex > 0, FALSE);
	g_return_val_if_fail (config != NULL, FALSE);

	/* Addresses */
	nm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);

	/* Routes */
	{
		int count = nm_ip4_config_get_num_routes (config);
		GArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);
		const NMPlatformIP4Route *route;
		gboolean success;

		for (i = 0; i < count; i++) {
			route = nm_ip4_config_get_route (config, i);

			/* Don't add the route if it's more specific than one of the subnets
			 * the device already has an IP address on.
			 */
			if (   route->gateway == 0
			    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))
				continue;

			g_array_append_vals (routes, route, 1);
		}

		success = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);
		g_array_unref (routes);
 			return FALSE;
 	}
 
	/* MTU */
	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))
		nm_platform_link_set_mtu (ifindex, mtu);
 	return TRUE;
 }
"
d65686849024838243515b5c40ae2c479460b4b5,1,"devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,
    int *eofp, caller_context_t *ct_unused, int flags_unused)
{
	struct sdev_node *sdvp = VTOSDEV(dvp);
	char *ptr;

	sdcmn_err13((""zv readdir of '%s' %s'"", sdvp->sdev_path,
	    sdvp->sdev_name));

	if (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {
		struct vnode *vp;

		rw_exit(&sdvp->sdev_contents);
		(void) devname_lookup_func(sdvp, ""dsk"", &vp, cred,
		    devzvol_create_dir, SDEV_VATTR);
		VN_RELE(vp);
		(void) devname_lookup_func(sdvp, ""rdsk"", &vp, cred,
		    devzvol_create_dir, SDEV_VATTR);
		VN_RELE(vp);
		rw_enter(&sdvp->sdev_contents, RW_READER);
		return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
	}
	if (uiop->uio_offset == 0)
		devzvol_prunedir(sdvp);
	ptr = sdvp->sdev_path + strlen(ZVOL_DIR);
	if ((strcmp(ptr, ""/dsk"") == 0) || (strcmp(ptr, ""/rdsk"") == 0)) {
		rw_exit(&sdvp->sdev_contents);
		devzvol_create_pool_dirs(dvp);
		rw_enter(&sdvp->sdev_contents, RW_READER);
 		return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
 	}
 
	ptr = strchr(ptr + 1, '/') + 1;
 	rw_exit(&sdvp->sdev_contents);
 	sdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);
 	rw_enter(&sdvp->sdev_contents, RW_READER);
	return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
}
"
dc8764f06155a7b3e635e02281b747a9e292127e,1,"static gboolean register_signal_handlers(void)

{

    struct sigaction sigact, sigact_chld;

    int ret;



    memset(&sigact, 0, sizeof(struct sigaction));

    sigact.sa_handler = quit_handler;



    ret = sigaction(SIGINT, &sigact, NULL);

    if (ret == -1) {

        g_error(""error configuring signal handler: %s"", strerror(errno));

        return false;

    }

    ret = sigaction(SIGTERM, &sigact, NULL);

    if (ret == -1) {

        g_error(""error configuring signal handler: %s"", strerror(errno));

        return false;

    }



    memset(&sigact_chld, 0, sizeof(struct sigaction));

    sigact_chld.sa_handler = child_handler;

    sigact_chld.sa_flags = SA_NOCLDSTOP;

    ret = sigaction(SIGCHLD, &sigact_chld, NULL);

    if (ret == -1) {

        g_error(""error configuring signal handler: %s"", strerror(errno));

    }



    return true;

}
"
dccda88f27a084bcbbb30198ace12b4e7ae961cc,1," static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)
 {
        xml_parser *parser = (xml_parser *)rsrc->ptr;
        if (parser->parser) {
                XML_ParserFree(parser->parser);
        }
	if (parser->ltags) {
		int inx;
		for (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)
			efree(parser->ltags[ inx ]);
		efree(parser->ltags);
	}
	if (parser->startElementHandler) {
		zval_ptr_dtor(&parser->startElementHandler);
	}
	if (parser->endElementHandler) {
		zval_ptr_dtor(&parser->endElementHandler);
	}
	if (parser->characterDataHandler) {
		zval_ptr_dtor(&parser->characterDataHandler);
	}
	if (parser->processingInstructionHandler) {
		zval_ptr_dtor(&parser->processingInstructionHandler);
	}
	if (parser->defaultHandler) {
		zval_ptr_dtor(&parser->defaultHandler);
	}
	if (parser->unparsedEntityDeclHandler) {
		zval_ptr_dtor(&parser->unparsedEntityDeclHandler);
	}
	if (parser->notationDeclHandler) {
		zval_ptr_dtor(&parser->notationDeclHandler);
	}
	if (parser->externalEntityRefHandler) {
		zval_ptr_dtor(&parser->externalEntityRefHandler);
	}
	if (parser->unknownEncodingHandler) {
		zval_ptr_dtor(&parser->unknownEncodingHandler);
	}
	if (parser->startNamespaceDeclHandler) {
		zval_ptr_dtor(&parser->startNamespaceDeclHandler);
	}
	if (parser->endNamespaceDeclHandler) {
		zval_ptr_dtor(&parser->endNamespaceDeclHandler);
	}
	if (parser->baseURI) {
		efree(parser->baseURI);
	}
	if (parser->object) {
		zval_ptr_dtor(&parser->object);
	}

	efree(parser);
}
"
df453700e8d81b1bdafdf684365ee2b9431fb702,1,"static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,
 			       const struct in6_addr *dst,
 			       const struct in6_addr *src)
 {
 	u32 hash, id;
 
	hash = __ipv6_addr_jhash(dst, hashrnd);
	hash = __ipv6_addr_jhash(src, hash);
	hash ^= net_hash_mix(net);
 
 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
 	 * set the hight order instead thus minimizing possible future
	 * collisions.
	 */
	id = ip_idents_reserve(hash, 1);
	if (unlikely(!id))
		id = 1 << 31;

	return id;
}
"
dff368031150a1033a1a3c913f8857679a0279be,1,"void Document::finishedParsing()
{
    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());
    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
    setParsingState(InDOMContentLoaded);

    if (!m_documentTiming.domContentLoadedEventStart())
        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());
    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));
    if (!m_documentTiming.domContentLoadedEventEnd())
        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());
    setParsingState(FinishedParsing);

    RefPtrWillBeRawPtr<Document> protect(this);

    Microtask::performCheckpoint();
 
     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {
        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();

        if (mainResourceWasAlreadyRequested)
            updateLayoutTreeIfNeeded();

        frame->loader().finishedParsing();

        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""MarkDOMContent"", TRACE_EVENT_SCOPE_THREAD, ""data"", InspectorMarkLoadEvent::data(frame.get()));
        InspectorInstrumentation::domContentLoadedEventFired(frame.get());
    }

    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);

    m_fetcher->clearPreloads();
}
"
ec8013beddd717d1740cfefb1a9b900deef85462,1,"static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
			   unsigned long arg)
{
	struct multipath *m = (struct multipath *) ti->private;
	struct block_device *bdev = NULL;
	fmode_t mode = 0;
	unsigned long flags;
	int r = 0;

	spin_lock_irqsave(&m->lock, flags);

	if (!m->current_pgpath)
		__choose_pgpath(m, 0);

	if (m->current_pgpath) {
		bdev = m->current_pgpath->path.dev->bdev;
		mode = m->current_pgpath->path.dev->mode;
	}

	if (m->queue_io)
		r = -EAGAIN;
	else if (!bdev)
		r = -EIO;
 
 	spin_unlock_irqrestore(&m->lock, flags);
 
 	return r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);
 }
"
ef397e88e96d4a798bd190bcd0c43865c3725ae2,1,"void ppc40x_chip_reset (CPUState *env)

{

    target_ulong dbsr;



    printf(""Reset PowerPC chip\n"");

    cpu_ppc_reset(env);

    /* XXX: TODO reset all internal peripherals */

    dbsr = env->spr[SPR_40x_DBSR];

    dbsr &= ~0x00000300;

    dbsr |= 0x00000200;

    env->spr[SPR_40x_DBSR] = dbsr;

    cpu_loop_exit();

}
"
f0ca6ffa0ae5d5564516ee7a18aa1e234751444a,1,"static void show_packets(AVFormatContext *fmt_ctx)

{

    AVPacket pkt;



    av_init_packet(&pkt);

    probe_array_header(""packets"", 0);

    while (!av_read_frame(fmt_ctx, &pkt))

        show_packet(fmt_ctx, &pkt);

    probe_array_footer(""packets"", 0);

}
"
f1c52354e5bdab6983d13a4c174759c585e834b3,0,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc) {
    if (!drc) return RTAS_OUT_ERROR;
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}"
f61bece684d9685b07895508e6c1c733b5564ccf,0,"av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact) {
#if HAVE_ALTIVEC 
    if (!fdsp) return; 
    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC)) return; 
    fdsp->vector_fmul = ff_vector_fmul_altivec; 
    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec; 
    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec; 
    if (!bit_exact) { 
        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec; 
    } 
#endif 
}"
faadf50e2962dd54175647a80bd6fc4319c91973,1,"static void init_excp_620 (CPUPPCState *env)

{

#if !defined(CONFIG_USER_ONLY)

    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;

    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;

    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;

    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;

    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;

    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;

    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;

    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;

    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;

    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;

    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;

    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;

    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;

    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;

    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;

    /* Hardware reset vector */

    env->hreset_vector = 0x0000000000000100ULL; /* ? */

#endif

}
"
fe0f4e56577a2dbd373bb50b0ae2d49e69d822fc,0,"int av_packet_ref(AVPacket*dst, AVPacket*src){
    int ret;
    ret=av_packet_copy_props(dst, src);
    if(ret<0)return ret;
    if(!src->buf){
        ret=packet_alloc(&dst->buf, src->size);
        if(ret<0)goto fail;
        if(dst->buf && dst->buf->data)
            memcpy(dst->buf->data, src->data, src->size);
    }else{
        dst->buf=av_buffer_ref(src->buf);
        if(!dst->buf || !dst->buf->data)
            goto fail;
    }
    dst->size=src->size;
    dst->data=dst->buf->data;
    return 0;
fail:
    av_packet_free_side_data(dst);
    return ret;
}"
ffmpeg_b6b09c4c3e5bc64d889707ee2981768cc0d19a6c_1,1,"static int config_input(AVFilterLink *inlink)
{
    AVFilterContext *ctx = inlink->dst;
    FrameRateContext *s = ctx->priv;
    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);
    int plane;

    for (plane = 0; plane < 4; plane++) {
        s->line_size[plane] = av_image_get_linesize(inlink->format, inlink->w,
                                                    plane);
    }

    s->bitdepth = pix_desc->comp[0].depth;
    s->vsub = pix_desc->log2_chroma_h;
    s->interp_start = s->interp_start_param << (s->bitdepth - 8);
    s->interp_end = s->interp_end_param << (s->bitdepth - 8);

    s->sad = av_pixelutils_get_sad_fn(3, 3, 2, s); // 8x8 both sources aligned
    if (!s->sad)
        return AVERROR(EINVAL);

    s->srce_time_base = inlink->time_base;

    s->max = 1 << (s->bitdepth);
    if (s->bitdepth == 8)
        s->blend = blend_frames_c;
    else
        s->blend = blend_frames16_c;

    return 0;
}"
ffmpeg_b73cbc53fdfe4f35f2d5baea64c1d5c879f37aee_1,1,"static void blend_frame(AVFilterContext *ctx,
                        AVFrame *top_buf,
                        AVFrame *bottom_buf,
                        AVFrame *dst_buf)
{
    BlendContext *b = ctx->priv;
    AVFilterLink *inlink = ctx->inputs[0];
    FilterParams *param;
    int plane;

    for (plane = 0; dst_buf->data[plane]; plane++) {
        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;
        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;
        int outw = dst_buf->width  >> hsub;
        int outh = dst_buf->height >> vsub;
        uint8_t *dst    = dst_buf->data[plane];
        uint8_t *top    = top_buf->data[plane];
        uint8_t *bottom = bottom_buf->data[plane];

        param = &b->params[plane];
        param->values[VAR_N]  = inlink->frame_count;
        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);
        param->values[VAR_W]  = outw;
        param->values[VAR_H]  = outh;
        param->values[VAR_SW] = outw / dst_buf->width;
        param->values[VAR_SH] = outh / dst_buf->height;
        param->blend(top, top_buf->linesize[plane],
                     bottom, bottom_buf->linesize[plane],
                     dst, dst_buf->linesize[plane], outw, outh, param);
    }
}"
ffmpeg_ba5684c37391efe9efb91df7a23fcf81e4576a92_1,1,"static int init_tile(Jpeg2000DecoderContext *s, int tileno)
{
    int compno;
    int tilex = tileno % s->numXtiles;
    int tiley = tileno / s->numXtiles;
    Jpeg2000Tile *tile = s->tile + tileno;

    if (!tile->comp)
        return AVERROR(ENOMEM);

    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);
    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);
    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);
    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);

    for (compno = 0; compno < s->ncomponents; compno++) {
        Jpeg2000Component *comp = tile->comp + compno;
        Jpeg2000CodingStyle *codsty = tile->codsty + compno;
        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;
        int ret; // global bandno

        comp->coord_o[0][0] = tile->coord[0][0];
        comp->coord_o[0][1] = tile->coord[0][1];
        comp->coord_o[1][0] = tile->coord[1][0];
        comp->coord_o[1][1] = tile->coord[1][1];
        if (compno) {
            comp->coord_o[0][0] /= s->cdx[compno];
            comp->coord_o[0][1] /= s->cdx[compno];
            comp->coord_o[1][0] /= s->cdy[compno];
            comp->coord_o[1][1] /= s->cdy[compno];
        }

        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);
        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);
        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);
        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);

        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,
                                             s->cbps[compno], s->cdx[compno],
                                             s->cdy[compno], s->avctx))
            return ret;
    }
    return 0;
}"
ffmpeg_c6ce2eacaecd9191100b06531cbdb284e64c4b15_1,1,"int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,
                            uint8_t *data, size_t size)
{
    AVPacketSideData *sd, *tmp;
    int i;

    for (i = 0; i < st->nb_side_data; i++) {
        sd = &st->side_data[i];

        if (sd->type == type) {
            av_freep(&sd->data);
            sd->data = data;
            sd->size = size;
            return 0;
        }
    }

    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp));
    if (!tmp) {
        return AVERROR(ENOMEM);
    }

    st->side_data = tmp;
    st->nb_side_data++;

    sd = &st->side_data[st->nb_side_data - 1];
    sd->type = type;
    sd->data = data;
    sd->size = size;

    return 0;
}"
ffmpeg_d1016f7c7d1ac94fc77fecf7861d280143ceff19_1,1,"static inline void refill_32(BitstreamContext *bc)
{
    if (bc->ptr >= bc->buffer_end)
        return;

#ifdef BITSTREAM_READER_LE
    bc->bits       = (uint64_t)AV_RL32(bc->ptr) << bc->bits_left | bc->bits;
#else
    bc->bits       = bc->bits | (uint64_t)AV_RB32(bc->ptr) << (32 - bc->bits_left);
#endif
    bc->ptr       += 4;
    bc->bits_left += 32;
}"
ffmpeg_f87de593a19e27efb9e7b523b9fd8ad3e720ec71_1,1,"void *av_realloc(void *ptr, size_t size)
{
#if CONFIG_MEMALIGN_HACK
    int diff;
#endif

    /* let's disallow possibly ambiguous cases */
    if (size > (max_alloc_size - 32))
        return NULL;

#if CONFIG_MEMALIGN_HACK
    //FIXME this isn't aligned correctly, though it probably isn't needed
    if (!ptr)
        return av_malloc(size);
    diff = ((char *)ptr)[-1];
    av_assert0(diff>0 && diff<=ALIGN);
    ptr = realloc((char *)ptr - diff, size + diff);
    if (ptr)
        ptr = (char *)ptr + diff;
    return ptr;
#elif HAVE_ALIGNED_MALLOC
    return _aligned_realloc(ptr, size + !size, ALIGN);
#else
    return realloc(ptr, size + !size);
#endif
}"
freerdp-1.0.2-0,0,"INLINE void gdi_RectToCRgn(HGDI_RECT rect, int*x, int*y, int*w, int*h){if(rect && x && y && w && h){*x=rect->left;*y=rect->top;*w=abs(rect->right-rect->left)+1;*h=abs(rect->bottom-rect->top)+1;}}"
freerdp-1.0.2-0,1,"INLINE void gdi_RectToCRgn(HGDI_RECT rect, int *x, int *y, int *w, int *h)
{
	*x = rect->left;
	*y = rect->top;
	*w = rect->right - rect->left + 1;
	*h = rect->bottom - rect->top + 1;
}"
freerdp-1.0.2-1,0,"static int BitBlt_SRCCOPY_8bpp(HGDI_DC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HGDI_DC hdcSrc, int nXSrc, int nYSrc){
    int y;
    uint8* srcp;
    uint8* dstp;
    if ((hdcDest->selectedObject != hdcSrc->selectedObject) || gdi_CopyOverlap(nXDest, nYDest, nWidth, nHeight, nXSrc, nYSrc) == 0) {
        for (y = 0; y < nHeight; y++) {
            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);
            if (srcp != 0 && dstp != 0) {
                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
                if (size / hdcDest->bytesPerPixel == nWidth) //Check for overflow 
                    memcpy(dstp, srcp, size);
            }
        }
        return 0;
    }
    if (nYSrc < nYDest) { /*copy down(bottom to top)*/
        for (y = nHeight - 1; y >= 0; y--) {
            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);
            if (srcp != 0 && dstp != 0) {
                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
                if (size / hdcDest->bytesPerPixel == nWidth) //Check for overflow 
                    memmove(dstp, srcp, size);
            }
        }
    } else if (nYSrc > nYDest || nXSrc > nXDest) { /*copy up or left(top to bottom)*/
        for (y = 0; y < nHeight; y++) {
            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);
            if (srcp != 0 && dstp != 0) {
                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
                if (size / hdcDest->bytesPerPixel == nWidth) //Check for overflow 
                    memmove(dstp, srcp, size);
            }
        }
    } else { /*copy straight right*/
        for (y = 0; y < nHeight; y++) {
            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);
            if (srcp != 0 && dstp != 0) {
                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
                if (size / hdcDest->bytesPerPixel == nWidth) //Check for overflow 
                    memmove(dstp, srcp, size);
            }
        }
    }
    return 0;
}"
freerdp-1.0.2-1,1,"static int BitBlt_SRCCOPY_8bpp(HGDI_DC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HGDI_DC hdcSrc, int nXSrc, int nYSrc)
{
	int y;
	uint8* srcp;
	uint8* dstp;

	if ((hdcDest->selectedObject != hdcSrc->selectedObject) ||
	    gdi_CopyOverlap(nXDest, nYDest, nWidth, nHeight, nXSrc, nYSrc) == 0)
	{
		for (y = 0; y < nHeight; y++)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
				memcpy(dstp, srcp, nWidth * hdcDest->bytesPerPixel);
		}

		return 0;
	}
	
	if (nYSrc < nYDest)
	{
		/* copy down (bottom to top) */
		for (y = nHeight - 1; y >= 0; y--)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
				memmove(dstp, srcp, nWidth * hdcDest->bytesPerPixel);
		}
	}
	else if (nYSrc > nYDest || nXSrc > nXDest)
	{
		/* copy up or left (top top bottom) */
		for (y = 0; y < nHeight; y++)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
				memmove(dstp, srcp, nWidth * hdcDest->bytesPerPixel);
		}
	}
	else
	{
		/* copy straight right */
		for (y = 0; y < nHeight; y++)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
				memmove(dstp, srcp, nWidth * hdcDest->bytesPerPixel);
		}
	}
	
	return 0;
}"
freerdp-1.0.2-2,0,"void gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap, uint8* data, int width, int height, int bpp, int length, boolean compressed) {
    uint32 size;
    if (width <= 0 || height <= 0 || bpp <= 0 || width > 10000 || height > 10000 || bpp > 32) {
        printf(""Invalid dimensions or bpp\n"");
        return;
    }
    size = (uint32)width * (uint32)height * ((uint32)bpp + 7) / 8;
    if (bitmap->data == NULL) {
        bitmap->data = (uint8*)xmalloc(size);
        if (bitmap->data == NULL) {
            printf(""Memory allocation failed\n"");
            return;
        }
    } else {
        uint8* new_data = (uint8*)xrealloc(bitmap->data, size);
        if (new_data == NULL) {
            printf(""Memory reallocation failed\n"");
            return;
        }
        bitmap->data = new_data;
    }
    if (compressed) {
        boolean status;
        status = bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);
        if (status != true) {
            printf(""Bitmap Decompression Failed\n"");
        }
    } else {
        freerdp_image_flip(data, bitmap->data, width, height, bpp);
    }
    bitmap->width = width;
    bitmap->height = height;
    bitmap->compressed = false;
    bitmap->length = size;
    bitmap->bpp = bpp;
}"
freerdp-1.0.2-2,1,"void gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,
		uint8* data, int width, int height, int bpp, int length, boolean compressed)
{
	uint16 size;

	size = width * height * (bpp + 7) / 8;

	if (bitmap->data == NULL)
		bitmap->data = (uint8*) xmalloc(size);
	else
		bitmap->data = (uint8*) xrealloc(bitmap->data, size);

	if (compressed)
	{
		boolean status;

		status = bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);

		if (status != true)
		{
			printf(""Bitmap Decompression Failed\n"");
		}
	}
	else
	{
		freerdp_image_flip(data, bitmap->data, width, height, bpp);

	}

	bitmap->width = width;
	bitmap->height = height;
	bitmap->compressed = false;
	bitmap->length = size;
	bitmap->bpp = bpp;
}"
freerdp-1.0.2-4,0,"void update_recv_order(rdpUpdate* update, STREAM* s) {
    uint8 controlFlags = 0;
    if (stream_get_length(s) >= 1) {
        stream_read_uint8(s, controlFlags);
        /* controlFlags(1 byte) */
        if (!(controlFlags & ORDER_STANDARD))
            update_recv_altsec_order(update, s, controlFlags);
        else if (controlFlags & ORDER_SECONDARY)
            update_recv_secondary_order(update, s, controlFlags);
        else 
            update_recv_primary_order(update, s, controlFlags);
    }
}"
freerdp-1.0.2-4,1,"void update_recv_order(rdpUpdate* update, STREAM* s)
{
	uint8 controlFlags;

	stream_read_uint8(s, controlFlags); /* controlFlags (1 byte) */

	if (!(controlFlags & ORDER_STANDARD))
		update_recv_altsec_order(update, s, controlFlags);
	else if (controlFlags & ORDER_SECONDARY)
		update_recv_secondary_order(update, s, controlFlags);
	else
		update_recv_primary_order(update, s, controlFlags);
}"
graphite2-1.3.5-0,0,"template<typename T>
T* grzeroalloc(size_t n) {
#ifdef GRAPHITE2_TELEMETRY
    telemetry::count_bytes(sizeof(T) * n);
#endif
    if (n == 0 || sizeof(T) == 0 || SIZE_MAX / sizeof(T) < n) return nullptr; // Improved check for overflow using division to avoid multiplication overflow risks.
    return static_cast<T*>(calloc(n, sizeof(T)));
}"
graphite2-1.3.5-0,1,"template <typename T> T * grzeroalloc(size_t n)
{
#ifdef GRAPHITE2_TELEMETRY
    telemetry::count_bytes(sizeof(T) * n);
#endif
    return static_cast<T*>(calloc(n, sizeof(T)));
}"
hhvm-HHVM-3.12.10-0,0,"static String HHVM_FUNCTION(bcadd, const String& left, const String& right, int64_t scale/*=-1*/) {
    if (scale < 0) scale = BCG(bc_precision);
    if (scale > MAX_SCALE) scale = MAX_SCALE; // Define MAX_SCALE as a reasonable upper limit for scale.
    bc_num first, second, result;
    bc_init_num(&first);
    bc_init_num(&second);
    bc_init_num(&result);
    php_str2num(&first, (char*)left.substr(0, MAX_NUM_SIZE).data());
    php_str2num(&second, (char*)right.substr(0, MAX_NUM_SIZE).data());
    bc_add(first, second, &result, scale);
    if (result->n_scale > scale) {
        result->n_scale = scale;
    }
    String ret(bc_num2str(result), AttachString);
    bc_free_num(&first);
    bc_free_num(&second);
    bc_free_num(&result);
    return ret;
}"
hhvm-HHVM-3.12.10-0,1,"static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
                            int64_t scale /* = -1 */) {
  if (scale < 0) scale = BCG(bc_precision);
  bc_num first, second, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&result);
  php_str2num(&first, (char*)left.data());
  php_str2num(&second, (char*)right.data());
  bc_add(first, second, &result, scale);
  if (result->n_scale > scale) {
    result->n_scale = scale;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&first);
  bc_free_num(&second);
  bc_free_num(&result);
  return ret;
}"
hhvm-HHVM-3.12.10-1,0,"String StringUtil::Implode(const Variant& items, const String& delim, const bool checkIsContainer/*=true*/) {
    if (checkIsContainer && !isContainer(items)) {
        throw_param_is_not_container();
    }
    int size = getContainerSize(items);
    if (size == 0) return empty_string();
    if (size > (INT_MAX / sizeof(String))) throw std::overflow_error(""Size is too large"");
    std::vector<String> sitems(size);
    size_t len = 0;
    int lenDelim = delim.size();
    int i = 0;
    for (ArrayIter iter(items); iter; ++iter) {
        sitems[i] = iter.second().toString();
        len += sitems[i].size() + lenDelim;
        if (len < sitems[i].size()) throw std::overflow_error(""Length overflow"");
        i++;
    }
    len -= lenDelim; // always one delimiter less than count of items 
    assert(i == size);
    String s = String(len, ReserveString);
    char* buffer = s.mutableData();
    const char* sdelim = delim.data();
    char* p = buffer;
    String& init_str = sitems[0];
    int init_len = init_str.size();
    memcpy(p, init_str.data(), init_len);
    p += init_len;
    for (int i = 1; i < size; i++) {
        String& item = sitems[i];
        memcpy(p, sdelim, lenDelim);
        p += lenDelim;
        int lenItem = item.size();
        memcpy(p, item.data(), lenItem);
        p += lenItem;
    }
    assert(p - buffer == len);
    s.setSize(len);
    return s;
}"
hhvm-HHVM-3.12.10-1,1,"String StringUtil::Implode(const Variant& items, const String& delim,
                           const bool checkIsContainer /* = true */) {
  if (checkIsContainer && !isContainer(items)) {
    throw_param_is_not_container();
  }
  int size = getContainerSize(items);
  if (size == 0) return empty_string();

  String* sitems = (String*)req::malloc(size * sizeof(String));
  int len = 0;
  int lenDelim = delim.size();
  int i = 0;
  for (ArrayIter iter(items); iter; ++iter) {
    new (&sitems[i]) String(iter.second().toString());
    len += sitems[i].size() + lenDelim;
    i++;
  }
  len -= lenDelim; // always one delimiter less than count of items
  assert(i == size);

  String s = String(len, ReserveString);
  char *buffer = s.mutableData();
  const char *sdelim = delim.data();
  char *p = buffer;
  String &init_str = sitems[0];
  int init_len = init_str.size();
  memcpy(p, init_str.data(), init_len);
  p += init_len;
  sitems[0].~String();
  for (int i = 1; i < size; i++) {
    String &item = sitems[i];
    memcpy(p, sdelim, lenDelim);
    p += lenDelim;
    int lenItem = item.size();
    memcpy(p, item.data(), lenItem);
    p += lenItem;
    sitems[i].~String();
  }
  req::free(sitems);
  assert(p - buffer == len);
  s.setSize(len);
  return s;
}"
httpd_03cab3f0aaf1bdf28cfd53e8c550030d5fe3a3ba_0,0,"static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade *a, apr_bucket *e) {
    if (b == NULL || a == NULL || b == a) return;
    apr_bucket *f;
    if (e != APR_BRIGADE_SENTINEL(b)) {
        f = APR_RING_LAST(&b->list);
        APR_RING_UNSPLICE(e, f, link);
        APR_RING_SPLICE_HEAD(&a->list, e, f, apr_bucket, link);
    }
    APR_BRIGADE_CHECK_CONSISTENCY(a);
    APR_BRIGADE_CHECK_CONSISTENCY(b);
}"
httpd_12cd078edfbd1ecce7533b49ce34f4f2743c725b_0,0,"static long get_chunk_size(char *b) {
    long chunksize = 0;
    size_t chunkbits = sizeof(long) * 8;
    size_t len = strlen(b);
    ap_xlate_proto_from_ascii(b, len);
    /* Skip leading zeros */
    while (*b == '0' && len > 0) {
        ++b;
        --len;
    }
    while (apr_isxdigit(*b) && (chunkbits > 0) && len > 0) {
        int xvalue = 0;
        if (*b >= '0' && *b <= '9') {
            xvalue = *b - '0';
        } else if (*b >= 'A' && *b <= 'F') {
            xvalue = *b - 'A' + 0xa;
        } else if (*b >= 'a' && *b <= 'f') {
            xvalue = *b - 'a' + 0xa;
        }
        chunksize = (chunksize << 4) | xvalue;
        chunkbits -= 4;
        ++b;
        --len;
    }
    if (apr_isxdigit(*b) && (chunkbits <= 0) && len > 0) {
        /* overflow */
        return -1;
    }
    return chunksize;
}"
httpd_27680735a0ee17ef5cefd7684a43e95dba679cc8_0,0,"AP_DECLARE(char*)ap_md5_binary(apr_pool_t*p, const unsigned char*buf, int length){const char*hex=""0123456789abcdef"";
    apr_md5_ctx_t my_md5;unsigned char hash[APR_MD5_DIGESTSIZE];char*r, result[33];/*(MD5_DIGESTSIZE*2)+1*/int i;/**Take the MD5 hash of the string argument.*/apr_md5_init(&my_md5);#if APR_CHARSET_EBCDIC 
    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);#endif 
    apr_md5_update(&my_md5, buf, (unsigned int)length);apr_md5_final(hash, &my_md5);for(i=0, r=result;i<APR_MD5_DIGESTSIZE;i++){*r++=hex[hash[i]>>4];*r++=hex[hash[i]&0xF];}*r='
    return apr_pstrndup(p, result, (APR_MD5_DIGESTSIZE*2)+1);}"
httpd_8038760bc02c48c31a059dda2ad061a6460cd0dd_0,0,"static int set_group_privs(void) {
    if (!geteuid()) {
        const char *name;
        if (unixd_config.user_name[0] == '#') {
            struct passwd *ent;
            char *endptr;
            uid_t uid = strtoul(&unixd_config.user_name[1], &endptr, 10);
            if (*endptr != '\0') {
                ap_log_error(APLOG_MARK, APLOG_ALERT, 0, NULL, ""Invalid UID format"");
                return -1;
            }
            if ((ent = getpwuid(uid)) == NULL) {
                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, ""getpwuid: couldn't determine user name from uid %u, ""
                             ""you probably need to modify the User directive"", (unsigned)uid);
                return -1;
            }
            name = ent->pw_name;
        } else {
            name = unixd_config.user_name;
        }
#if !defined(OS2) && !defined(TPF)
        if (setgid(unixd_config.group_id) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, ""setgid: unable to set group id to Group %u"", (unsigned)unixd_config.group_id);
            return -1;
        }
        if (initgroups(name, unixd_config.group_id) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, ""initgroups: unable to set groups for User %s ""
                        ""and Group %u"", name, (unsigned)unixd_config.group_id);
            return -1;
        }
#endif /*!defined(OS2) && !defined(TPF)*/
    }
    return 0;
}"
httpd_8dddb48ed8aa22eb4959dfc9c7275275e19c4299_0,0,"AP_DECLARE(char*)ap_md5_binary(apr_pool_t*p, const unsigned char*buf, int length){const char*hex=""0123456789abcdef"";
    apr_md5_ctx_t my_md5;unsigned char hash[APR_MD5_DIGESTSIZE];char*r, result[33];/*(MD5_DIGESTSIZE*2)+1*/int i;/**Take the MD5 hash of the string argument.*/apr_md5_init(&my_md5);#if APR_CHARSET_EBCDIC 
    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);#endif 
    apr_md5_update(&my_md5, buf, (unsigned int)length);apr_md5_final(hash, &my_md5);for(i=0, r=result;i<APR_MD5_DIGESTSIZE;i++){*r++=hex[hash[i]>>4];*r++=hex[hash[i]&0xF];}*r='\0';
    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);}"
httpd_8e8c19e46a77da0b247c91af6b30dde0c28163aa_0,0,"void ap_init_scoreboard(void*shared_score){
    char*more_storage;
    int i;
    size_t calculated_size = ap_calc_scoreboard_size();
    ap_scoreboard_image=calloc(1, calculated_size);
    if (!ap_scoreboard_image) return;
    more_storage=shared_score;
    ap_scoreboard_image->global=(global_score*)more_storage;
    more_storage+=sizeof(global_score);
    ap_scoreboard_image->parent=(process_score*)more_storage;
    more_storage+=sizeof(process_score)*server_limit;
    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));
    for(i=0;i<server_limit;i++){
        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;
        more_storage+=thread_limit*sizeof(worker_score);
    }
    if(lb_limit){
        ap_scoreboard_image->balancers=(lb_score*)more_storage;
        more_storage+=lb_limit*sizeof(lb_score);
    }
    ap_assert(more_storage == (char*)shared_score+calculated_size);
    ap_scoreboard_image->global->server_limit=server_limit;
    ap_scoreboard_image->global->thread_limit=thread_limit;
    ap_scoreboard_image->global->lb_limit=lb_limit;
}"
httpd_9413f5d49bae37718a97303fd1b07661b1cb5778_0,0,"AP_DECLARE(char*)ap_field_noparam(apr_pool_t*p, const char*intype){
    const char*semi;
    if(intype == NULL || *intype == '\0') return NULL;
    semi=ap_strchr_c(intype, ';');
    if(semi == NULL){
        return apr_pstrdup(p, intype);
    } else {
        while((semi>intype) && apr_isspace(semi[-1])){
            semi--;
        }
        return apr_pstrndup(p, intype, semi-intype);
    }
}"
httpd_9ad8554d836907d0dcbe899992b297f4e1975c23_0,0,"void ap_init_scoreboard(void*shared_score){
    char*more_storage;
    int i;
    ap_calc_scoreboard_size();
    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));
    if (!ap_scoreboard_image) {
        return;
    }
    more_storage=shared_score;
    ap_scoreboard_image->global=(global_score*)more_storage;
    more_storage+=sizeof(global_score);
    ap_scoreboard_image->parent=(process_score*)more_storage;
    more_storage+=sizeof(process_score)*server_limit;
    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));
    for(i=0;i<server_limit;i++){
        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;
        more_storage+=thread_limit*sizeof(worker_score);
    }
    if(lb_limit){
        ap_scoreboard_image->balancers=(lb_score*)more_storage;
        more_storage+=lb_limit*sizeof(lb_score);
    }
    ap_assert(more_storage <= (char*)shared_score+scoreboard_size);
    ap_scoreboard_image->global->server_limit=server_limit;
    ap_scoreboard_image->global->thread_limit=thread_limit;
    ap_scoreboard_image->global->lb_limit=lb_limit;
}"
httpd_b7f6b9ef9951e2fc956040d0e6b9e65359899ef7_0,0,"AP_DECLARE(char*)ap_field_noparam(apr_pool_t*p, const char*intype){
    const char*semi;
    if(intype == NULL)
        return NULL;
    semi=ap_strchr_c(intype, ';');
    if(semi == NULL){
        return apr_pstrdup(p, intype);
    }else{
        while((semi>intype) && apr_isspace(semi[-1])){
            semi--;
        }
        return apr_pstrndup(p, intype, semi-intype);
    }
}"
httpd_bfd6489f6b8ab0cbfbddc8e4d5754fa3660316e1_0,0,"AP_CORE_DECLARE(void)ap_parse_uri(request_rec*r, const char*uri){
    int status=HTTP_OK;
    r->unparsed_uri=apr_pstrdup(r->pool, uri);
    while((uri[0] == '/') && (uri[1] == '/')){
        ++uri;
    }
    if(r->method_number == M_CONNECT){
        status=apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);
    }else{
        status=apr_uri_parse(r->pool, uri, &r->parsed_uri);
    }
    if(status == APR_SUCCESS){
        if(r->parsed_uri.scheme && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))){
            r->hostname=r->parsed_uri.hostname;
        }else if(r->method_number == M_CONNECT){
            r->hostname=r->parsed_uri.hostname;
        }
        r->args=r->parsed_uri.query;
        r->uri=r->parsed_uri.path ? r->parsed_uri.path : apr_pstrdup(r->pool, ""/"");
        #if defined(OS2) || defined(WIN32)
        {
            char*x;
            for(x=r->uri;(x=strchr(x, '\')) != NULL;)*x='/';
        }
        #endif/*OS2 || WIN32*/
    }else{
        r->args=NULL;
        r->hostname=NULL;
        r->status=HTTP_BAD_REQUEST;
        r->uri=apr_pstrdup(r->pool, uri);
    }
}"
httpd_e95b9b94154dcd872cedbfbd7d77b4c252002034_0,0,"void ap_init_scoreboard(void*shared_score){
    char*more_storage;
    int i;
    ap_calc_scoreboard_size();
    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));
    if (!ap_scoreboard_image) return;
    more_storage=shared_score;
    if (!more_storage) return;
    ap_scoreboard_image->global=(global_score*)more_storage;
    more_storage+=sizeof(global_score);
    ap_scoreboard_image->parent=(process_score*)more_storage;
    more_storage+=sizeof(process_score)*server_limit;
    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));
    for(i=0;i<server_limit;i++){
        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;
        more_storage+=thread_limit*sizeof(worker_score);
    }
    if(lb_limit){
        ap_scoreboard_image->balancers=(lb_score*)more_storage;
        more_storage+=lb_limit*sizeof(lb_score);
    }
    ap_assert(more_storage == (char*)shared_score+scoreboard_size);
    ap_scoreboard_image->global->server_limit=server_limit;
    ap_scoreboard_image->global->thread_limit=thread_limit;
    ap_scoreboard_image->global->lb_limit=lb_limit;
}"
httpd_ecec010fd3f8197d1a6724dd38b0d3a9c1e95d4a_0,0,"static void* merge_action_dir_configs(apr_pool_t* p, void* basev, void* addv) {
    if (!basev || !addv) return NULL;
    action_dir_config* base = (action_dir_config*)basev;
    action_dir_config* add = (action_dir_config*)addv;
    action_dir_config* new = (action_dir_config*)apr_palloc(p, sizeof(action_dir_config));
    if (!new) return NULL;
    int i;
    new->action_types = apr_table_overlay(p, add->action_types, base->action_types);
    for (i = 0; i < METHODS; ++i) {
        new->scripted[i] = add->scripted[i] ? add->scripted[i] : base->scripted[i];
    }
    new->configured = (base->configured || add->configured);
    return new;
}"
httpd_edfecb64c8e7f169c3d396a0cc12da4baf41f6a8_0,0,"void ap_init_scoreboard(void*shared_score){
    char*more_storage;
    int i;
    ap_calc_scoreboard_size();
    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));
    more_storage=shared_score;
    ap_scoreboard_image->global=(global_score*)more_storage;
    more_storage+=sizeof(global_score);
    ap_scoreboard_image->parent=(process_score*)more_storage;
    more_storage+=sizeof(process_score)*server_limit;
    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));
    for(i=0;i<server_limit;i++){
        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;
        more_storage+=thread_limit*sizeof(worker_score);
    }
    if(lb_limit){
        ap_scoreboard_image->balancers=(lb_score*)more_storage;
        more_storage+=lb_limit*sizeof(lb_score);
    }
    ap_assert(more_storage <= (char*)shared_score+scoreboard_size);
    ap_scoreboard_image->global->server_limit=server_limit;
    ap_scoreboard_image->global->thread_limit=thread_limit;
    ap_scoreboard_image->global->lb_limit=lb_limit;
}"
jasper-version-2.0.11-0,0,"void jas_free(void*ptr){JAS_DBGLOG(100, (""jas_free(%p)\n"", ptr));if(ptr != NULL){free(ptr);}}"
jasper-version-2.0.11-0,1,"void jas_free(void *ptr)
{
	JAS_DBGLOG(100, (""jas_free(%p)\n"", ptr));
	free(ptr);
}"
libav_727640fec3cec9b3cb655b1a6dab306bc6234f7a_1,1,"void *av_realloc(void *ptr, size_t size)
{
#if CONFIG_MEMALIGN_HACK
    int diff;
#endif

    /* let's disallow possibly ambiguous cases */
    if (size > (INT_MAX - 16))
        return NULL;

#if CONFIG_MEMALIGN_HACK
    //FIXME this isn't aligned correctly, though it probably isn't needed
    if (!ptr)
        return av_malloc(size);
    diff = ((char *)ptr)[-1];
    return (char *)realloc((char *)ptr - diff, size + diff) + diff;
#elif HAVE_ALIGNED_MALLOC
    return _aligned_realloc(ptr, size, 32);
#else
    return realloc(ptr, size);
#endif
}"
libav_8d0b5ee0283ad22ab65429548b3d38dacc6552d0_1,1,"static int biquad_init_coeffs(void *avc, struct FFIIRFilterCoeffs *c,
                              enum IIRFilterMode filt_mode, int order,
                              float cutoff_ratio, float stopband)
{
    double cos_w0, sin_w0;
    double a0, x0, x1;

    if (filt_mode != FF_FILTER_MODE_HIGHPASS &&
        filt_mode != FF_FILTER_MODE_LOWPASS) {
        av_log(avc, AV_LOG_ERROR, ""Biquad filter currently only supports ""
               ""high-pass and low-pass filter modes\n"");
        return -1;
    }
    if (order != 2) {
        av_log(avc, AV_LOG_ERROR, ""Biquad filter must have order of 2\n"");
        return -1;
    }

    cos_w0 = cos(M_PI * cutoff_ratio);
    sin_w0 = sin(M_PI * cutoff_ratio);

    a0 = 1.0 + (sin_w0 / 2.0);

    if (filt_mode == FF_FILTER_MODE_HIGHPASS) {
        c->gain  =  ((1.0 + cos_w0) / 2.0)  / a0;
        x0       =  ((1.0 + cos_w0) / 2.0)  / a0;
        x1       = (-(1.0 + cos_w0))        / a0;
    } else { // FF_FILTER_MODE_LOWPASS
        c->gain  =  ((1.0 - cos_w0) / 2.0)  / a0;
        x0       =  ((1.0 - cos_w0) / 2.0)  / a0;
        x1       =   (1.0 - cos_w0)         / a0;
    }
    c->cy[0] = (-1.0 + (sin_w0 / 2.0)) / a0;
    c->cy[1] =  (2.0 *  cos_w0)        / a0;

    // divide by gain to make the x coeffs integers.
    // during filtering, the delay state will include the gain multiplication
    c->cx[0] = lrintf(x0 / c->gain);
    c->cx[1] = lrintf(x1 / c->gain);

    return 0;
}"
libav_ce8867a53583ae0c3ee8429342f33cf95a728660_1,1,"static inline void init_get_bits(GetBitContext *s, const uint8_t *buffer,
                                 int bit_size)
{
    int buffer_size = (bit_size+7)>>3;
    if (buffer_size < 0 || bit_size < 0) {
        buffer_size = bit_size = 0;
        buffer = NULL;
    }

    s->buffer       = buffer;
    s->size_in_bits = bit_size;
#if !UNCHECKED_BITSTREAM_READER
    s->size_in_bits_plus8 = bit_size + 8;
#endif
    s->buffer_end   = buffer + buffer_size;
    s->index        = 0;
}"
openssl_24578a18649b707d6800f04cac63e764445fbff5_1,1,"static
ECDSA_SIG *SM2_sig_gen(const EC_KEY *key, const BIGNUM *e)
{
    const BIGNUM *dA = EC_KEY_get0_private_key(key);
    const EC_GROUP *group = EC_KEY_get0_group(key);
    const BIGNUM *order = EC_GROUP_get0_order(group);

    ECDSA_SIG *sig = NULL;
    EC_POINT *kG = NULL;
    BN_CTX *ctx = NULL;
    BIGNUM *k = NULL;
    BIGNUM *rk = NULL;
    BIGNUM *r = NULL;
    BIGNUM *s = NULL;
    BIGNUM *x1 = NULL;
    BIGNUM *tmp = NULL;

    kG = EC_POINT_new(group);
    if (kG == NULL)
        goto done;

    ctx = BN_CTX_new();
    if (ctx == NULL)
        goto done;

    BN_CTX_start(ctx);

    k = BN_CTX_get(ctx);
    rk = BN_CTX_get(ctx);
    x1 = BN_CTX_get(ctx);
    tmp = BN_CTX_get(ctx);

    if (tmp == NULL)
        goto done;

    /* These values are returned and so should not be allocated out of the context */
    r = BN_new();
    s = BN_new();

    if (r == NULL || s == NULL)
        goto done;

    for (;;) {
        BN_priv_rand_range(k, order);

        if (EC_POINT_mul(group, kG, k, NULL, NULL, ctx) == 0)
            goto done;

        if (EC_POINT_get_affine_coordinates_GFp(group, kG, x1, NULL, ctx) == 0)
            goto done;

        if (BN_mod_add(r, e, x1, order, ctx) == 0)
            goto done;

        /* try again if r == 0 or r+k == n */
        if (BN_is_zero(r))
            continue;

        BN_add(rk, r, k);

        if (BN_cmp(rk, order) == 0)
            continue;

        BN_add(s, dA, BN_value_one());
        BN_mod_inverse(s, s, order, ctx);

        BN_mod_mul(tmp, dA, r, order, ctx);
        BN_sub(tmp, k, tmp);

        BN_mod_mul(s, s, tmp, order, ctx);

        sig = ECDSA_SIG_new();

        if (sig == NULL)
            goto done;

         /* takes ownership of r and s */
        ECDSA_SIG_set0(sig, r, s);
        break;
    }

 done:

    if (sig == NULL) {
        BN_free(r);
        BN_free(s);
    }

    BN_CTX_free(ctx);
    EC_POINT_free(kG);
    return sig;

}"
openssl_acd5c2acdca78d43c360387f0ae6b9a76ca3a5db_1,1,"void CRYPTO_destroy_dynlockid(int i)
	{
	CRYPTO_dynlock *pointer = NULL;
	if (i)
		i = -i-1;
	if (dynlock_destroy_callback == NULL)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))
		return;
	pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer != NULL)
		{
		--pointer->references;
#ifdef REF_CHECK
		if (pointer->references < 0)
			{
			fprintf(stderr,""CRYPTO_destroy_dynlockid, bad reference count\n"");
			abort();
			}
		else
#endif
			if (pointer->references <= 0)
				{
				sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
				}
			else
				pointer = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
		OPENSSL_free(pointer);
		}
	}"
openssl_af7e41d654be6c9d590ab32d8a62e865ce153973_1,1,"void PEM_dek_info(char *buf, const char *type, int len, char *str)
	{
	static const unsigned char map[17]=""0123456789ABCDEF"";
	long i;
	int j;

	strcat(buf,""DEK-Info: "");
	strcat(buf,type);
	strcat(buf,"","");
	j=strlen(buf);
	for (i=0; i<len; i++)
		{
		buf[j+i*2]  =map[(str[i]>>4)&0x0f];
		buf[j+i*2+1]=map[(str[i]   )&0x0f];
		}
	buf[j+i*2]='\n';
	buf[j+i*2+1]='\0';
	}"
openssl_b8a6868629e2e78bfd55feba6884ce0c43831fe1_1,1,"BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
        {
	BN_ULONG t1,t2;
	int c=0;

	assert(n >= 0);
	if (n <= 0) return((BN_ULONG)0);

	for (;;)
		{
		t1=a[0]; t2=b[0];
		r[0]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		t1=a[1]; t2=b[1];
		r[1]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		t1=a[2]; t2=b[2];
		r[2]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		t1=a[3]; t2=b[3];
		r[3]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		a+=4;
		b+=4;
		r+=4;
		}
	return(c);
	}"
openssl_fad572c151d33d540c83f14a22be1bd6e67bb566_1,1,"static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,
                           int max)
{
    const unsigned char *p = *pp;
    unsigned long ret = 0;
    unsigned int i;

    if (max-- < 1)
        return (0);
    if (*p == 0x80) {
        *inf = 1;
        ret = 0;
        p++;
    } else {
        *inf = 0;
        i = *p & 0x7f;
        if (*(p++) & 0x80) {
            if (max < (int)i)
                return 0;
            /* Skip leading zeroes */
            while (i && *p == 0) {
                p++;
                i--;
            }
            if (i > sizeof(long))
                return 0;
            while (i-- > 0) {
                ret <<= 8L;
                ret |= *(p++);
            }
        } else
            ret = i;
    }
    if (ret > LONG_MAX)
        return 0;
    *pp = p;
    *rl = (long)ret;
    return (1);
}"
