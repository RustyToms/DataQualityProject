UID,Vulnerable,Diagnosis,Function,ID
jasper-version-2.0.11-0,1,"['freed_variable','first_free']","
void jas_free(void *ptr)
{
	JAS_DBGLOG(100, (""jas_free(%p)\n"", ptr));
	if (ptr != NULL) {
		free(ptr);
	}
}",jasper-version-2.0.11-0
hhvm-HHVM-3.12.10-1,1,"['overflowed_variable','overflowed_call']","String StringUtil::Implode(const Variant& items, const String& delim,
                           const bool checkIsContainer /* = true */) {
  if (checkIsContainer && !isContainer(items)) {
    throw_param_is_not_container();
  }
  int size = getContainerSize(items);
  if (size == 0) return empty_string();

  if (size > (INT_MAX / sizeof(String))) throw std::overflow_error(""Size is too large"");
  String* sitems = (String*)req::malloc(size * sizeof(String));
  size_t len = 0;
  int lenDelim = delim.size();
  int i = 0;
  for (ArrayIter iter(items); iter; ++iter) {
    new (&sitems[i]) String(iter.second().toString());
    len += sitems[i].size() + lenDelim;
    i++;
  }
  len -= lenDelim; // always one delimiter less than count of items
  assert(i == size);

  String s = String(len, ReserveString);
  char *buffer = s.mutableData();
  const char *sdelim = delim.data();
  char *p = buffer;
  String &init_str = sitems[0];
  int init_len = init_str.size();
  memcpy(p, init_str.data(), init_len);
  p += init_len;
  sitems[0].~String();
  for (int i = 1; i < size; i++) {
    String &item = sitems[i];
    memcpy(p, sdelim, lenDelim);
    p += lenDelim;
    int lenItem = item.size();
    memcpy(p, item.data(), lenItem);
    p += lenItem;
    sitems[i].~String();
  }
  req::free(sitems);
  assert(p - buffer == len);
  s.setSize(len);
  return s;
}",hhvm-HHVM-3.12.10-1
hhvm-HHVM-3.12.10-0,1,"['overflowed_variable','overflowed_call']","static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
                            int64_t scale /* = -1 */) {
  if (scale < 0) scale = BCG(bc_precision);
  bc_num first, second, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&result);
  php_str2num(&first, (char*)left.substr(0, MAX_NUM_SIZE).data());
  php_str2num(&second, (char*)right.substr(0, MAX_NUM_SIZE).data());
  bc_add(first, second, &result, scale);
  if (result->n_scale > scale) {
    result->n_scale = scale;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&first);
  bc_free_num(&second);
  bc_free_num(&result);
  return ret;
}",hhvm-HHVM-3.12.10-0
graphite2-1.3.5-2,1,['heap_overflow'],"Machine::Code::Code(bool is_constraint, const byte * bytecode_begin, const byte * const bytecode_end,
           uint8 pre_context, uint16 rule_length, const Silf & silf, const Face & face,
           enum passtype pt, byte * * const _out)
 :  _code(0), _data(0), _data_size(0), _instr_count(0), _max_ref(0), _status(loaded),
    _constraint(is_constraint), _modify(false), _delete(false), _own(_out==0)
{
#ifdef GRAPHITE2_TELEMETRY
    telemetry::category _code_cat(face.tele.code);
#endif
    assert(bytecode_begin != 0);
    if (bytecode_begin == bytecode_end)
    {
      // ::new (this) Code();
      return;
    }
    assert(bytecode_end > bytecode_begin);
    const opcode_t *    op_to_fn = Machine::getOpcodeTable();
    
    // Allocate code and data target buffers, these sizes are a worst case
    // estimate.  Once we know their real sizes the we'll shrink them.
    if (_out)   _code = reinterpret_cast<instr *>(*_out);
    else        _code = static_cast<instr *>(malloc(estimateCodeDataOut(bytecode_end-bytecode_begin)));
    _data = reinterpret_cast<byte *>(malloc((bytecode_end - bytecode_begin) * sizeof(byte)));
    
    if (!_code || !_data) {
        failure(alloc_failed);
        return;
    }
    
    decoder::limits lims = {
        bytecode_end,
        pre_context,
        rule_length,
        silf.numClasses(),
        face.glyphs().numAttrs(),
        face.numFeatures(), 
        {1,1,1,1,1,1,1,1, 
         1,1,1,1,1,1,1,255,
         1,1,1,1,1,1,1,1, 
         1,1,1,1,1,1,0,0, 
         0,0,0,0,0,0,0,0, 
         0,0,0,0,0,0,0,0, 
         0,0,0,0,0,0,0, silf.numUser()}
    };
    
    decoder dec(lims, *this, pt);
    if(!dec.load(bytecode_begin, bytecode_end))
       return;
    
    // Is this an empty program?
    if (_instr_count == 0)
    {
      release_buffers();
      ::new (this) Code();
      return;
    }
    
    // When we reach the end check we've terminated it correctly
    if (!is_return(_code[_instr_count-1])) {
        failure(missing_return);
        return;
    }

    assert((_constraint && immutable()) || !_constraint);
    dec.apply_analysis(_code, _code + _instr_count);
    _max_ref = dec.max_ref();
    
    // Now we know exactly how much code and data the program really needs
    // realloc the buffers to exactly the right size so we don't waste any 
    // memory.
    assert((bytecode_end - bytecode_begin) >= ptrdiff_t(_instr_count));
    assert((bytecode_end - bytecode_begin) >= ptrdiff_t(_data_size));
    memmove(_code + (_instr_count+1), _data, _data_size*sizeof(byte));
    size_t const total_sz = ((_instr_count+1) + (_data_size + sizeof(instr)-1)/sizeof(instr))*sizeof(instr);
    if (_out)
        *_out += total_sz;
    else
        _code = static_cast<instr *>(realloc(_code, total_sz));
   _data = reinterpret_cast<byte *>(_code + (_instr_count+1));

    if (!_code)
    {
        failure(alloc_failed);
        return;
    }

    // Make this RET_ZERO, we should never reach this but just in case ...
    _code[_instr_count] = op_to_fn[RET_ZERO].impl[_constraint];

#ifdef GRAPHITE2_TELEMETRY
    telemetry::count_bytes(_data_size + (_instr_count+1)*sizeof(instr));
#endif
}",graphite2-1.3.5-2
graphite2-1.3.5-1,1,['heap_overflow'],"void Slot::setAttr(Segment *seg, attrCode ind, uint8 subindex, int16 value, const SlotMap & map)
{
    if (ind == gr_slatUserDefnV1)
    {
        ind = gr_slatUserDefn;
        subindex = 0;
    }
    else if (ind >= gr_slatJStretch && ind < gr_slatJStretch + 20 && ind != gr_slatJWidth)
    {
        int indx = ind - gr_slatJStretch;
        return setJustify(seg, indx / 5, indx % 5, value);
    }

    switch (ind)
    {
    case gr_slatAdvX :  m_advance.x = value; break;
    case gr_slatAdvY :  m_advance.y = value; break;
    case gr_slatAttTo :
    {
        const uint16 idx = uint16(value);
        if (idx < map.size() && map[idx])
        {
            Slot *other = map[idx];
            if (other == this || other == m_parent) break;
            if (m_parent) m_parent->removeChild(this);
            if (!other->isChildOf(this) && other->child(this))
            {
                attachTo(other);
                if ((map.dir() != 0) ^ (idx > subindex))
                    m_with = Position(advance(), 0);
                else        // normal match to previous root
                    m_attach = Position(other->advance(), 0);
            }
        }
        break;
    }
    case gr_slatAttX :          m_attach.x = value; break;
    case gr_slatAttY :          m_attach.y = value; break;
    case gr_slatAttXOff :
    case gr_slatAttYOff :       break;
    case gr_slatAttWithX :      m_with.x = value; break;
    case gr_slatAttWithY :      m_with.y = value; break;
    case gr_slatAttWithXOff :
    case gr_slatAttWithYOff :   break;
    case gr_slatAttLevel :
        m_attLevel = byte(value);
        break;
    case gr_slatBreak :
        seg->charinfo(m_original)->breakWeight(value);
        break;
    case gr_slatCompRef :   break;      // not sure what to do here
    case gr_slatDir : break;
    case gr_slatInsert :
        markInsertBefore(value? true : false);
        break;
    case gr_slatPosX :      break; // can't set these here
    case gr_slatPosY :      break;
    case gr_slatShiftX :    m_shift.x = value; break;
    case gr_slatShiftY :    m_shift.y = value; break;
    case gr_slatMeasureSol :    break;
    case gr_slatMeasureEol :    break;
    case gr_slatJWidth :    just(value); break;
    case gr_slatSegSplit :  seg->charinfo(m_original)->addflags(value & 3); break;
    case gr_slatUserDefn :  if (subindex < sizeof(m_userAttr) / sizeof(m_userAttr[0])) m_userAttr[subindex] = value; break;
    case gr_slatColFlags :  {
        SlotCollision *c = seg->collisionInfo(this);
        if (c)
            c->setFlags(value);
        break; }
    case gr_slatColLimitblx :    SLOTCOLSETCOMPLEXATTR(Rect, limit(), setLimit(Rect(Position(value, s.bl.y), s.tr)))
    case gr_slatColLimitbly :    SLOTCOLSETCOMPLEXATTR(Rect, limit(), setLimit(Rect(Position(s.bl.x, value), s.tr)))
    case gr_slatColLimittrx :    SLOTCOLSETCOMPLEXATTR(Rect, limit(), setLimit(Rect(s.bl, Position(value, s.tr.y))))
    case gr_slatColLimittry :    SLOTCOLSETCOMPLEXATTR(Rect, limit(), setLimit(Rect(s.bl, Position(s.tr.x, value))))
    case gr_slatColMargin :      SLOTCOLSETATTR(setMargin(value))
    case gr_slatColMarginWt :    SLOTCOLSETATTR(setMarginWt(value))
    case gr_slatColExclGlyph :   SLOTCOLSETATTR(setExclGlyph(value))
    case gr_slatColExclOffx :    SLOTCOLSETCOMPLEXATTR(Position, exclOffset(), setExclOffset(Position(value, s.y)))
    case gr_slatColExclOffy :    SLOTCOLSETCOMPLEXATTR(Position, exclOffset(), setExclOffset(Position(s.x, value)))
    case gr_slatSeqClass :       SLOTCOLSETATTR(setSeqClass(value))
    case gr_slatSeqProxClass :   SLOTCOLSETATTR(setSeqProxClass(value))
    case gr_slatSeqOrder :       SLOTCOLSETATTR(setSeqOrder(value))
    case gr_slatSeqAboveXoff :   SLOTCOLSETATTR(setSeqAboveXoff(value))
    case gr_slatSeqAboveWt :     SLOTCOLSETATTR(setSeqAboveWt(value))
    case gr_slatSeqBelowXlim :   SLOTCOLSETATTR(setSeqBelowXlim(value))
    case gr_slatSeqBelowWt :     SLOTCOLSETATTR(setSeqBelowWt(value))
    case gr_slatSeqValignHt :    SLOTCOLSETATTR(setSeqValignHt(value))
    case gr_slatSeqValignWt :    SLOTCOLSETATTR(setSeqValignWt(value))
    default :
        break;
    }
}",graphite2-1.3.5-1
graphite2-1.3.5-0,1,['declared_buffer'],"template <typename T> T * grzeroalloc(size_t n)
{
#ifdef GRAPHITE2_TELEMETRY
    telemetry::count_bytes(sizeof(T) * n);
#endif
    if (n && sizeof(T) > SIZE_MAX / n) return nullptr; // Check for overflow
    return static_cast<T*>(calloc(n, sizeof(T)));
}",graphite2-1.3.5-0
freerdp-1.0.2-4,1,['overflowed_call'],"void update_recv_order(rdpUpdate* update, STREAM* s)
{
	uint8 controlFlags;

	if (stream_get_length(s) >= 1)
	{
		stream_read_uint8(s, controlFlags); /* controlFlags (1 byte) */

		if (!(controlFlags & ORDER_STANDARD))
			update_recv_altsec_order(update, s, controlFlags);
		else if (controlFlags & ORDER_SECONDARY)
			update_recv_secondary_order(update, s, controlFlags);
		else
			update_recv_primary_order(update, s, controlFlags);
	}
}",freerdp-1.0.2-4
freerdp-1.0.2-3,1,['overflowed_variable'],"
void update_recv_secondary_order(rdpUpdate* update, STREAM* s, uint8 flags)
{
	uint8* next;
	uint8 orderType;
	uint16 extraFlags;
	uint16 orderLength;
	rdpContext* context = update->context;
	rdpSecondaryUpdate* secondary = update->secondary;

	stream_read_uint16(s, orderLength); /* orderLength (2 bytes) */
	stream_read_uint16(s, extraFlags); /* extraFlags (2 bytes) */
	stream_read_uint8(s, orderType); /* orderType (1 byte) */

	next = s->p + (uint32) orderLength + 7;

#ifdef WITH_DEBUG_ORDERS
	if (orderType < SECONDARY_DRAWING_ORDER_COUNT)
		printf(""%s Secondary Drawing Order (0x%02X)\n"", SECONDARY_DRAWING_ORDER_STRINGS[orderType], orderType);
	else
		printf(""Unknown Secondary Drawing Order (0x%02X)\n"", orderType);
#endif

	switch (orderType)
	{
		case ORDER_TYPE_BITMAP_UNCOMPRESSED:
			update_read_cache_bitmap_order(s, &(secondary->cache_bitmap_order), false, extraFlags);
			IFCALL(secondary->CacheBitmap, context, &(secondary->cache_bitmap_order));
			break;

		case ORDER_TYPE_CACHE_BITMAP_COMPRESSED:
			update_read_cache_bitmap_order(s, &(secondary->cache_bitmap_order), true, extraFlags);
			IFCALL(secondary->CacheBitmap, context, &(secondary->cache_bitmap_order));
			break;

		case ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:
			update_read_cache_bitmap_v2_order(s, &(secondary->cache_bitmap_v2_order), false, extraFlags);
			IFCALL(secondary->CacheBitmapV2, context, &(secondary->cache_bitmap_v2_order));
			break;

		case ORDER_TYPE_BITMAP_COMPRESSED_V2:
			update_read_cache_bitmap_v2_order(s, &(secondary->cache_bitmap_v2_order), true, extraFlags);
			IFCALL(secondary->CacheBitmapV2, context, &(secondary->cache_bitmap_v2_order));
			break;

		case ORDER_TYPE_BITMAP_COMPRESSED_V3:
			update_read_cache_bitmap_v3_order(s, &(secondary->cache_bitmap_v3_order), true, extraFlags);
			IFCALL(secondary->CacheBitmapV3, context, &(secondary->cache_bitmap_v3_order));
			break;

		case ORDER_TYPE_CACHE_COLOR_TABLE:
			update_read_cache_color_table_order(s, &(secondary->cache_color_table_order), extraFlags);
			IFCALL(secondary->CacheColorTable, context, &(secondary->cache_color_table_order));
			break;

		case ORDER_TYPE_CACHE_GLYPH:
			if (secondary->glyph_v2)
			{
				update_read_cache_glyph_v2_order(s, &(secondary->cache_glyph_v2_order), extraFlags);
				IFCALL(secondary->CacheGlyphV2, context, &(secondary->cache_glyph_v2_order));
			}
			else
			{
				update_read_cache_glyph_order(s, &(secondary->cache_glyph_order), extraFlags);
				IFCALL(secondary->CacheGlyph, context, &(secondary->cache_glyph_order));
			}
			break;

		case ORDER_TYPE_CACHE_BRUSH:
			update_read_cache_brush_order(s, &(secondary->cache_brush_order), extraFlags);
			IFCALL(secondary->CacheBrush, context, &(secondary->cache_brush_order));
			break;

		default:
			break;
	}

	s->p = next;
}",freerdp-1.0.2-3
freerdp-1.0.2-2,1,['overflowed_call'],"void gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,
		uint8* data, int width, int height, int bpp, int length, boolean compressed)
{
	uint32 size;

	size = (uint32)width * (uint32)height * ((uint32)bpp + 7) / 8;

	if (bitmap->data == NULL)
		bitmap->data = (uint8*) xmalloc(size);
	else
		bitmap->data = (uint8*) xrealloc(bitmap->data, size);

	if (compressed)
	{
		boolean status;

		status = bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);

		if (status != true)
		{
			printf(""Bitmap Decompression Failed\n"");
		}
	}
	else
	{
		freerdp_image_flip(data, bitmap->data, width, height, bpp);

	}

	bitmap->width = width;
	bitmap->height = height;
	bitmap->compressed = false;
	bitmap->length = size;
	bitmap->bpp = bpp;
}",freerdp-1.0.2-2
freerdp-1.0.2-1,1,['overflowed_call'],"static int BitBlt_SRCCOPY_8bpp(HGDI_DC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HGDI_DC hdcSrc, int nXSrc, int nYSrc)
{
	int y;
	uint8* srcp;
	uint8* dstp;

	if ((hdcDest->selectedObject != hdcSrc->selectedObject) ||
	    gdi_CopyOverlap(nXDest, nYDest, nWidth, nHeight, nXSrc, nYSrc) == 0)
	{
		for (y = 0; y < nHeight; y++)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
			{
				size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
				if (size / hdcDest->bytesPerPixel == nWidth) // Check for overflow
					memcpy(dstp, srcp, size);
			}
		}

		return 0;
	}
	
	if (nYSrc < nYDest)
	{
		/* copy down (bottom to top) */
		for (y = nHeight - 1; y >= 0; y--)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
			{
				size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
				if (size / hdcDest->bytesPerPixel == nWidth) // Check for overflow
					memmove(dstp, srcp, size);
			}
		}
	}
	else if (nYSrc > nYDest || nXSrc > nXDest)
	{
		/* copy up or left (top top bottom) */
		for (y = 0; y < nHeight; y++)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
			{
				size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
				if (size / hdcDest->bytesPerPixel == nWidth) // Check for overflow
					memmove(dstp, srcp, size);
			}
		}
	}
	else
	{
		/* copy straight right */
		for (y = 0; y < nHeight; y++)
		{
			srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);
			dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);

			if (srcp != 0 && dstp != 0)
			{
				size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;
				if (size / hdcDest->bytesPerPixel == nWidth) // Check for overflow
					memmove(dstp, srcp, size);
			}
		}
	}
	
	return 0;
}",freerdp-1.0.2-1
freerdp-1.0.2-0,1,['overflowed_variable'],"INLINE void gdi_RectToCRgn(HGDI_RECT rect, int *x, int *y, int *w, int *h)
{
	*x = rect->left;
	*y = rect->top;
	*w = abs(rect->right - rect->left) + 1;
	*h = abs(rect->bottom - rect->top) + 1;
}",freerdp-1.0.2-0
curl-curl-7_61_1-1,1,['heap_overflow'],"static CURLcode tftp_receive_packet(struct connectdata *conn)
{
  struct Curl_sockaddr_storage fromaddr;
  curl_socklen_t        fromlen;
  CURLcode              result = CURLE_OK;
  struct Curl_easy  *data = conn->data;
  tftp_state_data_t     *state = (tftp_state_data_t *)conn->proto.tftpc;
  struct SingleRequest  *k = &data->req;

  /* Receive the packet */
  fromlen = sizeof(fromaddr);
  state->rbytes = (int)recvfrom(state->sockfd,
                                (void *)state->rpacket.data,
                                state->blksize + 4,
                                0,
                                (struct sockaddr *)&fromaddr,
                                &fromlen);
  if(state->remote_addrlen == 0) {
    memcpy(&state->remote_addr, &fromaddr, fromlen);
    state->remote_addrlen = fromlen;
  }

  /* Sanity check packet length */
  if(state->rbytes < 4) {
    failf(data, ""Received too short packet"");
    /* Not a timeout, but how best to handle it? */
    state->event = TFTP_EVENT_TIMEOUT;
  }
  else {
    /* The event is given by the TFTP packet time */
    unsigned short event = getrpacketevent(&state->rpacket);
    state->event = (tftp_event_t)event;

    switch(state->event) {
    case TFTP_EVENT_DATA:
      /* Don't pass to the client empty or retransmitted packets */
      if(state->rbytes > 4 &&
         (NEXT_BLOCKNUM(state->block) == getrpacketblock(&state->rpacket))) {
        result = Curl_client_write(conn, CLIENTWRITE_BODY,
                                   (char *)state->rpacket.data + 4,
                                   state->rbytes-4);
        if(result) {
          tftp_state_machine(state, TFTP_EVENT_ERROR);
          return result;
        }
        k->bytecount += state->rbytes-4;
        Curl_pgrsSetDownloadCounter(data, (curl_off_t) k->bytecount);
      }
      break;
    case TFTP_EVENT_ERROR:
    {
      unsigned short error = getrpacketblock(&state->rpacket);
      char *str = (char *)state->rpacket.data + 4;
      size_t strn = state->rbytes - 4;
      state->error = (tftp_error_t)error;
      if(Curl_strnlen(str, strn) < strn)
        infof(data, ""TFTP error: %s\n"", str);
      break;
    }
    case TFTP_EVENT_ACK:
      break;
    case TFTP_EVENT_OACK:
      result = tftp_parse_option_ack(state,
                                     (const char *)state->rpacket.data + 2,
                                     state->rbytes-2);
      if(result)
        return result;
      break;
    case TFTP_EVENT_RRQ:
    case TFTP_EVENT_WRQ:
    default:
      failf(data, ""%s"", ""Internal error: Unexpected packet"");
      break;
    }

    /* Update the progress meter */
    if(Curl_pgrsUpdate(conn)) {
      tftp_state_machine(state, TFTP_EVENT_ERROR);
      return CURLE_ABORTED_BY_CALLBACK;
    }
  }
  return result;
}",curl-curl-7_61_1-1
curl-curl-7_61_1-0,1,['declared_buffer'],"static CURLcode tftp_connect(struct connectdata *conn, bool *done)
{
  tftp_state_data_t *state;
  int blksize;

  blksize = TFTP_BLKSIZE_DEFAULT;

  state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));
  if(!state)
    return CURLE_OUT_OF_MEMORY;

  /* alloc pkt buffers based on specified blksize */
  if(conn->data->set.tftp_blksize) {
    blksize = (int)conn->data->set.tftp_blksize;
    if(blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN)
      return CURLE_TFTP_ILLEGAL;
  }

  if(!state->rpacket.data) {
    state->rpacket.data = calloc(1, blksize + 2 + 2);

    if(!state->rpacket.data)
      return CURLE_OUT_OF_MEMORY;
  }

  if(!state->spacket.data) {
    state->spacket.data = calloc(1, blksize + 2 + 2);

    if(!state->spacket.data)
      return CURLE_OUT_OF_MEMORY;
  }
}",curl-curl-7_61_1-0
curl-curl-7_56_1-0,1,"['overflowed_variable','overflowed_call']","CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char *user, size_t userlen,
                                       const char *domain, size_t domlen,
                                       unsigned char *ntlmhash,
                                       unsigned char *ntlmv2hash)
{
  /* Unicode representation */
  if (userlen > (SIZE_MAX / 2) - domlen)
    return CURLE_OUT_OF_MEMORY;
  size_t identity_len = (userlen + domlen) * 2;
  unsigned char *identity = malloc(identity_len);
  CURLcode result = CURLE_OK;

  if(!identity)
    return CURLE_OUT_OF_MEMORY;

  if (userlen > (SIZE_MAX >> 1))
    return CURLE_OUT_OF_MEMORY;
  ascii_uppercase_to_unicode_le(identity, user, userlen);
  ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);

  result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len),
                         ntlmv2hash);

  free(identity);

  return result;
}",curl-curl-7_56_1-0
cjson-v.1.7.3-0,1,"['freed_variable', 'use_after_free']","static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
{
    if ((object == NULL) || (string == NULL) || (item == NULL))
    {
        return false;
    }

    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
    {
        hooks->deallocate(item->string);
        item->string = NULL;
    }

    if (constant_key)
    {
        item->string = (char*)cast_away_const(string);
        item->type |= cJSON_StringIsConst;
    }
    else
    {
        char *key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
        if (key == NULL)
        {
            return false;
        }

        item->string = key;
        item->type &= ~cJSON_StringIsConst;
    }

    return add_item_to_array(object, item);
}",cjson-v.1.7.3-0
cjson-v.1.7.2-0,1,['second_free'],"static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
{
    static const size_t default_buffer_size = 256;
    printbuffer buffer[1];
    unsigned char *printed = NULL;

    memset(buffer, 0, sizeof(buffer));

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
    buffer->length = default_buffer_size;
    buffer->format = format;
    buffer->hooks = *hooks;
    if (buffer->buffer == NULL)
    {
        goto fail;
    }

    /* print the value */
    if (!print_value(item, buffer))
    {
        goto fail;
    }
    update_offset(buffer);

    /* check if reallocate is available */
    if (hooks->reallocate != NULL)
    {
        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
        buffer->buffer = NULL;
        if (printed == NULL) {
            goto fail;
        }
    }
    else /* otherwise copy the JSON over to a new buffer */
    {
        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
        if (printed == NULL)
        {
            goto fail;
        }
        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
        printed[buffer->offset] = '\0'; /* just to be sure */

        /* free the buffer */
        if (buffer->buffer != NULL) {
            hooks->deallocate(buffer->buffer);
            buffer->buffer = NULL;
        }
    }

    return printed;

fail:
    if (buffer->buffer != NULL)
    {
        hooks->deallocate(buffer->buffer);
        buffer->buffer = NULL;
    }

    if (printed != NULL)
    {
        hooks->deallocate(printed);
    }

    return NULL;
}",cjson-v.1.7.2-0
avian-v1.2.0-0,1,"['overflowed_variable', 'overflowed_call']","{'content': 'void arrayCopy(Thread* t,\n               object src,\n               int32_t srcOffset,\n               object dst,\n               int32_t dstOffset,\n               int32_t length)\n{\n  if (LIKELY(src and dst)) {\n    if (LIKELY(compatibleArrayTypes(\n            t, objectClass(t, src), objectClass(t, dst)))) {\n      unsigned elementSize = objectClass(t, src)->arrayElementSize();\n\n      if (LIKELY(elementSize)) {\n        intptr_t sl = fieldAtOffset<uintptr_t>(src, BytesPerWord);\n        intptr_t dl = fieldAtOffset<uintptr_t>(dst, BytesPerWord);\n        if (LIKELY(length > 0)) {\n          if (LIKELY(srcOffset >= 0 and (int64_t)srcOffset + (int64_t)length <= sl\n                     and dstOffset >= 0 and (int64_t)dstOffset + (int64_t)length <= dl)) {\n            uint8_t* sbody = &fieldAtOffset<uint8_t>(src, ArrayBody);\n            uint8_t* dbody = &fieldAtOffset<uint8_t>(dst, ArrayBody);\n            if (src == dst) {\n              memmove(dbody + (dstOffset * elementSize),\n                      sbody + (srcOffset * elementSize),\n                      length * elementSize);\n            } else {\n              memcpy(dbody + (dstOffset * elementSize),\n                     sbody + (srcOffset * elementSize),\n                     length * elementSize);\n            }\n\n            if (objectClass(t, dst)->objectMask()) {\n              mark(t, dst, ArrayBody + (dstOffset * BytesPerWord), length);\n            }\n\n            return;\n          } else {\n            throwNew(t, GcIndexOutOfBoundsException::Type);\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  } else {\n    throwNew(t, GcNullPointerException::Type);\n    return;\n  }\n\n  throwNew(t, GcArrayStoreException::Type);\n}'}",avian-v1.2.0-0
